"use strict";
// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateDeployment = void 0;
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Manages a template deployment of resources
 *
 * > **Note on ARM Template Deployments:** Due to the way the underlying Azure API is designed, this provider can only manage the deployment of the ARM Template - and not any resources which are created by it.
 * This means that when deleting the `azure.core.TemplateDeployment` resource, this provider will only remove the reference to the deployment, whilst leaving any resources created by that ARM Template Deployment.
 * One workaround for this is to use a unique Resource Group for each ARM Template Deployment, which means deleting the Resource Group would contain any resources created within it - however this isn't ideal. [More information](https://docs.microsoft.com/en-us/rest/api/resources/deployments#Deployments_Delete).
 *
 * ## Example Usage
 *
 * > **Note:** This example uses Storage Accounts and Public IP's which are natively supported by this provider - we'd highly recommend using the Native Resources where possible instead rather than an ARM Template, for the reasons outlined above.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as azure from "@pulumi/azure";
 *
 * const exampleResourceGroup = new azure.core.ResourceGroup("exampleResourceGroup", {location: "West Europe"});
 * const exampleTemplateDeployment = new azure.core.TemplateDeployment("exampleTemplateDeployment", {
 *     resourceGroupName: exampleResourceGroup.name,
 *     templateBody: `{
 *   "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
 *   "contentVersion": "1.0.0.0",
 *   "parameters": {
 *     "storageAccountType": {
 *       "type": "string",
 *       "defaultValue": "Standard_LRS",
 *       "allowedValues": [
 *         "Standard_LRS",
 *         "Standard_GRS",
 *         "Standard_ZRS"
 *       ],
 *       "metadata": {
 *         "description": "Storage Account type"
 *       }
 *     }
 *   },
 *   "variables": {
 *     "location": "[resourceGroup().location]",
 *     "storageAccountName": "[concat(uniquestring(resourceGroup().id), 'storage')]",
 *     "publicIPAddressName": "[concat('myPublicIp', uniquestring(resourceGroup().id))]",
 *     "publicIPAddressType": "Dynamic",
 *     "apiVersion": "2015-06-15",
 *     "dnsLabelPrefix": "example-acctest"
 *   },
 *   "resources": [
 *     {
 *       "type": "Microsoft.Storage/storageAccounts",
 *       "name": "[variables('storageAccountName')]",
 *       "apiVersion": "[variables('apiVersion')]",
 *       "location": "[variables('location')]",
 *       "properties": {
 *         "accountType": "[parameters('storageAccountType')]"
 *       }
 *     },
 *     {
 *       "type": "Microsoft.Network/publicIPAddresses",
 *       "apiVersion": "[variables('apiVersion')]",
 *       "name": "[variables('publicIPAddressName')]",
 *       "location": "[variables('location')]",
 *       "properties": {
 *         "publicIPAllocationMethod": "[variables('publicIPAddressType')]",
 *         "dnsSettings": {
 *           "domainNameLabel": "[variables('dnsLabelPrefix')]"
 *         }
 *       }
 *     }
 *   ],
 *   "outputs": {
 *     "storageAccountName": {
 *       "type": "string",
 *       "value": "[variables('storageAccountName')]"
 *     }
 *   }
 * }
 * `,
 *     parameters: {
 *         storageAccountType: "Standard_GRS",
 *     },
 *     deploymentMode: "Incremental",
 * });
 * export const storageAccountName = exampleTemplateDeployment.outputs.storageAccountName;
 * ```
 * ## Note
 *
 * This provider does not know about the individual resources created by Azure using a deployment template and therefore cannot delete these resources during a destroy. Destroying a template deployment removes the associated deployment operations, but will not delete the Azure resources created by the deployment. In order to delete these resources, the containing resource group must also be destroyed. [More information](https://docs.microsoft.com/en-us/rest/api/resources/deployments#Deployments_Delete).
 */
class TemplateDeployment extends pulumi.CustomResource {
    constructor(name, argsOrState, opts) {
        let resourceInputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState;
            resourceInputs["deploymentMode"] = state ? state.deploymentMode : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["outputs"] = state ? state.outputs : undefined;
            resourceInputs["parameters"] = state ? state.parameters : undefined;
            resourceInputs["parametersBody"] = state ? state.parametersBody : undefined;
            resourceInputs["resourceGroupName"] = state ? state.resourceGroupName : undefined;
            resourceInputs["templateBody"] = state ? state.templateBody : undefined;
        }
        else {
            const args = argsOrState;
            if ((!args || args.deploymentMode === undefined) && !opts.urn) {
                throw new Error("Missing required property 'deploymentMode'");
            }
            if ((!args || args.resourceGroupName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'resourceGroupName'");
            }
            resourceInputs["deploymentMode"] = args ? args.deploymentMode : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["parameters"] = args ? args.parameters : undefined;
            resourceInputs["parametersBody"] = args ? args.parametersBody : undefined;
            resourceInputs["resourceGroupName"] = args ? args.resourceGroupName : undefined;
            resourceInputs["templateBody"] = args ? args.templateBody : undefined;
            resourceInputs["outputs"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(TemplateDeployment.__pulumiType, name, resourceInputs, opts);
    }
    /**
     * Get an existing TemplateDeployment resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new TemplateDeployment(name, state, Object.assign(Object.assign({}, opts), { id: id }));
    }
    /**
     * Returns true if the given object is an instance of TemplateDeployment.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === TemplateDeployment.__pulumiType;
    }
}
exports.TemplateDeployment = TemplateDeployment;
/** @internal */
TemplateDeployment.__pulumiType = 'azure:core/templateDeployment:TemplateDeployment';
//# sourceMappingURL=templateDeployment.js.map