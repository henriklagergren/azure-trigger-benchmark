// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { isTokenCredential } from "@azure/core-auth";
import { eventGridCredentialPolicy } from "./eventGridAuthenticationPolicy";
import { DEFAULT_EVENTGRID_SCOPE } from "./constants";
import { cloudEventReservedPropertyNames, } from "./models";
import { GeneratedClient } from "./generated/generatedClient";
import { cloudEventDistributedTracingEnricherPolicy } from "./cloudEventDistrubtedTracingEnricherPolicy";
import { createSpan } from "./tracing";
import { SpanStatusCode } from "@azure/core-tracing";
import { v4 as uuidv4 } from "uuid";
import { bearerTokenAuthenticationPolicy, tracingPolicyName } from "@azure/core-rest-pipeline";
/**
 * Client class for publishing events to the Event Grid Service.
 */
export class EventGridPublisherClient {
    /**
     * Creates an instance of EventGridPublisherClient which sends events using the Event Grid Schema.
     *
     * Example usage:
     * ```ts
     * import { EventGridPublisherClient, AzureKeyCredential } from "@azure/eventgrid";
     *
     * const client = new EventGridPublisherClient(
     *    "<service endpoint>",
     *    "EventGrid",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     *
     * @param endpointUrl - The URL to the Event Grid endpoint, e.g. https://eg-topic.westus2-1.eventgrid.azure.net/api/events.
     * @param inputSchema - The schema that the Event Grid endpoint is configured to accept. One of "EventGrid", "CloudEvent", or "Custom".
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Event Grid Client.
     */
    constructor(endpointUrl, inputSchema, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        this.inputSchema = inputSchema;
        this.client = new GeneratedClient(options);
        const authPolicy = isTokenCredential(credential)
            ? bearerTokenAuthenticationPolicy({ credential, scopes: DEFAULT_EVENTGRID_SCOPE })
            : eventGridCredentialPolicy(credential);
        this.client.pipeline.addPolicy(authPolicy);
        this.client.pipeline.addPolicy(cloudEventDistributedTracingEnricherPolicy(), {
            afterPolicies: [tracingPolicyName],
        });
        this.apiVersion = this.client.apiVersion;
    }
    /**
     * Sends events to a topic.
     *
     * @param events - The events to send. The events should be in the schema used when constructing the client.
     * @param options - Options to control the underlying operation.
     */
    async send(events, options) {
        const { span, updatedOptions } = createSpan("EventGridPublisherClient-send", options || {});
        try {
            switch (this.inputSchema) {
                case "EventGrid": {
                    return await this.client.publishEvents(this.endpointUrl, events.map(convertEventGridEventToModelType), updatedOptions);
                }
                case "CloudEvent": {
                    return await this.client.publishCloudEventEvents(this.endpointUrl, events.map(convertCloudEventToModelType), updatedOptions);
                }
                case "Custom": {
                    return await this.client.publishCustomEventEvents(this.endpointUrl, events, updatedOptions);
                }
                default: {
                    throw new Error(`Unknown input schema type '${this.inputSchema}'`);
                }
            }
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
}
/**
 * @internal
 */
export function convertEventGridEventToModelType(event) {
    var _a, _b;
    return {
        eventType: event.eventType,
        eventTime: (_a = event.eventTime) !== null && _a !== void 0 ? _a : new Date(),
        id: (_b = event.id) !== null && _b !== void 0 ? _b : uuidv4(),
        subject: event.subject,
        topic: event.topic,
        data: event.data,
        dataVersion: event.dataVersion,
    };
}
/**
 * @internal
 */
export function convertCloudEventToModelType(event) {
    var _a, _b, _c, _d;
    if (event.extensionAttributes) {
        for (const propName in event.extensionAttributes) {
            // Per the cloud events spec: "CloudEvents attribute names MUST consist of lower-case letters ('a' to 'z') or digits ('0' to '9') from the ASCII character set"
            // they also can not match an existing defined property name.
            if (!/^[a-z0-9]*$/.test(propName) ||
                cloudEventReservedPropertyNames.indexOf(propName) !== -1) {
                throw new Error(`invalid extension attribute name: ${propName}`);
            }
        }
    }
    const converted = Object.assign({ specversion: "1.0", type: event.type, source: event.source, id: (_a = event.id) !== null && _a !== void 0 ? _a : uuidv4(), time: (_b = event.time) !== null && _b !== void 0 ? _b : new Date(), subject: event.subject, dataschema: event.dataschema }, ((_c = event.extensionAttributes) !== null && _c !== void 0 ? _c : []));
    if (event.data instanceof Uint8Array) {
        if (!event.datacontenttype) {
            throw new Error("a data content type must be provided when sending an event with binary data");
        }
        converted.datacontenttype = event.datacontenttype;
        converted.dataBase64 = event.data;
    }
    else {
        converted.datacontenttype = (_d = event.datacontenttype) !== null && _d !== void 0 ? _d : "application/json";
        converted.data = event.data;
    }
    return converted;
}
//# sourceMappingURL=eventGridClient.js.map