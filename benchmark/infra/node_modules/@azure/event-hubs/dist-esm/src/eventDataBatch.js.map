{"version":3,"file":"eventDataBatch.js","sourceRoot":"","sources":["../../src/eventDataBatch.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { EventData, isAmqpAnnotatedMessage, toRheaMessage } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { MessageAnnotations, message, Message as RheaMessage } from \"rhea-promise\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { Span, SpanContext } from \"@azure/core-tracing\";\nimport { TRACEPARENT_PROPERTY, instrumentEventData } from \"./diagnostics/instrumentEventData\";\nimport { convertTryAddOptionsForCompatibility, createMessageSpan } from \"./diagnostics/tracing\";\nimport { isDefined, isObjectWithProperties } from \"./util/typeGuards\";\nimport { OperationTracingOptions } from \"@azure/core-tracing\";\n\n/**\n * The amount of bytes to reserve as overhead for a small message.\n */\nconst smallMessageOverhead = 5;\n/**\n * The amount of bytes to reserve as overhead for a large message.\n */\nconst largeMessageOverhead = 8;\n/**\n * The maximum number of bytes that a message may be to be considered small.\n */\nconst smallMessageMaxBytes = 255;\n\n/**\n * Checks if the provided eventDataBatch is an instance of `EventDataBatch`.\n * @param eventDataBatch - The instance of `EventDataBatch` to verify.\n * @internal\n */\nexport function isEventDataBatch(eventDataBatch: unknown): eventDataBatch is EventDataBatch {\n  return (\n    isObjectWithProperties(eventDataBatch, [\"count\", \"sizeInBytes\", \"tryAdd\"]) &&\n    typeof eventDataBatch.tryAdd === \"function\" &&\n    typeof eventDataBatch.count === \"number\" &&\n    typeof eventDataBatch.sizeInBytes === \"number\"\n  );\n}\n\n/**\n * Options to configure the behavior of the `tryAdd` method on the `EventDataBatch` class.\n */\nexport interface TryAddOptions {\n  /**\n   * The options to use when creating Spans for tracing.\n   */\n  tracingOptions?: OperationTracingOptions;\n\n  /**\n   * @deprecated Tracing options have been moved to the `tracingOptions` property.\n   */\n  parentSpan?: Span | SpanContext;\n}\n\n/**\n * An interface representing a batch of events which can be used to send events to Event Hub.\n *\n * To create the batch, use the `createBatch()` method on the `EventHubProducerClient`.\n * To send the batch, use the `sendBatch()` method on the same client.\n * To fill the batch, use the `tryAdd()` method on the batch itself.\n *\n */\nexport interface EventDataBatch {\n  /**\n   * A value that is hashed and used by the Azure Event Hubs service to determine the partition to\n   * which the events are sent. Use the `createBatch()` method on the `EventHubProducerClient` to\n   * set the partitionKey.\n   * @readonly\n   * @internal\n   */\n  readonly partitionKey?: string;\n\n  /**\n   * Id of the partition to which the batch of events are sent. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the partitionId.\n   * @readonly\n   * @internal\n   */\n  readonly partitionId?: string;\n\n  /**\n   * Size of the batch in bytes after the events added to it have been encoded into a single AMQP\n   * message.\n   * @readonly\n   */\n  readonly sizeInBytes: number;\n\n  /**\n   * Number of events added to the batch.\n   * @readonly\n   */\n  readonly count: number;\n\n  /**\n   * The maximum size of the batch, in bytes. The `tryAdd` function on the batch will return `false`\n   * if the event being added causes the size of the batch to exceed this limit. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the maxSizeInBytes.\n   * @readonly\n   */\n  readonly maxSizeInBytes: number;\n\n  /**\n   * Adds an event to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData -  An individual event data object or AmqpAnnotatedMessage.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  tryAdd(eventData: EventData | AmqpAnnotatedMessage, options?: TryAddOptions): boolean;\n\n  /**\n   * The AMQP message containing encoded events that were added to the batch.\n   * Used internally by the `sendBatch()` method on the `EventHubProducerClient`.\n   * This is not meant for the user to use directly.\n   *\n   * @internal\n   */\n  _generateMessage(): Buffer;\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * Used internally by the `sendBatch()` method to set up the right spans in traces if tracing is enabled.\n   * @internal\n   */\n  readonly _messageSpanContexts: SpanContext[];\n}\n\n/**\n * An internal class representing a batch of events which can be used to send events to Event Hub.\n *\n * @internal\n */\nexport class EventDataBatchImpl implements EventDataBatch {\n  /**\n   * Describes the amqp connection context for the Client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * The Id of the partition to which the batch is expected to be sent to.\n   * Specifying this will throw an error if the batch was created using a `paritionKey`.\n   */\n  private _partitionId?: string;\n  /**\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the batch was created using a `paritionId`.\n   */\n  private _partitionKey?: string;\n  /**\n   * The maximum size allowed for the batch.\n   */\n  private _maxSizeInBytes: number;\n  /**\n   * Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * Number of events in the batch.\n   */\n  private _count: number;\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: SpanContext[] = [];\n  /**\n   * The message annotations to apply on the batch envelope.\n   * This will reflect the message annotations on the first event\n   * that was added to the batch.\n   * A common annotation is the partition key.\n   */\n  private _batchAnnotations?: MessageAnnotations;\n\n  /**\n   * EventDataBatch should not be constructed using `new EventDataBatch()`\n   * Use the `createBatch()` method on your `EventHubProducer` instead.\n   * @internal\n   */\n  constructor(\n    context: ConnectionContext,\n    maxSizeInBytes: number,\n    partitionKey?: string,\n    partitionId?: string\n  ) {\n    this._context = context;\n    this._maxSizeInBytes = maxSizeInBytes;\n    this._partitionKey = isDefined(partitionKey) ? String(partitionKey) : partitionKey;\n    this._partitionId = isDefined(partitionId) ? String(partitionId) : partitionId;\n    this._sizeInBytes = 0;\n    this._count = 0;\n  }\n\n  /**\n   * The maximum size of the batch, in bytes.\n   * @readonly\n   */\n  get maxSizeInBytes(): number {\n    return this._maxSizeInBytes;\n  }\n\n  /**\n   * The partitionKey set during `EventDataBatch` creation. This value is hashed to\n   * produce a partition assignment when the producer is created without a `partitionId`\n   * @readonly\n   */\n  get partitionKey(): string | undefined {\n    return this._partitionKey;\n  }\n\n  /**\n   * The partitionId set during `EventDataBatch` creation.\n   * If this value is set then partitionKey can not be set.\n   * @readonly\n   */\n  get partitionId(): string | undefined {\n    return this._partitionId;\n  }\n\n  /**\n   * Size of the `EventDataBatch` instance after the events added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * Number of events in the `EventDataBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * @internal\n   */\n  get _messageSpanContexts(): SpanContext[] {\n    return this._spanContexts;\n  }\n\n  /**\n   * Generates an AMQP message that contains the provided encoded events and annotations.\n   * @param encodedEvents - The already encoded events to include in the AMQP batch.\n   * @param annotations - The message annotations to set on the batch.\n   */\n  private _generateBatch(encodedEvents: Buffer[], annotations?: MessageAnnotations): Buffer {\n    const batchEnvelope: RheaMessage = {\n      body: message.data_sections(encodedEvents)\n    };\n    if (annotations) {\n      batchEnvelope.message_annotations = annotations;\n    }\n    return message.encode(batchEnvelope);\n  }\n\n  /**\n   * Generates the single AMQP message which is the result of encoding all the events\n   * added into the `EventDataBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  _generateMessage(): Buffer {\n    return this._generateBatch(this._encodedMessages, this._batchAnnotations);\n  }\n\n  /**\n   * Tries to add an event data to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData -  An individual event data object.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  public tryAdd(eventData: EventData | AmqpAnnotatedMessage, options: TryAddOptions = {}): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"tryAdd\", \"eventData\", eventData);\n    options = convertTryAddOptionsForCompatibility(options);\n\n    // check if the event has already been instrumented\n    const previouslyInstrumented = Boolean(\n      (isAmqpAnnotatedMessage(eventData)\n        ? eventData.applicationProperties\n        : eventData.properties)?.[TRACEPARENT_PROPERTY] // Event Data maps properties to applicationProperties.\n    );\n    let spanContext: SpanContext | undefined;\n    if (!previouslyInstrumented) {\n      const { span: messageSpan } = createMessageSpan(options, this._context.config);\n      eventData = instrumentEventData(eventData, messageSpan);\n      spanContext = messageSpan.spanContext();\n      messageSpan.end();\n    }\n\n    // Convert EventData to RheaMessage.\n    const amqpMessage = toRheaMessage(eventData, this._partitionKey);\n    const encodedMessage = message.encode(amqpMessage);\n\n    let currentSize = this._sizeInBytes;\n    // The first time an event is added, we need to calculate\n    // the overhead of creating an AMQP batch, including the\n    // message_annotations that are taken from the 1st message.\n    if (this.count === 0) {\n      if (amqpMessage.message_annotations) {\n        this._batchAnnotations = amqpMessage.message_annotations;\n      }\n\n      // Figure out the overhead of creating a batch by generating an empty batch\n      // with the expected batch annotations.\n      currentSize += this._generateBatch([], this._batchAnnotations).length;\n    }\n\n    const messageSize = encodedMessage.length;\n    const messageOverhead =\n      messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;\n    currentSize += messageSize + messageOverhead;\n\n    // Check if the size of the batch exceeds the maximum allowed size\n    // once we add the new event to it.\n    if (currentSize > this._maxSizeInBytes) {\n      return false;\n    }\n\n    // The event will fit in the batch, so it is now safe to store it.\n    this._encodedMessages.push(encodedMessage);\n    if (spanContext) {\n      this._spanContexts.push(spanContext);\n    }\n\n    this._sizeInBytes = currentSize;\n    this._count++;\n    return true;\n  }\n}\n"]}