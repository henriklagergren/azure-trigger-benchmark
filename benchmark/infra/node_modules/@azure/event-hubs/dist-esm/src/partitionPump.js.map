{"version":3,"file":"partitionPump.js","sourceRoot":"","sources":["../../src/partitionPump.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,kBAAkB,EAAE,MAAM,EAAE,MAAM,OAAO,CAAC;AAEnD,OAAO,EAAE,WAAW,EAAE,MAAM,iBAAiB,CAAC;AAG9C,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACtD,OAAO,EAAE,eAAe,EAAE,MAAM,yBAAyB,CAAC;AAG1D,OAAO,EAAE,cAAc,EAAc,QAAQ,EAAE,MAAM,qBAAqB,CAAC;AAC3E,OAAO,EAAE,+BAA+B,EAAE,MAAM,mCAAmC,CAAC;AAGpF,OAAO,EAAE,kBAAkB,EAAE,MAAM,uBAAuB,CAAC;AAG3D;;GAEG;AACH,MAAM,OAAO,aAAa;IAOxB,YACU,QAA2B,EACnC,kBAAsC,EACrB,cAA6B,EAC9C,OAAoC;QAH5B,aAAQ,GAAR,QAAQ,CAAmB;QAElB,mBAAc,GAAd,cAAc,CAAe;QANxC,iBAAY,GAAY,KAAK,CAAC;QAC9B,eAAU,GAAY,KAAK,CAAC;QAQlC,IAAI,CAAC,mBAAmB,GAAG,kBAAkB,CAAC;QAC9C,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC;QACjC,IAAI,CAAC,gBAAgB,GAAG,IAAI,eAAe,EAAE,CAAC;IAChD,CAAC;IAED,IAAW,WAAW;QACpB,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED,KAAK,CAAC,KAAK;QACT,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QACzB,IAAI;YACF,MAAM,IAAI,CAAC,mBAAmB,CAAC,UAAU,EAAE,CAAC;SAC7C;QAAC,OAAO,GAAG,EAAE;YACZ,+CAA+C;YAC/C,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;SAC5C;QAED,+EAA+E;QAC/E,gDAAgD;QAChD,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,CAAC;QAC1D,MAAM,CAAC,IAAI,CACT,oDAAoD,IAAI,CAAC,mBAAmB,CAAC,WAAW,IAAI,CAC7F,CAAC;IACJ,CAAC;IAED;;;;;OAKG;IACK,qBAAqB,CAC3B,WAAmB,EACnB,sBAA8B;QAE9B,kDAAkD;QAClD,uEAAuE;QACvE,mCAAmC;QACnC,uCAAuC;QACvC,MAAM,oBAAoB,GACxB,sBAAsB,IAAI,CAAC;YACzB,CAAC,CAAC;gBACE,cAAc,EAAE,sBAAsB;gBACtC,WAAW,EAAE,KAAK;aACnB;YACH,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC;QAE1B,+CAA+C;QAC/C,IAAI,CAAC,SAAS,GAAG,IAAI,gBAAgB,CACnC,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,mBAAmB,CAAC,aAAa,EACtC,WAAW,EACX,oBAAoB,EACpB;YACE,UAAU,EAAE,IAAI,CAAC,iBAAiB,CAAC,UAAU;YAC7C,gCAAgC,EAAE,IAAI,CAAC,iBAAiB,CAAC,gCAAgC;YACzF,YAAY,EAAE,IAAI,CAAC,iBAAiB,CAAC,YAAY;YACjD,qBAAqB,EAAE,IAAI,CAAC,iBAAiB,CAAC,qBAAqB;SACpE,CACF,CAAC;QAEF,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAEO,KAAK,CAAC,cAAc,CAAC,WAAmB;QAC9C,IAAI,sBAAsB,GAAG,CAAC,CAAC,CAAC;QAChC,IAAI,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,sBAAsB,CAAC,CAAC;QAE/E,OAAO,IAAI,CAAC,YAAY,EAAE;YACxB,IAAI;gBACF,0DAA0D;gBAC1D,IAAI,QAAQ,CAAC,QAAQ,EAAE;oBACrB,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,sBAAsB,CAAC,CAAC;iBAC5E;gBAED,MAAM,cAAc,GAAG,MAAM,QAAQ,CAAC,YAAY,CAChD,IAAI,CAAC,iBAAiB,CAAC,YAAY,EACnC,IAAI,CAAC,iBAAiB,CAAC,oBAAoB,EAC3C,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAC7B,CAAC;gBAEF,IACE,IAAI,CAAC,iBAAiB,CAAC,gCAAgC;oBACvD,QAAQ,CAAC,2BAA2B,EACpC;oBACA,IAAI,CAAC,mBAAmB,CAAC,2BAA2B;wBAClD,QAAQ,CAAC,2BAA2B,CAAC;iBACxC;gBACD,4FAA4F;gBAC5F,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACtB,OAAO;iBACR;gBAED,IAAI,cAAc,CAAC,MAAM,EAAE;oBACzB,sBAAsB,GAAG,cAAc,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,cAAc,CAAC;iBACnF;gBAED,MAAM,IAAI,GAAG,oBAAoB,CAC/B,cAAc,EACd,IAAI,CAAC,QAAQ,CAAC,MAAM,EACpB,IAAI,CAAC,iBAAiB,CACvB,CAAC;gBAEF,MAAM,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,mBAAmB,CAAC,aAAa,CAAC,cAAc,CAAC,EAAE,IAAI,CAAC,CAAC;aACjF;YAAC,OAAO,GAAG,EAAE;gBACZ,wCAAwC;gBACxC,uEAAuE;gBACvE,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACtB,+DAA+D;oBAC/D,OAAO;iBACR;gBAED,MAAM,CAAC,OAAO,CACZ,0EAA0E,IAAI,CAAC,mBAAmB,CAAC,WAAW,GAAG,CAClH,CAAC;gBACF,kBAAkB,CAAC,GAAG,CAAC,CAAC;gBACxB,yEAAyE;gBACzE,IAAI;oBACF,MAAM,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;iBAClD;gBAAC,OAAO,aAAa,EAAE;oBACtB,8DAA8D;oBAC9D,MAAM,CAAC,OAAO,CAAC,qDAAqD,EAAE,aAAa,CAAC,CAAC;iBACtF;gBAED,yEAAyE;gBACzE,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,CAAE,GAAsB,CAAC,SAAS,EAAE;oBACjE,IAAI;wBACF,yGAAyG;wBACzG,2DAA2D;wBAC3D,IAAI,GAAG,CAAC,IAAI,KAAK,2BAA2B,EAAE;4BAC5C,OAAO,MAAM,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;yBACnD;wBACD,mEAAmE;wBACnE,OAAO,MAAM,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;qBAC9C;oBAAC,OAAO,aAAa,EAAE;wBACtB,8DAA8D;wBAC9D,MAAM,CAAC,OAAO,CACZ,4DAA4D,WAAW,CAAC,QAAQ,IAAI,EACpF,aAAa,CACd,CAAC;qBACH;iBACF;aACF;SACF;IACH,CAAC;IAED,KAAK,CAAC,IAAI,CAAC,MAAmB;QAC5B,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,OAAO;SACR;QACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAC1B,IAAI;YACF,wDAAwD;YACxD,qEAAqE;YACrE,wCAAwC;YACxC,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC;YAE9B,IAAI,IAAI,CAAC,SAAS,EAAE;gBAClB,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;aAC9B;YACD,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;SAC9C;QAAC,OAAO,GAAG,EAAE;YACZ,MAAM,CAAC,OAAO,CAAC,iDAAiD,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,IAAI,KAAK,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,OAAO,EAAE,CAAC,CAAC;YAC9F,kBAAkB,CAAC,GAAG,CAAC,CAAC;YACxB,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;YAC3C,MAAM,GAAG,CAAC;SACX;IACH,CAAC;CACF;AAED;;GAEG;AACH,MAAM,UAAU,oBAAoB,CAClC,cAAmC,EACnC,kBAAyE,EACzE,OAA0B;IAE1B,MAAM,KAAK,GAAW,EAAE,CAAC;IAEzB,KAAK,MAAM,aAAa,IAAI,cAAc,EAAE;QAC1C,MAAM,WAAW,GAAG,+BAA+B,CAAC,aAAa,CAAC,CAAC;QAEnE,IAAI,WAAW,IAAI,IAAI,EAAE;YACvB,SAAS;SACV;QAED,KAAK,CAAC,IAAI,CAAC;YACT,OAAO,EAAE,WAAW;YACpB,UAAU,EAAE;gBACV,YAAY,EAAE,aAAa,CAAC,eAAe,CAAC,OAAO,EAAE;aACtD;SACF,CAAC,CAAC;KACJ;IAED,MAAM,EAAE,IAAI,EAAE,GAAG,kBAAkB,CAAC,SAAS,EAAE,OAAO,EAAE,kBAAkB,EAAE;QAC1E,IAAI,EAAE,QAAQ,CAAC,QAAQ;QACvB,KAAK;KACN,CAAC,CAAC;IAEH,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,KAAK,CAAC,EAAuB,EAAE,IAAU;IAC7D,IAAI;QACF,MAAM,EAAE,EAAE,CAAC;QACX,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,cAAc,CAAC,EAAE,EAAE,CAAC,CAAC;KAC7C;IAAC,OAAO,GAAG,EAAE;QACZ,IAAI,CAAC,SAAS,CAAC;YACb,IAAI,EAAE,cAAc,CAAC,KAAK;YAC1B,OAAO,EAAE,GAAG,CAAC,OAAO;SACrB,CAAC,CAAC;QACH,MAAM,GAAG,CAAC;KACX;YAAS;QACR,IAAI,CAAC,GAAG,EAAE,CAAC;KACZ;AACH,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { CloseReason } from \"./models/public\";\nimport { EventPosition } from \"./eventPosition\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { EventHubReceiver } from \"./eventHubReceiver\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { MessagingError } from \"@azure/core-amqp\";\nimport { OperationOptions } from \"./util/operationOptions\";\nimport { SpanStatusCode, Link, Span, SpanKind } from \"@azure/core-tracing\";\nimport { extractSpanContextFromEventData } from \"./diagnostics/instrumentEventData\";\nimport { ReceivedEventData } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { createEventHubSpan } from \"./diagnostics/tracing\";\nimport { EventHubConnectionConfig } from \"./eventhubConnectionConfig\";\n\n/**\n * @internal\n */\nexport class PartitionPump {\n  private _partitionProcessor: PartitionProcessor;\n  private _processorOptions: CommonEventProcessorOptions;\n  private _receiver: EventHubReceiver | undefined;\n  private _isReceiving: boolean = false;\n  private _isStopped: boolean = false;\n  private _abortController: AbortController;\n  constructor(\n    private _context: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    private readonly _startPosition: EventPosition,\n    options: CommonEventProcessorOptions\n  ) {\n    this._partitionProcessor = partitionProcessor;\n    this._processorOptions = options;\n    this._abortController = new AbortController();\n  }\n\n  public get isReceiving(): boolean {\n    return this._isReceiving;\n  }\n\n  async start(): Promise<void> {\n    this._isReceiving = true;\n    try {\n      await this._partitionProcessor.initialize();\n    } catch (err) {\n      // swallow the error from the user-defined code\n      this._partitionProcessor.processError(err);\n    }\n\n    // this is intentionally not await'd - the _receiveEvents loop will continue to\n    // execute and can be stopped by calling .stop()\n    this._receiveEvents(this._partitionProcessor.partitionId);\n    logger.info(\n      `Successfully started the receiver for partition \"${this._partitionProcessor.partitionId}\".`\n    );\n  }\n\n  /**\n   * Creates a new `EventHubReceiver` and replaces any existing receiver.\n   * @param partitionId - The partition the receiver should read messages from.\n   * @param lastSeenSequenceNumber - The sequence number to begin receiving messages from (exclusive).\n   * If `-1`, then the PartitionPump's startPosition will be used instead.\n   */\n  private _setOrReplaceReceiver(\n    partitionId: string,\n    lastSeenSequenceNumber: number\n  ): EventHubReceiver {\n    // Determine what the new EventPosition should be.\n    // If this PartitionPump has received events, we'll start from the last\n    // seen sequenceNumber (exclusive).\n    // Otherwise, use the `_startPosition`.\n    const currentEventPosition: EventPosition =\n      lastSeenSequenceNumber >= 0\n        ? {\n            sequenceNumber: lastSeenSequenceNumber,\n            isInclusive: false\n          }\n        : this._startPosition;\n\n    // Set or replace the PartitionPump's receiver.\n    this._receiver = new EventHubReceiver(\n      this._context,\n      this._partitionProcessor.consumerGroup,\n      partitionId,\n      currentEventPosition,\n      {\n        ownerLevel: this._processorOptions.ownerLevel,\n        trackLastEnqueuedEventProperties: this._processorOptions.trackLastEnqueuedEventProperties,\n        retryOptions: this._processorOptions.retryOptions,\n        skipParsingBodyAsJson: this._processorOptions.skipParsingBodyAsJson\n      }\n    );\n\n    return this._receiver;\n  }\n\n  private async _receiveEvents(partitionId: string): Promise<void> {\n    let lastSeenSequenceNumber = -1;\n    let receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n\n    while (this._isReceiving) {\n      try {\n        // Check if the receiver was closed so we can recreate it.\n        if (receiver.isClosed) {\n          receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n        }\n\n        const receivedEvents = await receiver.receiveBatch(\n          this._processorOptions.maxBatchSize,\n          this._processorOptions.maxWaitTimeInSeconds,\n          this._abortController.signal\n        );\n\n        if (\n          this._processorOptions.trackLastEnqueuedEventProperties &&\n          receiver.lastEnqueuedEventProperties\n        ) {\n          this._partitionProcessor.lastEnqueuedEventProperties =\n            receiver.lastEnqueuedEventProperties;\n        }\n        // avoid calling user's processEvents handler if the pump was stopped while receiving events\n        if (!this._isReceiving) {\n          return;\n        }\n\n        if (receivedEvents.length) {\n          lastSeenSequenceNumber = receivedEvents[receivedEvents.length - 1].sequenceNumber;\n        }\n\n        const span = createProcessingSpan(\n          receivedEvents,\n          this._context.config,\n          this._processorOptions\n        );\n\n        await trace(() => this._partitionProcessor.processEvents(receivedEvents), span);\n      } catch (err) {\n        // check if this pump is still receiving\n        // it may not be if the EventProcessor was stopped during processEvents\n        if (!this._isReceiving) {\n          // no longer receiving, so close was called from somewhere else\n          return;\n        }\n\n        logger.warning(\n          `An error was thrown while receiving or processing events on partition \"${this._partitionProcessor.partitionId}\"`\n        );\n        logErrorStackTrace(err);\n        // forward error to user's processError and swallow errors they may throw\n        try {\n          await this._partitionProcessor.processError(err);\n        } catch (errorFromUser) {\n          // Using verbose over warning because this error is swallowed.\n          logger.verbose(\"An error was thrown by user's processError method: \", errorFromUser);\n        }\n\n        // close the partition processor if a non-retryable error was encountered\n        if (typeof err !== \"object\" || !(err as MessagingError).retryable) {\n          try {\n            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel\n            // started consuming the partition), update the closeReason\n            if (err.code === \"ReceiverDisconnectedError\") {\n              return await this.stop(CloseReason.OwnershipLost);\n            }\n            // this will close the pump and will break us out of the while loop\n            return await this.stop(CloseReason.Shutdown);\n          } catch (errorFromStop) {\n            // Using verbose over warning because this error is swallowed.\n            logger.verbose(\n              `An error occurred while closing the receiver with reason ${CloseReason.Shutdown}: `,\n              errorFromStop\n            );\n          }\n        }\n      }\n    }\n  }\n\n  async stop(reason: CloseReason): Promise<void> {\n    if (this._isStopped) {\n      return;\n    }\n    this._isStopped = true;\n    this._isReceiving = false;\n    try {\n      // Trigger the cancellation before closing the receiver,\n      // otherwise the receiver will remove the listener on the abortSignal\n      // before it has a chance to be emitted.\n      this._abortController.abort();\n\n      if (this._receiver) {\n        await this._receiver.close();\n      }\n      await this._partitionProcessor.close(reason);\n    } catch (err) {\n      logger.warning(`An error occurred while closing the receiver: ${err?.name}: ${err?.message}`);\n      logErrorStackTrace(err);\n      this._partitionProcessor.processError(err);\n      throw err;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function createProcessingSpan(\n  receivedEvents: ReceivedEventData[],\n  eventHubProperties: Pick<EventHubConnectionConfig, \"entityPath\" | \"host\">,\n  options?: OperationOptions\n): Span {\n  const links: Link[] = [];\n\n  for (const receivedEvent of receivedEvents) {\n    const spanContext = extractSpanContextFromEventData(receivedEvent);\n\n    if (spanContext == null) {\n      continue;\n    }\n\n    links.push({\n      context: spanContext,\n      attributes: {\n        enqueuedTime: receivedEvent.enqueuedTimeUtc.getTime()\n      }\n    });\n  }\n\n  const { span } = createEventHubSpan(\"process\", options, eventHubProperties, {\n    kind: SpanKind.CONSUMER,\n    links\n  });\n\n  return span;\n}\n\n/**\n * @internal\n */\nexport async function trace(fn: () => Promise<void>, span: Span): Promise<void> {\n  try {\n    await fn();\n    span.setStatus({ code: SpanStatusCode.OK });\n  } catch (err) {\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: err.message\n    });\n    throw err;\n  } finally {\n    span.end();\n  }\n}\n"]}