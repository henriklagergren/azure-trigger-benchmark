{"version":3,"file":"index.js","sources":["../src/util/typeGuards.ts","../src/log.ts","../src/util/runtimeInfo.ts","../src/util/constants.ts","../src/util/connectionStringUtils.ts","../src/util/retries.ts","../src/linkEntity.ts","../src/util/error.ts","../src/diagnostics/tracing.ts","../src/managementClient.ts","../src/util/parseEndpoint.ts","../src/eventhubConnectionConfig.ts","../src/connectionContext.ts","../src/inMemoryCheckpointStore.ts","../src/models/public.ts","../src/dataTransformer.ts","../src/eventData.ts","../src/eventPosition.ts","../src/eventHubReceiver.ts","../src/diagnostics/instrumentEventData.ts","../src/partitionPump.ts","../src/pumpManager.ts","../src/partitionProcessor.ts","../src/util/delayWithoutThrow.ts","../src/eventProcessor.ts","../src/impl/partitionGate.ts","../src/loadBalancerStrategies/unbalancedStrategy.ts","../src/loadBalancerStrategies/loadBalancingStrategy.ts","../src/loadBalancerStrategies/greedyStrategy.ts","../src/loadBalancerStrategies/balancedStrategy.ts","../src/eventHubConsumerClient.ts","../src/eventDataBatch.ts","../src/eventHubSender.ts","../src/eventHubProducerClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  isNamedKeyCredential,\n  isSASCredential,\n  isTokenCredential,\n  NamedKeyCredential,\n  SASCredential,\n  TokenCredential\n} from \"@azure/core-auth\";\n\n/**\n * Helper TypeGuard that checks if something is defined or not.\n * @param thing - Anything\n * @internal\n */\nexport function isDefined<T>(thing: T | undefined | null): thing is T {\n  return typeof thing !== \"undefined\" && thing !== null;\n}\n\n/**\n * Helper TypeGuard that checks if the input is an object with the specified properties.\n * @param thing - Anything.\n * @param properties - The name of the properties that should appear in the object.\n * @internal\n */\nexport function isObjectWithProperties<Thing extends unknown, PropertyName extends string>(\n  thing: Thing,\n  properties: PropertyName[]\n): thing is Thing & Record<PropertyName, unknown> {\n  if (!isDefined(thing) || typeof thing !== \"object\") {\n    return false;\n  }\n\n  for (const property of properties) {\n    if (!objectHasProperty(thing, property)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Helper TypeGuard that checks if the input is an object with the specified property.\n * @param thing - Any object.\n * @param property - The name of the property that should appear in the object.\n * @internal\n */\nexport function objectHasProperty<Thing extends unknown, PropertyName extends string>(\n  thing: Thing,\n  property: PropertyName\n): thing is Thing & Record<PropertyName, unknown> {\n  return typeof thing === \"object\" && property in (thing as Record<string, unknown>);\n}\n\n/**\n * Typeguard that checks if the input is a credential type the clients accept.\n * @param thing - Any object.\n * @internal\n */\nexport function isCredential(\n  thing: unknown\n): thing is TokenCredential | NamedKeyCredential | SASCredential {\n  return isTokenCredential(thing) || isNamedKeyCredential(thing) || isSASCredential(thing);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\nimport { isObjectWithProperties } from \"./util/typeGuards\";\n\n/**\n * The `@azure/logger` configuration for this package.\n * This will output logs using the `azure:event-hubs` namespace prefix.\n */\nexport const logger = createClientLogger(\"event-hubs\");\n\n/**\n * Logs the error's stack trace to \"verbose\" if a stack trace is available.\n * @param error - Error containing a stack trace.\n * @hidden\n */\nexport function logErrorStackTrace(error: unknown): void {\n  if (isObjectWithProperties(error, [\"stack\"]) && error.stack) {\n    logger.verbose(error.stack);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as os from \"os\";\n\n/**\n * Returns information about the platform this function is being run on.\n * @internal\n */\nexport function getRuntimeInfo(): string {\n  return `NODE-VERSION ${process.version}; ${os.type()} ${os.release()}`;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * @hidden\n */\nexport const packageJsonInfo = {\n  name: \"@azure/event-hubs\",\n  version: \"5.7.0\"\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { parseConnectionString } from \"@azure/core-amqp\";\n\n/**\n * The set of properties that comprise an Event Hub connection string.\n */\nexport interface EventHubConnectionStringProperties {\n  /**\n   * The fully qualified Event Hub namespace extracted from the \"Endpoint\" in the\n   * connection string. This is likely to be similar to `{yournamespace}.servicebus.windows.net`.\n   * This is typically used to construct an EventHubProducerClient or an EventHubConsumerClient.\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The value for \"Endpoint\" in the connection string.\n   */\n  endpoint: string;\n  /**\n   * The value for \"EntityPath\" in the connection string which would be the name of the event hub instance associated with the connection string.\n   * Connection string from a Shared Access Policy created at the namespace level\n   * will not have the EntityPath in it.\n   */\n  eventHubName?: string;\n  /**\n   * The value for \"SharedAccessKey\" in the connection string. This along with the \"SharedAccessKeyName\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKey?: string;\n  /**\n   * The value for \"SharedAccessKeyName\" in the connection string. This along with the \"SharedAccessKey\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKeyName?: string;\n  /**\n   * The value for \"SharedAccessSignature\" in the connection string. This is typically not present in the\n   * connection string generated for a Shared Access Policy. It is instead generated by the\n   * user and appended to the connection string for ease of use.\n   */\n  sharedAccessSignature?: string;\n}\n\n/**\n * Parses given connection string into the different properties applicable to Azure Event Hubs.\n * The properties are useful to then construct an EventHubProducerClient or an EventHubConsumerClient.\n * @param connectionString - The connection string associated with the Shared Access Policy created\n * for the Event Hubs namespace.\n */\nexport function parseEventHubConnectionString(\n  connectionString: string\n): Readonly<EventHubConnectionStringProperties> {\n  const parsedResult = parseConnectionString<{\n    Endpoint: string;\n    EntityPath?: string;\n    SharedAccessSignature?: string;\n    SharedAccessKey?: string;\n    SharedAccessKeyName?: string;\n  }>(connectionString);\n\n  validateProperties(\n    parsedResult.Endpoint,\n    parsedResult.SharedAccessSignature,\n    parsedResult.SharedAccessKey,\n    parsedResult.SharedAccessKeyName\n  );\n\n  const output: EventHubConnectionStringProperties = {\n    fullyQualifiedNamespace: (parsedResult.Endpoint.match(\".*://([^/]*)\") || [])[1],\n    endpoint: parsedResult.Endpoint\n  };\n\n  if (parsedResult.EntityPath) {\n    output.eventHubName = parsedResult.EntityPath;\n  }\n\n  if (parsedResult.SharedAccessSignature) {\n    output.sharedAccessSignature = parsedResult.SharedAccessSignature;\n  }\n\n  if (parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {\n    output.sharedAccessKey = parsedResult.SharedAccessKey;\n    output.sharedAccessKeyName = parsedResult.SharedAccessKeyName;\n  }\n\n  return output;\n}\n\n/**\n * @internal\n */\nfunction validateProperties(\n  endpoint?: string,\n  sharedAccessSignature?: string,\n  sharedAccessKey?: string,\n  sharedAccessKeyName?: string\n): void {\n  if (!endpoint) {\n    throw new Error(\"Connection string should have an Endpoint key.\");\n  }\n\n  if (sharedAccessSignature) {\n    if (sharedAccessKey || sharedAccessKeyName) {\n      throw new Error(\n        \"Connection string cannot have both SharedAccessSignature and SharedAccessKey keys.\"\n      );\n    }\n  } else if (sharedAccessKey && !sharedAccessKeyName) {\n    throw new Error(\"Connection string with SharedAccessKey should have SharedAccessKeyName.\");\n  } else if (!sharedAccessKey && sharedAccessKeyName) {\n    throw new Error(\n      \"Connection string with SharedAccessKeyName should have SharedAccessKey as well.\"\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants, RetryOptions } from \"@azure/core-amqp\";\nimport { isDefined } from \"./typeGuards\";\n\n/**\n * @internal\n */\nexport function getRetryAttemptTimeoutInMs(retryOptions: RetryOptions | undefined): number {\n  const timeoutInMs =\n    !isDefined(retryOptions) ||\n    typeof retryOptions.timeoutInMs !== \"number\" ||\n    !isFinite(retryOptions.timeoutInMs) ||\n    retryOptions.timeoutInMs < Constants.defaultOperationTimeoutInMs\n      ? Constants.defaultOperationTimeoutInMs\n      : retryOptions.timeoutInMs;\n  return timeoutInMs;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport { Constants, TokenType, defaultCancellableLock, isSasTokenProvider } from \"@azure/core-amqp\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { AwaitableSender, Receiver } from \"rhea-promise\";\nimport { logger } from \"./log\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\n\n/**\n * @hidden\n */\nexport interface LinkEntityOptions {\n  /**\n   * The unique name for the entity. If not provided then a guid will be\n   * assigned.\n   */\n  name?: string;\n  /**\n   * The partitionId associated with the link entity.\n   */\n  partitionId?: string;\n  /**\n   * The link entity address in one of the following forms:\n   */\n  address?: string;\n  /**\n   * The link entity token audience in one of the following forms:\n   */\n  audience?: string;\n}\n\n/**\n * Describes the base class for entities like EventHub Sender, Receiver and Management link.\n * @internal\n */\nexport class LinkEntity {\n  /**\n   * The unique name for the entity (mostly a guid).\n   */\n  name: string;\n  /**\n   * The link entity address in one of the following forms:\n   *\n   * **Sender**\n   * - `\"<hubName>\"`\n   * - `\"<hubName>/Partitions/<partitionId>\"`.\n   *\n   * **Receiver**\n   * - `\"<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`.\n   *\n   * **ManagementClient**\n   * -`\"$management\"`.\n   */\n  address: string;\n  /**\n   * The link entity token audience in one of the following forms:\n   *\n   * **Sender**\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>\"`.\n   *\n   * **Receiver**\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`.\n   *\n   * **ManagementClient**\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management\"`.\n   */\n  audience: string;\n  /**\n   * The partitionId associated with the link entity.\n   */\n  partitionId?: string;\n  /**\n   * Indicates whether the link is in the process of connecting\n   * (establishing) itself. Default value: `false`.\n   */\n  isConnecting: boolean = false;\n  /**\n   * Provides relevant information about the amqp connection,\n   * cbs and $management sessions, token provider, sender and receivers.\n   */\n  protected _context: ConnectionContext;\n  /**\n   * The token renewal timer that keeps track of when\n   * the Link Entity is due for token renewal.\n   */\n  protected _tokenRenewalTimer?: NodeJS.Timer;\n  /**\n   * Indicates token timeout in milliseconds\n   */\n  protected _tokenTimeoutInMs?: number;\n  /**\n   * Creates a new LinkEntity instance.\n   * @hidden\n   * @param context - The connection context.\n   * @param options - Options that can be provided while creating the LinkEntity.\n   */\n  constructor(context: ConnectionContext, options?: LinkEntityOptions) {\n    if (!options) options = {};\n    this._context = context;\n    this.address = options.address || \"\";\n    this.audience = options.audience || \"\";\n    this.name = `${options.name}-${uuid()}`;\n    this.partitionId = options.partitionId;\n  }\n\n  /**\n   * Negotiates cbs claim for the LinkEntity.\n   * @hidden\n   * @returns Promise<void>\n   */\n  protected async _negotiateClaim({\n    abortSignal,\n    setTokenRenewal,\n    timeoutInMs\n  }: {\n    setTokenRenewal: boolean | undefined;\n    abortSignal: AbortSignalLike | undefined;\n    timeoutInMs: number;\n  }): Promise<void> {\n    // Acquire the lock and establish a cbs session if it does not exist on the connection.\n    // Although node.js is single threaded, we need a locking mechanism to ensure that a\n    // race condition does not happen while creating a shared resource (in this case the\n    // cbs session, since we want to have exactly 1 cbs session per connection).\n    logger.verbose(\n      \"[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: \" +\n        \"'%s' with address: '%s'.\",\n      this._context.connectionId,\n      this._context.cbsSession.cbsLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    const startTime = Date.now();\n    if (!this._context.cbsSession.isOpen()) {\n      await defaultCancellableLock.acquire(\n        this._context.cbsSession.cbsLock,\n        () => {\n          return this._context.cbsSession.init({\n            abortSignal,\n            timeoutInMs: timeoutInMs - (Date.now() - startTime)\n          });\n        },\n        {\n          abortSignal,\n          timeoutInMs\n        }\n      );\n    }\n    let tokenObject: AccessToken;\n    let tokenType: TokenType;\n    if (isSasTokenProvider(this._context.tokenCredential)) {\n      tokenObject = this._context.tokenCredential.getToken(this.audience);\n      tokenType = TokenType.CbsTokenTypeSas;\n\n      // renew sas token in every 45 minutess\n      this._tokenTimeoutInMs = (3600 - 900) * 1000;\n    } else {\n      const aadToken = await this._context.tokenCredential.getToken(Constants.aadEventHubsScope);\n      if (!aadToken) {\n        throw new Error(`Failed to get token from the provided \"TokenCredential\" object`);\n      }\n      tokenObject = aadToken;\n      tokenType = TokenType.CbsTokenTypeJwt;\n      this._tokenTimeoutInMs = tokenObject.expiresOnTimestamp - Date.now() - 2 * 60 * 1000;\n    }\n\n    logger.verbose(\n      \"[%s] %s: calling negotiateClaim for audience '%s'.\",\n      this._context.connectionId,\n      this._type,\n      this.audience\n    );\n    // Acquire the lock to negotiate the CBS claim.\n    logger.verbose(\n      \"[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.\",\n      this._context.connectionId,\n      this._context.negotiateClaimLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    await defaultCancellableLock.acquire(\n      this._context.negotiateClaimLock,\n      () => {\n        return this._context.cbsSession.negotiateClaim(\n          this.audience,\n          tokenObject.token,\n          tokenType,\n          { abortSignal, timeoutInMs: timeoutInMs - (Date.now() - startTime) }\n        );\n      },\n      {\n        abortSignal,\n        timeoutInMs: timeoutInMs - (Date.now() - startTime)\n      }\n    );\n    logger.verbose(\n      \"[%s] Negotiated claim for %s '%s' with with address: %s\",\n      this._context.connectionId,\n      this._type,\n      this.name,\n      this.address\n    );\n    if (setTokenRenewal) {\n      await this._ensureTokenRenewal();\n    }\n  }\n\n  /**\n   * Ensures that the token is renewed within the predefined renewal margin.\n   * @hidden\n   */\n  protected _ensureTokenRenewal(): void {\n    if (!this._tokenTimeoutInMs) {\n      return;\n    }\n    // Clear the existing token renewal timer.\n    // This scenario can happen if the connection goes down and is brought back up\n    // before the `nextRenewalTimeout` was reached.\n    if (this._tokenRenewalTimer) {\n      clearTimeout(this._tokenRenewalTimer);\n    }\n    this._tokenRenewalTimer = setTimeout(async () => {\n      try {\n        await this._negotiateClaim({\n          setTokenRenewal: true,\n          abortSignal: undefined,\n          timeoutInMs: getRetryAttemptTimeoutInMs(undefined)\n        });\n      } catch (err) {\n        logger.verbose(\n          \"[%s] %s '%s' with address %s, an error occurred while renewing the token: %O\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address,\n          err\n        );\n      }\n    }, this._tokenTimeoutInMs);\n    logger.verbose(\n      \"[%s] %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).\",\n      this._context.connectionId,\n      this._type,\n      this.name,\n      this.address,\n      this._tokenTimeoutInMs,\n      new Date(Date.now() + this._tokenTimeoutInMs).toString()\n    );\n  }\n\n  /**\n   * Closes the Sender|Receiver link and it's underlying session and also removes it from the\n   * internal map.\n   * @hidden\n   * @param link - The Sender or Receiver link that needs to be closed and\n   * removed.\n   */\n  protected async _closeLink(link?: AwaitableSender | Receiver): Promise<void> {\n    clearTimeout(this._tokenRenewalTimer as NodeJS.Timer);\n    if (link) {\n      try {\n        // Closing the link and its underlying session if the link is open. This should also\n        // remove them from the internal map.\n        await link.close();\n        logger.verbose(\n          \"[%s] %s '%s' with address '%s' closed.\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address\n        );\n      } catch (err) {\n        logger.verbose(\n          \"[%s] An error occurred while closing the %s '%s' with address '%s': %O\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address,\n          err\n        );\n      }\n    }\n  }\n\n  /**\n   * Provides the current type of the LinkEntity.\n   * @returns The entity type.\n   */\n  private get _type(): string {\n    let result = \"LinkEntity\";\n    if ((this as any).constructor && (this as any).constructor.name) {\n      result = (this as any).constructor.name;\n    }\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logErrorStackTrace, logger } from \"../log\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { isDefined } from \"./typeGuards\";\n\n/**\n * @internal\n * Logs and throws Error if the current AMQP connection is closed.\n * @param context - The ConnectionContext associated with the current AMQP connection.\n */\nexport function throwErrorIfConnectionClosed(context: ConnectionContext): void {\n  if (context && context.wasConnectionCloseCalled) {\n    const errorMessage = \"The underlying AMQP connection is closed.\";\n    const error = new Error(errorMessage);\n    logger.warning(`[${context.connectionId}] ${error.name}: ${error.message}`);\n    logErrorStackTrace(error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is undefined or null\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param methodName - Name of the method that was passed the parameter\n * @param parameterName - Name of the parameter to check\n * @param parameterValue - Value of the parameter to check\n */\nexport function throwTypeErrorIfParameterMissing(\n  connectionId: string,\n  methodName: string,\n  parameterName: string,\n  parameterValue: unknown\n): void {\n  if (!isDefined(parameterValue)) {\n    const error = new TypeError(\n      `${methodName} called without required argument \"${parameterName}\"`\n    );\n    logger.warning(`[${connectionId}] ${error.name}: ${error.message}`);\n    logErrorStackTrace(error);\n    throw error;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  createSpanFunction,\n  SpanContext,\n  SpanOptions,\n  setSpan,\n  setSpanContext,\n  Span,\n  SpanKind,\n  context\n} from \"@azure/core-tracing\";\nimport { TryAddOptions } from \"../eventDataBatch\";\nimport { EventHubConnectionConfig } from \"../eventhubConnectionConfig\";\nimport { OperationOptions } from \"../util/operationOptions\";\n\nconst _createSpan = createSpanFunction({\n  namespace: \"Microsoft.EventHub\",\n  packagePrefix: \"Azure.EventHubs\"\n});\n\n/**\n * Creates an EventHubs specific span, with peer.address and message_bus.destination filled out.\n * @internal\n */\nexport function createEventHubSpan(\n  operationName: string,\n  operationOptions: OperationOptions | undefined,\n  connectionConfig: Pick<EventHubConnectionConfig, \"entityPath\" | \"host\">,\n  additionalSpanOptions?: SpanOptions\n): { span: Span; updatedOptions: OperationOptions } {\n  const { span, updatedOptions } = _createSpan(operationName, {\n    ...operationOptions,\n    tracingOptions: {\n      ...operationOptions?.tracingOptions,\n      spanOptions: {\n        ...operationOptions?.tracingOptions?.spanOptions,\n        ...additionalSpanOptions\n      }\n    }\n  });\n\n  span.setAttribute(\"message_bus.destination\", connectionConfig.entityPath);\n  span.setAttribute(\"peer.address\", connectionConfig.host);\n\n  return {\n    span,\n    updatedOptions\n  };\n}\n\n/**\n * @internal\n */\nexport function createMessageSpan(\n  operationOptions: OperationOptions,\n  eventHubConfig: Pick<EventHubConnectionConfig, \"entityPath\" | \"host\">\n): ReturnType<typeof createEventHubSpan> {\n  return createEventHubSpan(\"message\", operationOptions, eventHubConfig, {\n    kind: SpanKind.PRODUCER\n  });\n}\n\n/**\n * Converts TryAddOptions into the modern shape (OperationOptions) when needed.\n * (this is something we can eliminate at the next major release of EH _or_ when\n * we release with the GA version of opentelemetry).\n *\n * @internal\n */\nexport function convertTryAddOptionsForCompatibility(tryAddOptions: TryAddOptions): TryAddOptions {\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore: parentSpan is deprecated and this is compat code to translate it until we can get rid of it.\n  const legacyParentSpanOrSpanContext = tryAddOptions.parentSpan;\n\n  /*\n    Our goal here is to offer compatibility but there is a case where a user might accidentally pass\n    _both_ sets of options. We'll assume they want the OperationTracingOptions code path in that case.\n\n    Example of accidental span passing:\n\n    const someOptionsPassedIntoTheirFunction = {\n       parentSpan: span;      // set somewhere else in their code\n    }\n\n    function takeSomeOptionsFromSomewhere(someOptionsPassedIntoTheirFunction) {\n      \n      batch.tryAddMessage(message, { \n        // \"runtime\" blend of options from some other part of their app\n        ...someOptionsPassedIntoTheirFunction,      // parentSpan comes along for the ride...\n\n        tracingOptions: {\n          // thank goodness, I'm doing this right! (thinks the developer)\n          spanOptions: {\n            context: context\n          }\n        }\n      });\n    }\n\n    And now they've accidentally been opted into the legacy code path even though they think\n    they're using the modern code path.\n    \n    This does kick the can down the road a bit - at some point we will be putting them in this\n    situation where things looked okay but their spans are becoming unparented but we can \n    try to announce this (and other changes related to tracing) in our next big rev.\n  */\n\n  if (!legacyParentSpanOrSpanContext || tryAddOptions.tracingOptions) {\n    // assume that the options are already in the modern shape even if (possibly)\n    // they were still specifying `parentSpan`\n    return tryAddOptions;\n  }\n\n  const convertedOptions: TryAddOptions = {\n    ...tryAddOptions,\n    tracingOptions: {\n      tracingContext: isSpan(legacyParentSpanOrSpanContext)\n        ? setSpan(context.active(), legacyParentSpanOrSpanContext)\n        : setSpanContext(context.active(), legacyParentSpanOrSpanContext)\n    }\n  };\n\n  return convertedOptions;\n}\n\nfunction isSpan(possibleSpan: Span | SpanContext | undefined): possibleSpan is Span {\n  if (possibleSpan == null) {\n    return false;\n  }\n\n  const x = possibleSpan as Span;\n  return typeof x.spanContext === \"function\";\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport {\n  Constants,\n  RequestResponseLink,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  SendRequestOptions,\n  defaultCancellableLock,\n  isSasTokenProvider,\n  retry,\n  translate\n} from \"@azure/core-amqp\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport {\n  EventContext,\n  Message,\n  ReceiverEvents,\n  ReceiverOptions,\n  SenderEvents,\n  SenderOptions,\n  generate_uuid\n} from \"rhea-promise\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { throwErrorIfConnectionClosed, throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { OperationOptions } from \"./util/operationOptions\";\nimport { createEventHubSpan } from \"./diagnostics/tracing\";\n\n/**\n * Describes the runtime information of an Event Hub.\n */\nexport interface EventHubProperties {\n  /**\n   * The name of the event hub.\n   */\n  name: string;\n  /**\n   * The date and time the hub was created in UTC.\n   */\n  createdOn: Date;\n  /**\n   * The slice of string partition identifiers.\n   */\n  partitionIds: string[];\n}\n\n/**\n * Describes the runtime information of an EventHub Partition.\n */\nexport interface PartitionProperties {\n  /**\n   * The name of the Event Hub.\n   */\n  eventHubName: string;\n  /**\n   * Identifier of the partition within the Event Hub.\n   */\n  partitionId: string;\n  /**\n   * The starting sequence number of the partition's message log.\n   */\n  beginningSequenceNumber: number;\n  /**\n   * The last sequence number of the partition's message log.\n   */\n  lastEnqueuedSequenceNumber: number;\n  /**\n   * The offset of the last enqueued message in the partition's message log.\n   */\n  lastEnqueuedOffset: number;\n  /**\n   * The time of the last enqueued message in the partition's message log in UTC.\n   */\n  lastEnqueuedOnUtc: Date;\n  /**\n   * Indicates whether the partition is empty.\n   */\n  isEmpty: boolean;\n}\n\n/**\n * @internal\n */\nexport interface ManagementClientOptions {\n  address?: string;\n  audience?: string;\n}\n\n/**\n * @internal\n * Descibes the EventHubs Management Client that talks\n * to the $management endpoint over AMQP connection.\n */\nexport class ManagementClient extends LinkEntity {\n  readonly managementLock: string = `${Constants.managementRequestKey}-${uuid()}`;\n  /**\n   * The name/path of the entity (hub name) for which the management\n   * request needs to be made.\n   */\n  entityPath: string;\n  /**\n   * The reply to Guid for the management client.\n   */\n  replyTo: string = uuid();\n  /**\n   * $management sender, receiver on the same session.\n   */\n  private _mgmtReqResLink?: RequestResponseLink;\n\n  /**\n   * Instantiates the management client.\n   * @hidden\n   * @param context - The connection context.\n   * @param address - The address for the management endpoint. For IotHub it will be\n   * `/messages/events/$management`.\n   */\n  constructor(context: ConnectionContext, options?: ManagementClientOptions) {\n    super(context, {\n      address: options && options.address ? options.address : Constants.management,\n      audience:\n        options && options.audience ? options.audience : context.config.getManagementAudience()\n    });\n    this._context = context;\n    this.entityPath = context.config.entityPath as string;\n  }\n\n  /**\n   * Gets the security token for the management application properties.\n   * @internal\n   */\n  async getSecurityToken(): Promise<AccessToken | null> {\n    if (isSasTokenProvider(this._context.tokenCredential)) {\n      // the security_token has the $management address removed from the end of the audience\n      // expected audience: sb://fully.qualified.namespace/event-hub-name/$management\n      const audienceParts = this.audience.split(\"/\");\n      // for management links, address should be '$management'\n      if (audienceParts[audienceParts.length - 1] === this.address) {\n        audienceParts.pop();\n      }\n      const audience = audienceParts.join(\"/\");\n      return this._context.tokenCredential.getToken(audience);\n    }\n\n    // aad credentials use the aad scope\n    return this._context.tokenCredential.getToken(Constants.aadEventHubsScope);\n  }\n\n  /**\n   * Provides the eventhub runtime information.\n   * @hidden\n   */\n  async getEventHubProperties(\n    options: OperationOptions & { retryOptions?: RetryOptions } = {}\n  ): Promise<EventHubProperties> {\n    throwErrorIfConnectionClosed(this._context);\n    const { span: clientSpan } = createEventHubSpan(\n      \"getEventHubProperties\",\n      options,\n      this._context.config\n    );\n\n    try {\n      const securityToken = await this.getSecurityToken();\n      const request: Message = {\n        body: Buffer.from(JSON.stringify([])),\n        message_id: uuid(),\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.readOperation,\n          name: this.entityPath as string,\n          type: `${Constants.vendorString}:${Constants.eventHub}`,\n          security_token: securityToken?.token\n        }\n      };\n\n      const info: any = await this._makeManagementRequest(request, {\n        ...options,\n        requestName: \"getHubRuntimeInformation\"\n      });\n      const runtimeInfo: EventHubProperties = {\n        name: info.name,\n        createdOn: new Date(info.created_at),\n        partitionIds: info.partition_ids\n      };\n      logger.verbose(\"[%s] The hub runtime info is: %O\", this._context.connectionId, runtimeInfo);\n\n      clientSpan.setStatus({ code: SpanStatusCode.OK });\n      return runtimeInfo;\n    } catch (error) {\n      clientSpan.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: error.message\n      });\n      logger.warning(\n        `An error occurred while getting the hub runtime information: ${error?.name}: ${error?.message}`\n      );\n      logErrorStackTrace(error);\n      throw error;\n    } finally {\n      clientSpan.end();\n    }\n  }\n\n  /**\n   * Provides information about the specified partition.\n   * @hidden\n   * @param partitionId - Partition ID for which partition information is required.\n   */\n  async getPartitionProperties(\n    partitionId: string,\n    options: OperationOptions & { retryOptions?: RetryOptions } = {}\n  ): Promise<PartitionProperties> {\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"getPartitionProperties\",\n      \"partitionId\",\n      partitionId\n    );\n    partitionId = String(partitionId);\n\n    const { span: clientSpan } = createEventHubSpan(\n      \"getPartitionProperties\",\n      options,\n      this._context.config\n    );\n\n    try {\n      const securityToken = await this.getSecurityToken();\n      const request: Message = {\n        body: Buffer.from(JSON.stringify([])),\n        message_id: uuid(),\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.readOperation,\n          name: this.entityPath as string,\n          type: `${Constants.vendorString}:${Constants.partition}`,\n          partition: `${partitionId}`,\n          security_token: securityToken?.token\n        }\n      };\n\n      const info: any = await this._makeManagementRequest(request, {\n        ...options,\n        requestName: \"getPartitionInformation\"\n      });\n\n      const partitionInfo: PartitionProperties = {\n        beginningSequenceNumber: info.begin_sequence_number,\n        eventHubName: info.name,\n        lastEnqueuedOffset: info.last_enqueued_offset,\n        lastEnqueuedOnUtc: new Date(info.last_enqueued_time_utc),\n        lastEnqueuedSequenceNumber: info.last_enqueued_sequence_number,\n        partitionId: info.partition,\n        isEmpty: info.is_partition_empty\n      };\n      logger.verbose(\"[%s] The partition info is: %O.\", this._context.connectionId, partitionInfo);\n\n      clientSpan.setStatus({ code: SpanStatusCode.OK });\n\n      return partitionInfo;\n    } catch (error) {\n      clientSpan.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: error.message\n      });\n      logger.warning(\n        `An error occurred while getting the partition information: ${error?.name}: ${error?.message}`\n      );\n      logErrorStackTrace(error);\n      throw error;\n    } finally {\n      clientSpan.end();\n    }\n  }\n\n  /**\n   * Closes the AMQP management session to the Event Hub for this client,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @hidden\n   */\n  async close(): Promise<void> {\n    try {\n      // Always clear the timeout, as the isOpen check may report\n      // false without ever having cleared the timeout otherwise.\n      clearTimeout(this._tokenRenewalTimer as NodeJS.Timer);\n      if (this._isMgmtRequestResponseLinkOpen()) {\n        const mgmtLink = this._mgmtReqResLink;\n        this._mgmtReqResLink = undefined;\n        await mgmtLink!.close();\n        logger.info(\"Successfully closed the management session.\");\n      }\n    } catch (err) {\n      const msg = `An error occurred while closing the management session: ${err?.name}: ${err?.message}`;\n      logger.warning(msg);\n      logErrorStackTrace(err);\n      throw new Error(msg);\n    }\n  }\n\n  private async _init({\n    abortSignal,\n    timeoutInMs\n  }: {\n    abortSignal: AbortSignalLike | undefined;\n    timeoutInMs: number;\n  }): Promise<void> {\n    try {\n      if (!this._isMgmtRequestResponseLinkOpen()) {\n        // Wait for the connectionContext to be ready to open the link.\n        await this._context.readyToOpenLink();\n        await this._negotiateClaim({ setTokenRenewal: false, abortSignal, timeoutInMs });\n        const rxopt: ReceiverOptions = {\n          source: { address: this.address },\n          name: this.replyTo,\n          target: { address: this.replyTo },\n          onSessionError: (context: EventContext) => {\n            const id = context.connection.options.id;\n            const ehError = translate(context.session!.error!);\n            logger.verbose(\n              \"[%s] An error occurred on the session for request/response links for \" +\n                \"$management: %O\",\n              id,\n              ehError\n            );\n          }\n        };\n        const sropt: SenderOptions = {\n          target: { address: this.address }\n        };\n        logger.verbose(\n          \"[%s] Creating sender/receiver links on a session for $management endpoint with \" +\n            \"srOpts: %o, receiverOpts: %O.\",\n          this._context.connectionId,\n          sropt,\n          rxopt\n        );\n        this._mgmtReqResLink = await RequestResponseLink.create(\n          this._context.connection,\n          sropt,\n          rxopt,\n          { abortSignal }\n        );\n        this._mgmtReqResLink.sender.on(SenderEvents.senderError, (context: EventContext) => {\n          const id = context.connection.options.id;\n          const ehError = translate(context.sender!.error!);\n          logger.verbose(\"[%s] An error occurred on the $management sender link.. %O\", id, ehError);\n        });\n        this._mgmtReqResLink.receiver.on(ReceiverEvents.receiverError, (context: EventContext) => {\n          const id = context.connection.options.id;\n          const ehError = translate(context.receiver!.error!);\n          logger.verbose(\n            \"[%s] An error occurred on the $management receiver link.. %O\",\n            id,\n            ehError\n          );\n        });\n        logger.verbose(\n          \"[%s] Created sender '%s' and receiver '%s' links for $management endpoint.\",\n          this._context.connectionId,\n          this._mgmtReqResLink.sender.name,\n          this._mgmtReqResLink.receiver.name\n        );\n        await this._ensureTokenRenewal();\n      }\n    } catch (err) {\n      const translatedError = translate(err);\n      logger.warning(\n        `[${this._context.connectionId}] An error occured while establishing the $management links: ${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  /**\n   * Helper method to make the management request\n   * @param request - The AMQP message to send\n   * @param options - The options to use when sending a request over a $management link\n   */\n  private async _makeManagementRequest(\n    request: Message,\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n      requestName?: string;\n    } = {}\n  ): Promise<any> {\n    const retryOptions = options.retryOptions || {};\n    try {\n      const abortSignal: AbortSignalLike | undefined = options && options.abortSignal;\n\n      const sendOperationPromise = async (): Promise<Message> => {\n        let count = 0;\n\n        const retryTimeoutInMs = getRetryAttemptTimeoutInMs(options.retryOptions);\n        let timeTakenByInit = 0;\n\n        if (!this._isMgmtRequestResponseLinkOpen()) {\n          logger.verbose(\n            \"[%s] Acquiring lock to get the management req res link.\",\n            this._context.connectionId\n          );\n\n          const initOperationStartTime = Date.now();\n          try {\n            await defaultCancellableLock.acquire(\n              this.managementLock,\n              () => {\n                const acquireLockEndTime = Date.now();\n                const timeoutInMs =\n                  retryTimeoutInMs - (acquireLockEndTime - initOperationStartTime);\n                return this._init({ abortSignal, timeoutInMs });\n              },\n              { abortSignal, timeoutInMs: retryTimeoutInMs }\n            );\n          } catch (err) {\n            const translatedError = translate(err);\n            logger.warning(\n              \"[%s] An error occurred while creating the management link %s: %s\",\n              this._context.connectionId,\n              this.name,\n              `${translatedError?.name}: ${translatedError?.message}`\n            );\n            logErrorStackTrace(translatedError);\n            throw translatedError;\n          }\n          timeTakenByInit = Date.now() - initOperationStartTime;\n        }\n\n        const remainingOperationTimeoutInMs = retryTimeoutInMs - timeTakenByInit;\n\n        const sendRequestOptions: SendRequestOptions = {\n          abortSignal: options.abortSignal,\n          requestName: options.requestName,\n          timeoutInMs: remainingOperationTimeoutInMs\n        };\n\n        count++;\n        if (count !== 1) {\n          // Generate a new message_id every time after the first attempt\n          request.message_id = generate_uuid();\n        } else if (!request.message_id) {\n          // Set the message_id in the first attempt only if it is not set\n          request.message_id = generate_uuid();\n        }\n\n        return this._mgmtReqResLink!.sendRequest(request, sendRequestOptions);\n      };\n\n      const config: RetryConfig<Message> = Object.defineProperties(\n        {\n          operation: sendOperationPromise,\n          operationType: RetryOperationType.management,\n          abortSignal: abortSignal,\n          retryOptions: retryOptions\n        },\n        {\n          connectionId: {\n            enumerable: true,\n            get: () => {\n              return this._context.connectionId;\n            }\n          }\n        }\n      );\n      return (await retry<Message>(config)).body;\n    } catch (err) {\n      const translatedError = translate(err);\n      logger.warning(\n        \"[%s] An error occurred during send on management request-response link with address '%s': %s\",\n        this._context.connectionId,\n        this.address,\n        `${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  private _isMgmtRequestResponseLinkOpen(): boolean {\n    return this._mgmtReqResLink! && this._mgmtReqResLink!.isOpen();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Parses the host, hostname, and port from an endpoint.\n * @param endpoint - And endpoint to parse.\n * @internal\n */\nexport function parseEndpoint(endpoint: string): { host: string; hostname: string; port?: string } {\n  const hostMatch = endpoint.match(/.*:\\/\\/([^/]*)/);\n  if (!hostMatch) {\n    throw new TypeError(`Invalid endpoint missing host: ${endpoint}`);\n  }\n\n  const [, host] = hostMatch;\n  const [hostname, port] = host.split(\":\");\n\n  return { host, hostname, port };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint-disable eqeqeq */\n\nimport { ConnectionConfig } from \"@azure/core-amqp\";\nimport { parseEndpoint } from \"./util/parseEndpoint\";\n\n/**\n * Describes the connection config object that is created after parsing an EventHub connection\n * string. It also provides some convenience methods for getting the address and audience for\n * different entities.\n * @internal\n */\nexport interface EventHubConnectionConfig extends ConnectionConfig {\n  /**\n   * The name/path of the entity (event hub name) to which the\n   * connection needs to happen.\n   */\n  entityPath: string;\n  /**\n   * Provides the EventHub Sender address in one of the following forms based on the input:\n   * - `\"<hubName>\"`\n   * - `\"<hubName>/Partitions/<partitionId>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub to which messages will be sent.\n   */\n  getSenderAddress(partitionId?: string | number): string;\n  /**\n   * Provides the EventHub Sender audience in one of the following forms based on the input:\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub to which messages will be sent.\n   */\n  getSenderAudience(partitionId?: string | number): string;\n  /**\n   * Provides the EventHub Receiver address:\n   * - `\"<hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub from which messages will be received.\n   * @param consumergroup - The consumergoup in the EventHub from which the messages will\n   * be received. Default: `$default`.\n   */\n  getReceiverAddress(partitionId: string | number, consumergroup?: string): string;\n  /**\n   * Provides the EventHub Receiver audience.\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub from which messages will be received.\n   * @param consumergroup - The consumergoup in the EventHub from which the messages will\n   * be received. Default: `$default`.\n   */\n  getReceiverAudience(partitionId: string | number, consumergroup?: string): string;\n  /**\n   * Provides the EventHub Management address.\n   * - `\"<hub-name>/$management\"`\n   */\n  getManagementAddress(): string;\n  /**\n   * Provides the EventHub Management audience.\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<hub-name>/$management\"`\n   */\n  getManagementAudience(): string;\n}\n\n/**\n * Describes the connection config object that is created after parsing an EventHub connection\n * string. It also provides some convenience methods for getting the address and audience for\n * different entities.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- renaming constant would be a breaking change.\nexport const EventHubConnectionConfig = {\n  /**\n   * Creates the connection config.\n   * @param connectionString - The connection string for a given service like\n   * EventHub/ServiceBus.\n   * @param path - The name/path of the entity (hub name) to which the\n   * connection needs to happen. This will override the EntityPath in the connectionString\n   * if present.\n   * @returns EventHubConnectionConfig\n   */\n  create(connectionString: string, path?: string): EventHubConnectionConfig {\n    const config = ConnectionConfig.create(connectionString, path);\n    if (!config.entityPath) {\n      throw new TypeError(\n        `Either provide \"path\" or the \"connectionString\": \"${connectionString}\", ` +\n          `must contain EntityPath=\"<path-to-the-entity>\".`\n      );\n    }\n    return EventHubConnectionConfig.createFromConnectionConfig(config);\n  },\n\n  /**\n   * Creates an EventHubConnectionConfig from the provided base ConnectionConfig.\n   * @param config - The base connection config from which the EventHubConnectionConfig needs to be\n   * created.\n   * @returns EventHubConnectionConfig\n   */\n  createFromConnectionConfig(config: ConnectionConfig): EventHubConnectionConfig {\n    ConnectionConfig.validate(config, { isEntityPathRequired: true });\n\n    (config as EventHubConnectionConfig).getManagementAudience = () => {\n      return `${config.endpoint}${config.entityPath}/$management`;\n    };\n    (config as EventHubConnectionConfig).getManagementAddress = () => {\n      return `${config.entityPath}/$management`;\n    };\n\n    (config as EventHubConnectionConfig).getSenderAudience = (partitionId?: string | number) => {\n      if (partitionId != undefined) {\n        return `${config.endpoint}${config.entityPath}/Partitions/${partitionId}`;\n      } else {\n        return `${config.endpoint}${config.entityPath}`;\n      }\n    };\n\n    (config as EventHubConnectionConfig).getSenderAddress = (partitionId?: string | number) => {\n      if (partitionId != undefined) {\n        return `${config.entityPath}/Partitions/${partitionId}`;\n      } else {\n        return `${config.entityPath}`;\n      }\n    };\n\n    (config as EventHubConnectionConfig).getReceiverAudience = (\n      partitionId: string | number,\n      consumergroup?: string\n    ) => {\n      if (!consumergroup) consumergroup = \"$default\";\n      return (\n        `${config.endpoint}${config.entityPath}/ConsumerGroups/${consumergroup}/` +\n        `Partitions/${partitionId}`\n      );\n    };\n\n    (config as EventHubConnectionConfig).getReceiverAddress = (\n      partitionId: string | number,\n      consumergroup?: string\n    ) => {\n      if (!consumergroup) consumergroup = \"$default\";\n      return `${config.entityPath}/ConsumerGroups/${consumergroup}/Partitions/${partitionId}`;\n    };\n    return config as EventHubConnectionConfig;\n  },\n\n  /**\n   * Updates the provided EventHubConnectionConfig to use the custom endpoint address.\n   * @param config - An existing connection configuration to be updated.\n   * @param customEndpointAddress - The custom endpoint address to use.\n   */\n  setCustomEndpointAddress(config: EventHubConnectionConfig, customEndpointAddress: string): void {\n    // The amqpHostname should match the host prior to using the custom endpoint.\n    config.amqpHostname = config.host;\n    const { hostname, port } = parseEndpoint(customEndpointAddress);\n    // Since we specify the port separately, set host to the customEndpointAddress hostname.\n    config.host = hostname;\n    if (port) {\n      config.port = parseInt(port, 10);\n    }\n  },\n\n  /**\n   * Validates the properties of connection config.\n   * @param config - The connection config to be validated.\n   * @returns void\n   */\n  validate(config: EventHubConnectionConfig): void {\n    return ConnectionConfig.validate(config, { isEntityPathRequired: true });\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/* eslint-disable @azure/azure-sdk/ts-no-namespaces */\n/* eslint-disable no-inner-declarations */\n\nimport { logger, logErrorStackTrace } from \"./log\";\nimport { getRuntimeInfo } from \"./util/runtimeInfo\";\nimport { packageJsonInfo } from \"./util/constants\";\nimport {\n  EventHubConnectionStringProperties,\n  parseEventHubConnectionString\n} from \"./util/connectionStringUtils\";\nimport { EventHubReceiver } from \"./eventHubReceiver\";\nimport { EventHubSender } from \"./eventHubSender\";\nimport {\n  ConnectionContextBase,\n  Constants,\n  CreateConnectionContextBaseParameters,\n  ConnectionConfig,\n  SasTokenProvider,\n  createSasTokenProvider\n} from \"@azure/core-amqp\";\nimport {\n  TokenCredential,\n  NamedKeyCredential,\n  SASCredential,\n  isNamedKeyCredential,\n  isSASCredential\n} from \"@azure/core-auth\";\nimport { ManagementClient, ManagementClientOptions } from \"./managementClient\";\nimport { EventHubClientOptions } from \"./models/public\";\nimport { Connection, ConnectionEvents, Dictionary, EventContext, OnAmqpEvent } from \"rhea-promise\";\nimport { EventHubConnectionConfig } from \"./eventhubConnectionConfig\";\nimport { isCredential } from \"./util/typeGuards\";\n\n/**\n * @internal\n * Provides contextual information like the underlying amqp connection, cbs session, management session,\n * tokenProvider, senders, receivers, etc. about the EventHub client.\n */\nexport interface ConnectionContext extends ConnectionContextBase {\n  /**\n   * The EventHub connection config that is created after\n   * parsing the connection string.\n   */\n  readonly config: EventHubConnectionConfig;\n  /**\n   * The credential to be used for Authentication.\n   * Default value: SasTokenProvider.\n   */\n  tokenCredential: SasTokenProvider | TokenCredential;\n  /**\n   * Indicates whether the close() method was\n   * called on theconnection object.\n   */\n  wasConnectionCloseCalled: boolean;\n  /**\n   * A dictionary of the EventHub Receivers associated with this client.\n   */\n  receivers: Dictionary<EventHubReceiver>;\n  /**\n   * A dictionary of the EventHub Senders associated with this client.\n   */\n  senders: Dictionary<EventHubSender>;\n  /**\n   * A reference to the management session ($management endpoint) on\n   * the underlying amqp connection for the EventHub Client.\n   */\n  managementSession?: ManagementClient;\n  /**\n   * Function returning a promise that resolves once the connectionContext is ready to open an AMQP link.\n   * ConnectionContext will be ready to open an AMQP link when:\n   * - The AMQP connection is already open on both sides.\n   * - The AMQP connection has been closed or disconnected. In this case, a new AMQP connection is expected\n   * to be created first.\n   * An AMQP link cannot be opened if the AMQP connection\n   * is in the process of closing or disconnecting.\n   */\n  readyToOpenLink(): Promise<void>;\n  /**\n   * Closes all AMQP links, sessions and connection.\n   */\n  close(): Promise<void>;\n}\n\n/**\n * Describes the members on the ConnectionContext that are only\n * used by it internally.\n * @internal\n */\nexport interface ConnectionContextInternalMembers extends ConnectionContext {\n  /**\n   * Indicates whether the connection is in the process of closing.\n   * When this returns `true`, a `disconnected` event will be received\n   * after the connection is closed.\n   *\n   */\n  isConnectionClosing(): boolean;\n  /**\n   * Resolves once the context's connection emits a `disconnected` event.\n   */\n  waitForDisconnectedEvent(): Promise<void>;\n  /**\n   * Resolves once the connection has finished being reset.\n   * Connections are reset as part of reacting to a `disconnected` event.\n   */\n  waitForConnectionReset(): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport interface ConnectionContextOptions extends EventHubClientOptions {\n  managementSessionAddress?: string;\n  managementSessionAudience?: string;\n}\n\n/**\n * Helper type to get the names of all the functions on an object.\n */\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T]; // eslint-disable-line @typescript-eslint/ban-types\n/**\n * Helper type to get the types of all the functions on an object.\n */\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n/**\n * Helper type to get the types of all the functions on ConnectionContext\n * and the internal methods from ConnectionContextInternalMembers.\n * Note that this excludes the functions that ConnectionContext inherits.\n * Each function also has its `this` type set as `ConnectionContext`.\n */\ntype ConnectionContextMethods = Omit<\n  FunctionProperties<ConnectionContextInternalMembers>,\n  FunctionPropertyNames<ConnectionContextBase>\n> &\n  ThisType<ConnectionContextInternalMembers>;\n\n/**\n * @internal\n */\nexport namespace ConnectionContext {\n  /**\n   * The user agent string for the EventHubs client.\n   * See guideline at https://github.com/Azure/azure-sdk/blob/main/docs/design/Telemetry.mdk\n   */\n  const userAgent: string = `azsdk-js-azureeventhubs/${\n    packageJsonInfo.version\n  } (${getRuntimeInfo()})`;\n\n  export function getUserAgent(options: ConnectionContextOptions): string {\n    const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;\n    if (finalUserAgent.length > Constants.maxUserAgentLength) {\n      throw new Error(\n        `The user-agent string cannot be more than ${Constants.maxUserAgentLength} characters in length.` +\n          `The given user-agent string is: ${finalUserAgent} with length: ${finalUserAgent.length}`\n      );\n    }\n    return finalUserAgent;\n  }\n\n  export function create(\n    config: EventHubConnectionConfig,\n    tokenCredential: SasTokenProvider | TokenCredential,\n    options?: ConnectionContextOptions\n  ): ConnectionContext {\n    if (!options) options = {};\n\n    config.webSocket = options.webSocketOptions && options.webSocketOptions.webSocket;\n    config.webSocketEndpointPath = \"$servicebus/websocket\";\n    config.webSocketConstructorOptions =\n      options.webSocketOptions && options.webSocketOptions.webSocketConstructorOptions;\n\n    const parameters: CreateConnectionContextBaseParameters = {\n      config: config,\n      // re-enabling this will be a post-GA discussion.\n      // dataTransformer: options.dataTransformer,\n      isEntityPathRequired: true,\n      connectionProperties: {\n        product: \"MSJSClient\",\n        userAgent: getUserAgent(options),\n        version: packageJsonInfo.version\n      }\n    };\n    // Let us create the base context and then add EventHub specific ConnectionContext properties.\n    const connectionContext = ConnectionContextBase.create(parameters) as ConnectionContext;\n    connectionContext.tokenCredential = tokenCredential;\n    connectionContext.wasConnectionCloseCalled = false;\n    connectionContext.senders = {};\n    connectionContext.receivers = {};\n    const mOptions: ManagementClientOptions = {\n      address: options.managementSessionAddress,\n      audience: options.managementSessionAudience\n    };\n    connectionContext.managementSession = new ManagementClient(connectionContext, mOptions);\n\n    let waitForConnectionRefreshResolve: () => void;\n    let waitForConnectionRefreshPromise: Promise<void> | undefined;\n\n    Object.assign<ConnectionContext, ConnectionContextMethods>(connectionContext, {\n      isConnectionClosing() {\n        // When the connection is not open, but the remote end is open,\n        // then the rhea connection is in the process of terminating.\n        return Boolean(!this.connection.isOpen() && this.connection.isRemoteOpen());\n      },\n      async readyToOpenLink() {\n        // Check that the connection isn't in the process of closing.\n        // This can happen when the idle timeout has been reached but\n        // the underlying socket is waiting to be destroyed.\n        if (this.isConnectionClosing()) {\n          // Wait for the disconnected event that indicates the underlying socket has closed.\n          await this.waitForDisconnectedEvent();\n        }\n\n        // Wait for the connection to be reset.\n        await this.waitForConnectionReset();\n      },\n      waitForDisconnectedEvent() {\n        return new Promise((resolve) => {\n          logger.verbose(\n            `[${this.connectionId}] Attempting to reinitialize connection` +\n              ` but the connection is in the process of closing.` +\n              ` Waiting for the disconnect event before continuing.`\n          );\n          this.connection.once(ConnectionEvents.disconnected, resolve);\n        });\n      },\n      waitForConnectionReset() {\n        // Check if the connection is currently in the process of disconnecting.\n        if (waitForConnectionRefreshPromise) {\n          return waitForConnectionRefreshPromise;\n        }\n        return Promise.resolve();\n      },\n      async close() {\n        try {\n          if (this.connection.isOpen()) {\n            // Close all the senders.\n            await Promise.all(\n              Object.keys(connectionContext.senders).map((name) =>\n                connectionContext.senders[name]?.close().catch(() => {\n                  /* error already logged, swallow it here */\n                })\n              )\n            );\n            // Close all the receivers.\n            await Promise.all(\n              Object.keys(connectionContext.receivers).map((name) =>\n                connectionContext.receivers[name]?.close().catch(() => {\n                  /* error already logged, swallow it here */\n                })\n              )\n            );\n            // Close the cbs session;\n            await this.cbsSession.close();\n            // Close the management session\n            await this.managementSession?.close();\n            await this.connection.close();\n            this.wasConnectionCloseCalled = true;\n            logger.info(\"Closed the amqp connection '%s' on the client.\", this.connectionId);\n          }\n        } catch (err) {\n          const errorDescription =\n            err instanceof Error ? `${err.name}: ${err.message}` : JSON.stringify(err);\n          logger.warning(\n            `An error occurred while closing the connection \"${this.connectionId}\":\\n${errorDescription}`\n          );\n          logErrorStackTrace(err);\n          throw err;\n        }\n      }\n    });\n\n    // Define listeners to be added to the connection object for\n    // \"connection_open\" and \"connection_error\" events.\n    const onConnectionOpen: OnAmqpEvent = () => {\n      connectionContext.wasConnectionCloseCalled = false;\n      logger.verbose(\n        \"[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.\",\n        connectionContext.connection.id,\n        connectionContext.wasConnectionCloseCalled\n      );\n    };\n\n    const onDisconnected: OnAmqpEvent = async (context: EventContext) => {\n      if (waitForConnectionRefreshPromise) {\n        return;\n      }\n      waitForConnectionRefreshPromise = new Promise((resolve) => {\n        waitForConnectionRefreshResolve = resolve;\n      });\n      try {\n        logger.verbose(\n          \"[%s] 'disconnected' event occurred on the amqp connection.\",\n          connectionContext.connection.id\n        );\n\n        if (context.connection && context.connection.error) {\n          logger.verbose(\n            \"[%s] Accompanying error on the context.connection: %O\",\n            connectionContext.connection.id,\n            context.connection && context.connection.error\n          );\n        }\n        if (context.error) {\n          logger.verbose(\n            \"[%s] Accompanying error on the context: %O\",\n            connectionContext.connection.id,\n            context.error\n          );\n        }\n        const state: Readonly<{\n          wasConnectionCloseCalled: boolean;\n          numSenders: number;\n          numReceivers: number;\n        }> = {\n          wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,\n          numSenders: Object.keys(connectionContext.senders).length,\n          numReceivers: Object.keys(connectionContext.receivers).length\n        };\n        logger.verbose(\n          \"[%s] Closing all open senders and receivers in the state: %O\",\n          connectionContext.connection.id,\n          state\n        );\n\n        // Clear internal map maintained by rhea to avoid reconnecting of old links once the\n        // connection is back up.\n        connectionContext.connection.removeAllSessions();\n\n        // Close the cbs session to ensure all the event handlers are released.\n        await connectionContext.cbsSession?.close().catch(() => {\n          /* error already logged, swallow it here */\n        });\n        // Close the management session to ensure all the event handlers are released.\n        await connectionContext.managementSession?.close().catch(() => {\n          /* error already logged, swallow it here */\n        });\n\n        // Close all senders and receivers to ensure clean up of timers & other resources.\n        if (state.numSenders || state.numReceivers) {\n          await Promise.all(\n            Object.keys(connectionContext.senders).map((name) =>\n              connectionContext.senders[name]?.close().catch(() => {\n                /* error already logged, swallow it here */\n              })\n            )\n          );\n\n          await Promise.all(\n            Object.keys(connectionContext.receivers).map((name) =>\n              connectionContext.receivers[name]?.close().catch(() => {\n                /* error already logged, swallow it here */\n              })\n            )\n          );\n        }\n      } catch (err) {\n        logger.verbose(\n          `[${connectionContext.connectionId}] An error occurred while closing the connection in 'disconnected'. %O`,\n          err\n        );\n      }\n\n      try {\n        await refreshConnection(connectionContext);\n      } catch (err) {\n        logger.verbose(\n          `[${connectionContext.connectionId}] An error occurred while refreshing the connection in 'disconnected'. %O`,\n          err\n        );\n      } finally {\n        waitForConnectionRefreshResolve();\n        waitForConnectionRefreshPromise = undefined;\n      }\n    };\n\n    const protocolError: OnAmqpEvent = async (context: EventContext) => {\n      logger.verbose(\n        \"[%s] 'protocol_error' event occurred on the amqp connection.\",\n        connectionContext.connection.id\n      );\n\n      if (context.connection && context.connection.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context.connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    const error: OnAmqpEvent = async (context: EventContext) => {\n      logger.verbose(\n        \"[%s] 'error' event occurred on the amqp connection.\",\n        connectionContext.connection.id\n      );\n\n      if (context.connection && context.connection.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context.connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    function addConnectionListeners(connection: Connection): void {\n      // Add listeners on the connection object.\n      connection.on(ConnectionEvents.connectionOpen, onConnectionOpen);\n      connection.on(ConnectionEvents.disconnected, onDisconnected);\n      connection.on(ConnectionEvents.protocolError, protocolError);\n      connection.on(ConnectionEvents.error, error);\n    }\n\n    function cleanConnectionContext(context: ConnectionContext): Promise<void> {\n      // Remove listeners from the connection object.\n      context.connection.removeListener(ConnectionEvents.connectionOpen, onConnectionOpen);\n      context.connection.removeListener(ConnectionEvents.disconnected, onDisconnected);\n      context.connection.removeListener(ConnectionEvents.protocolError, protocolError);\n      context.connection.removeListener(ConnectionEvents.error, error);\n      // Close the connection\n      return context.connection.close();\n    }\n\n    async function refreshConnection(context: ConnectionContext): Promise<void> {\n      const originalConnectionId = context.connectionId;\n      try {\n        await cleanConnectionContext(context);\n      } catch (err) {\n        logger.verbose(\n          `[${context.connectionId}] There was an error closing the connection before reconnecting: %O`,\n          err\n        );\n      }\n\n      // Create a new connection, id, locks, and cbs client.\n      context.refreshConnection();\n      addConnectionListeners(context.connection);\n      logger.verbose(\n        `The connection \"${originalConnectionId}\" has been updated to \"${context.connectionId}\".`\n      );\n    }\n\n    addConnectionListeners(connectionContext.connection);\n\n    logger.verbose(\"[%s] Created connection context successfully.\", connectionContext.connectionId);\n    return connectionContext;\n  }\n}\n\n/**\n * Helper method to create a ConnectionContext from the input passed to either\n * EventHubProducerClient or EventHubConsumerClient constructors\n *\n * @internal\n */\nexport function createConnectionContext(\n  hostOrConnectionString: string,\n  eventHubNameOrOptions?: string | EventHubClientOptions,\n  credentialOrOptions?:\n    | TokenCredential\n    | NamedKeyCredential\n    | SASCredential\n    | EventHubClientOptions,\n  options?: EventHubClientOptions\n): ConnectionContext {\n  let connectionString;\n  let config;\n  let credential: TokenCredential | SasTokenProvider;\n  hostOrConnectionString = String(hostOrConnectionString);\n\n  if (!isCredential(credentialOrOptions)) {\n    const parsedCS = parseEventHubConnectionString(hostOrConnectionString);\n    if (\n      !(\n        parsedCS.eventHubName ||\n        (typeof eventHubNameOrOptions === \"string\" && eventHubNameOrOptions)\n      )\n    ) {\n      throw new TypeError(\n        `Either provide \"eventHubName\" or the \"connectionString\": \"${hostOrConnectionString}\", ` +\n          `must contain \"EntityPath=<your-event-hub-name>\".`\n      );\n    }\n    if (\n      parsedCS.eventHubName &&\n      typeof eventHubNameOrOptions === \"string\" &&\n      eventHubNameOrOptions &&\n      parsedCS.eventHubName !== eventHubNameOrOptions\n    ) {\n      throw new TypeError(\n        `The entity path \"${parsedCS.eventHubName}\" in connectionString: \"${hostOrConnectionString}\" ` +\n          `doesn't match with eventHubName: \"${eventHubNameOrOptions}\".`\n      );\n    }\n    connectionString = hostOrConnectionString;\n    if (typeof eventHubNameOrOptions !== \"string\") {\n      // connectionstring and/or options were passed to constructor\n      config = EventHubConnectionConfig.create(connectionString);\n      options = eventHubNameOrOptions;\n    } else {\n      // connectionstring, eventHubName and/or options were passed to constructor\n      const eventHubName = eventHubNameOrOptions;\n      config = EventHubConnectionConfig.create(connectionString, eventHubName);\n      options = credentialOrOptions;\n    }\n\n    const parsed = parseEventHubConnectionString(connectionString) as Required<\n      | Pick<EventHubConnectionStringProperties, \"sharedAccessKey\" | \"sharedAccessKeyName\">\n      | Pick<EventHubConnectionStringProperties, \"sharedAccessSignature\">\n    >;\n    // Since connectionString was passed, create a TokenProvider.\n    credential = createSasTokenProvider(parsed);\n  } else {\n    // host, eventHubName, a TokenCredential and/or options were passed to constructor\n    const eventHubName = eventHubNameOrOptions;\n    let host = hostOrConnectionString;\n    if (isNamedKeyCredential(credentialOrOptions) || isSASCredential(credentialOrOptions)) {\n      credential = createSasTokenProvider(credentialOrOptions);\n    } else {\n      credential = credentialOrOptions;\n    }\n    if (!eventHubName) {\n      throw new TypeError(`\"eventHubName\" is missing`);\n    }\n\n    if (!host.endsWith(\"/\")) host += \"/\";\n    connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;EntityPath=${eventHubName}`;\n    config = EventHubConnectionConfig.create(connectionString);\n  }\n\n  if (options?.customEndpointAddress) {\n    EventHubConnectionConfig.setCustomEndpointAddress(config, options.customEndpointAddress);\n  }\n\n  ConnectionConfig.validate(config);\n\n  return ConnectionContext.create(config, credential, options);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CheckpointStore, PartitionOwnership } from \"./eventProcessor\";\nimport { Checkpoint } from \"./partitionProcessor\";\nimport { generate_uuid } from \"rhea-promise\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\n\n/**\n * The `EventProcessor` relies on a `CheckpointStore` to store checkpoints and handle partition\n * ownerships. `InMemoryCheckpointStore` is simple partition manager that stores checkpoints and\n * partition ownerships in memory of your program.\n *\n * You can use the `InMemoryCheckpointStore` to get started with using the `EventProcessor`.\n * But in production, you should choose an implementation of the `CheckpointStore` interface that will\n * store the checkpoints and partition ownerships to a durable store instead.\n *\n * @internal\n */\nexport class InMemoryCheckpointStore implements CheckpointStore {\n  private _partitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n  private _committedCheckpoints: Map<string, Map<string, Checkpoint>> = new Map();\n\n  /**\n   * Get the list of all existing partition ownership from the underlying data store. Could return empty\n   * results if there are is no existing ownership information.\n   *\n   * @param fullyQualifiedNamespace - The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName - The event hub name.\n   * @param consumerGroup - The consumer group name.\n   * @returns Partition ownership details of all the partitions that have/had an owner..\n   */\n  async listOwnership(\n    _fullyQualifiedNamespace: string,\n    _eventHubName: string,\n    _consumerGroup: string\n  ): Promise<PartitionOwnership[]> {\n    const ownerships = [];\n\n    for (const value of this._partitionOwnershipMap.values()) {\n      ownerships.push({ ...value });\n    }\n\n    return ownerships;\n  }\n\n  /**\n   * Claim ownership of a list of partitions. This will return the list of partitions that were owned\n   * successfully.\n   *\n   * @param partitionOwnership - The list of partition ownership this instance is claiming to own.\n   * @returns A list partitions this instance successfully claimed ownership.\n   */\n  async claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]> {\n    const claimedOwnerships = [];\n\n    for (const ownership of partitionOwnership) {\n      if (\n        !this._partitionOwnershipMap.has(ownership.partitionId) ||\n        this._partitionOwnershipMap.get(ownership.partitionId)!.etag === ownership.etag\n      ) {\n        const date = new Date();\n\n        const newOwnership = {\n          ...ownership,\n          etag: generate_uuid(),\n          lastModifiedTimeInMs: date.getTime()\n        };\n\n        this._partitionOwnershipMap.set(newOwnership.partitionId, newOwnership);\n        claimedOwnerships.push(newOwnership);\n      }\n    }\n    return claimedOwnerships;\n  }\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint - The checkpoint.\n   */\n  async updateCheckpoint(checkpoint: Checkpoint): Promise<void> {\n    throwTypeErrorIfParameterMissing(\n      \"\",\n      \"updateCheckpoint\",\n      \"sequenceNumber\",\n      checkpoint.sequenceNumber\n    );\n    throwTypeErrorIfParameterMissing(\"\", \"updateCheckpoint\", \"offset\", checkpoint.offset);\n\n    checkpoint = { ...checkpoint };\n\n    const partitionOwnership = this._partitionOwnershipMap.get(checkpoint.partitionId);\n    if (partitionOwnership) {\n      partitionOwnership.etag = generate_uuid();\n\n      const key = `${checkpoint.fullyQualifiedNamespace}:${checkpoint.eventHubName}:${checkpoint.consumerGroup}`;\n      let partitionMap = this._committedCheckpoints.get(key);\n\n      if (partitionMap == null) {\n        partitionMap = new Map();\n        this._committedCheckpoints.set(key, partitionMap);\n      }\n\n      partitionMap.set(checkpoint.partitionId, checkpoint);\n    }\n  }\n\n  async listCheckpoints(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<Checkpoint[]> {\n    const key = `${fullyQualifiedNamespace}:${eventHubName}:${consumerGroup}`;\n\n    const partitionMap = this._committedCheckpoints.get(key);\n\n    if (partitionMap == null) {\n      return [];\n    }\n\n    const checkpoints = [];\n\n    for (const value of partitionMap.values()) {\n      checkpoints.push({ ...value });\n    }\n\n    return checkpoints;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"../util/operationOptions\";\nimport { RetryOptions, WebSocketOptions } from \"@azure/core-amqp\";\n\n/**\n * The set of options to configure the behavior of `getEventHubProperties`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetEventHubPropertiesOptions extends OperationOptions {}\n\n/**\n * The set of options to configure the behavior of `getPartitionProperties`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetPartitionPropertiesOptions extends OperationOptions {}\n\n/**\n * The set of options to configure the behavior of `getPartitionIds`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetPartitionIdsOptions extends OperationOptions {}\n\n/**\n * Options to configure the `sendBatch` method on the `EventHubProducerClient`\n * when sending an array of events.\n * If `partitionId` is set, `partitionKey` must not be set and vice versa.\n *\n * - `partitionId`  : The partition this batch will be sent to.\n * - `partitionKey` : A value that is hashed to produce a partition assignment.\n * - `abortSignal`  : A signal used to cancel the send operation.\n */\nexport interface SendBatchOptions extends OperationOptions {\n  /**\n   * The partition this batch will be sent to.\n   * If this value is set then partitionKey can not be set.\n   */\n  partitionId?: string;\n  /**\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  partitionKey?: string;\n}\n\n/**\n * The set of options to configure the `send` operation on the `EventHubProducer`.\n * - `partitionKey` : A value that is hashed to produce a partition assignment.\n * - `abortSignal`  : A signal used to cancel the send operation.\n *\n * Example usage:\n * ```js\n * {\n *     partitionKey: 'foo'\n * }\n * ```\n *\n * @internal\n */\nexport interface SendOptions extends OperationOptions {\n  /**\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  partitionKey?: string;\n}\n\n/**\n * An enum representing the different reasons for an `EventHubConsumerClient` to stop processing\n * events from a partition in a consumer group of an Event Hub.\n */\nexport enum CloseReason {\n  /**\n   * Ownership of the partition was lost or transitioned to a new processor instance.\n   */\n  OwnershipLost = \"OwnershipLost\",\n  /**\n   * The EventProcessor was shutdown.\n   */\n  Shutdown = \"Shutdown\"\n}\n\n/**\n * Describes the options that can be provided while creating the EventHubClient.\n * - `userAgent`        : A string to append to the built in user agent string that is passed as a connection property\n * to the service.\n * - `webSocketOptions` : Options to configure the channelling of the AMQP connection over Web Sockets.\n *    - `websocket`     : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n * over a WebSocket.\n *    - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n * over a WebSocket.\n * - `retryOptions`     : The retry options for all the operations on the client/producer/consumer.\n *    - `maxRetries` : The number of times the operation can be retried in case of a retryable error.\n *    - `maxRetryDelayInMs`: The maximum delay between retries. Applicable only when performing exponential retries.\n *    - `mode`: Which retry mode to apply, specified by the `RetryMode` enum. Options are `Exponential` and `Fixed`. Defaults to `Fixed`.\n *    - `retryDelayInMs`: Amount of time to wait in milliseconds before making the next attempt. When `mode` is set to `Exponential`,\n *       this is used to compute the exponentially increasing delays between retries. Default: 30000 milliseconds.\n *    - `timeoutInMs`: Amount of time in milliseconds to wait before the operation times out. This will trigger a retry if there are any\n *       retry attempts remaining. Minimum value: 60000 milliseconds.\n *\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * Example usage:\n * ```js\n * {\n *     retryOptions: {\n *         maxRetries: 4\n *     }\n * }\n * ```\n */\nexport interface EventHubClientOptions {\n  /**\n   * A custom endpoint to use when connecting to the Event Hubs service.\n   * This can be useful when your network does not allow connecting to the\n   * standard Azure Event Hubs endpoint address, but does allow connecting\n   * through an intermediary.\n   *\n   * Example: \"https://my.custom.endpoint:100/\"\n   */\n  customEndpointAddress?: string;\n  /**\n   * Options to configure the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   *\n   */\n  retryOptions?: RetryOptions;\n  /**\n   * Options to configure the channelling of the AMQP connection over Web Sockets.\n   */\n  webSocketOptions?: WebSocketOptions;\n  /**\n   * Value that is appended to the built in user agent string that is passed to the Event Hubs service.\n   */\n  userAgent?: string;\n}\n\n/**\n * Describes the options that can be provided while creating the EventHubConsumerClient.\n * - `loadBalancingOptions`: Options to tune how the EventHubConsumerClient claims partitions.\n * - `userAgent`        : A string to append to the built in user agent string that is passed as a connection property\n * to the service.\n * - `webSocketOptions` : Options to configure the channelling of the AMQP connection over Web Sockets.\n *    - `websocket`     : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n * over a WebSocket.\n *    - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n * over a WebSocket.\n * - `retryOptions`     : The retry options for all the operations on the client/producer/consumer.\n *    - `maxRetries` : The number of times the operation can be retried in case of a retryable error.\n *    - `maxRetryDelayInMs`: The maximum delay between retries. Applicable only when performing exponential retries.\n *    - `mode`: Which retry mode to apply, specified by the `RetryMode` enum. Options are `Exponential` and `Fixed`. Defaults to `Fixed`.\n *    - `retryDelayInMs`: Amount of time to wait in milliseconds before making the next attempt. When `mode` is set to `Exponential`,\n *       this is used to compute the exponentially increasing delays between retries. Default: 30000 milliseconds.\n *    - `timeoutInMs`: Amount of time in milliseconds to wait before the operation times out. This will trigger a retry if there are any\n *       retry attempts remaining. Minimum value: 60000 milliseconds.\n *\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * Example usage:\n * ```js\n * {\n *     retryOptions: {\n *         maxRetries: 4\n *     }\n * }\n * ```\n */\nexport interface EventHubConsumerClientOptions extends EventHubClientOptions {\n  /**\n   * Options to tune how the EventHubConsumerClient claims partitions.\n   */\n  loadBalancingOptions?: LoadBalancingOptions;\n}\n\n/**\n * An options bag to configure load balancing settings.\n */\nexport interface LoadBalancingOptions {\n  /**\n   * Whether to apply a greedy or a more balanced approach when\n   * claiming partitions.\n   *\n   * - balanced: The `EventHubConsumerClient` will take a measured approach to\n   * requesting partition ownership when balancing work with other clients,\n   * slowly claiming partitions until a stabilized distribution is achieved.\n   *\n   * - greedy: The `EventHubConsumerClient` will attempt to claim ownership\n   * of its fair share of partitions aggressively when balancing work with\n   * other clients.\n   *\n   * This option is ignored when either:\n   *   - `CheckpointStore` is __not__ provided to the `EventHubConsumerClient`.\n   *   - `subscribe()` is called for a single partition.\n   * Default: balanced\n   */\n  strategy?: \"balanced\" | \"greedy\";\n  /**\n   * The length of time between attempts to claim partitions.\n   * Default: 10000\n   */\n  updateIntervalInMs?: number;\n  /**\n   * The length of time a partition claim is valid.\n   * Default: 60000\n   */\n  partitionOwnershipExpirationIntervalInMs?: number;\n}\n\n/**\n * Options to configure the `createBatch` method on the `EventHubProducerClient`.\n * - `partitionKey`  : A value that is hashed to produce a partition assignment.\n * - `maxSizeInBytes`: The upper limit for the size of batch.\n * - `abortSignal`   : A signal the request to cancel the send operation.\n *\n * Example usage:\n * ```js\n * {\n *     partitionKey: 'foo',\n *     maxSizeInBytes: 1024 * 1024 // 1 MB\n * }\n * ```\n */\nexport interface CreateBatchOptions extends OperationOptions {\n  /**\n   * A value that is hashed to produce a partition assignment. It guarantees that messages\n   * with the same partitionKey end up in the same partition.\n   * If this value is set then partitionId can not be set.\n   */\n  partitionKey?: string;\n  /**\n   * The partition this batch will be sent to.\n   * If this value is set then partitionKey can not be set.\n   */\n  partitionId?: string;\n  /**\n   * The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   */\n  maxSizeInBytes?: number;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { message } from \"rhea-promise\";\nimport isBuffer from \"is-buffer\";\nimport { Buffer } from \"buffer\";\nimport { logErrorStackTrace, logger } from \"./log\";\n\n/**\n * The allowed AMQP message body types.\n * @internal\n */\nexport type BodyTypes = \"data\" | \"value\" | \"sequence\";\n\n/** @internal */\nexport const dataSectionTypeCode = 0x75 as const;\n/** @internal */\nexport const sequenceSectionTypeCode = 0x76 as const;\n/** @internal */\nexport const valueSectionTypeCode = 0x77 as const;\n\n/**\n * The default data transformer that will be used by the Azure SDK.\n * @internal\n */\nexport const defaultDataTransformer = {\n  /**\n   * A function that takes the body property from an EventData object\n   * and returns an encoded body (some form of AMQP type).\n   *\n   * @param body - The AMQP message body\n   * @param bodyType - The AMQP section to story the body in.\n   * @returns The encoded AMQP message body as an AMQP Data/Sequence/Value section.\n   */\n  encode(body: unknown, bodyType: BodyTypes): any {\n    let result: any;\n    // string, undefined, null, boolean, array, object, number should end up here\n    // coercing undefined to null as that will ensure that null value will be given to the\n    // customer on receive.\n    if (body === undefined) body = null;\n\n    if (bodyType === \"value\") {\n      // TODO: Expose value_section from `rhea` similar to the data_section and sequence_section.\n      // Right now there isn't a way to create a value section officially.\n      result = message.data_section(body);\n      result.typecode = valueSectionTypeCode;\n    } else if (bodyType === \"sequence\") {\n      result = message.sequence_section(body);\n    } else if (isBuffer(body)) {\n      result = message.data_section(body);\n    } else if (body === null && bodyType === \"data\") {\n      result = message.data_section(null);\n    } else {\n      try {\n        const bodyStr = JSON.stringify(body);\n        result = message.data_section(Buffer.from(bodyStr, \"utf8\"));\n      } catch (err) {\n        const msg =\n          `An error occurred while executing JSON.stringify() on the given body ` +\n          body +\n          `${err ? err.stack : JSON.stringify(err)}`;\n        logger.warning(\"[encode] \" + msg);\n        logErrorStackTrace(err);\n        throw new Error(msg);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * A function that takes the body property from an AMQP message, which can come from either\n   * the 'data', 'value' or 'sequence' sections of an AMQP message.\n   *\n   * If the body is not a JSON string the the raw contents will be returned, along with the bodyType\n   * indicating which part of the AMQP message the body was decoded from.\n   *\n   * @param body - The AMQP message body as received from rhea.\n   * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body when body type is `content`.\n   * @returns The decoded/raw body and the body type.\n   */\n  decode(\n    body: unknown | RheaAmqpSection,\n    skipParsingBodyAsJson: boolean\n  ): { body: unknown; bodyType: BodyTypes } {\n    try {\n      if (isRheaAmqpSection(body)) {\n        switch (body.typecode) {\n          case dataSectionTypeCode:\n            return {\n              body: skipParsingBodyAsJson ? body.content : tryToJsonDecode(body.content),\n              bodyType: \"data\"\n            };\n          case sequenceSectionTypeCode:\n            return { body: body.content, bodyType: \"sequence\" };\n          case valueSectionTypeCode:\n            return { body: body.content, bodyType: \"value\" };\n        }\n      } else {\n        if (isBuffer(body)) {\n          return { body: skipParsingBodyAsJson ? body : tryToJsonDecode(body), bodyType: \"data\" };\n        }\n\n        return { body, bodyType: \"value\" };\n      }\n    } catch (err) {\n      logger.verbose(\n        \"[decode] An error occurred while decoding the received message body. The error is: %O\",\n        err\n      );\n      throw err;\n    }\n  }\n};\n\n/**\n * Attempts to decode 'body' as a JSON string. If it fails it returns body\n * verbatim.\n *\n * @param body - An AMQP message body.\n * @returns A JSON decoded object, or body if body was not a JSON string.\n *\n * @internal\n */\nfunction tryToJsonDecode(body: unknown): unknown {\n  let processedBody: any = body;\n  try {\n    // Trying to stringify and JSON.parse() anything else will fail flat and we shall return\n    // the original type back\n    const bodyStr: string = processedBody.toString(\"utf8\");\n    processedBody = JSON.parse(bodyStr);\n  } catch (err) {\n    logger.verbose(\n      \"[decode] An error occurred while trying JSON.parse() on the received body. The error is %O\",\n      err\n    );\n  }\n  return processedBody;\n}\n\n/**\n * Mirror of the internal Section interface in rhea.\n *\n * @internal\n */\nexport interface RheaAmqpSection {\n  typecode:\n    | typeof dataSectionTypeCode\n    | typeof sequenceSectionTypeCode\n    | typeof valueSectionTypeCode;\n  content: any;\n}\n\n/** @internal */\nexport function isRheaAmqpSection(\n  possibleSection: any | RheaAmqpSection\n): possibleSection is RheaAmqpSection {\n  return (\n    possibleSection != null &&\n    typeof possibleSection.typecode === \"number\" &&\n    (possibleSection.typecode === dataSectionTypeCode ||\n      possibleSection.typecode === valueSectionTypeCode ||\n      possibleSection.typecode === sequenceSectionTypeCode)\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { DeliveryAnnotations, Message as RheaMessage, MessageAnnotations } from \"rhea-promise\";\nimport { AmqpAnnotatedMessage, Constants } from \"@azure/core-amqp\";\nimport { isDefined, isObjectWithProperties, objectHasProperty } from \"./util/typeGuards\";\nimport { BodyTypes, defaultDataTransformer } from \"./dataTransformer\";\n\n/**\n * Describes the delivery annotations.\n * @hidden\n */\nexport interface EventHubDeliveryAnnotations extends DeliveryAnnotations {\n  /**\n   * The offset of the last event.\n   */\n  last_enqueued_offset?: string;\n  /**\n   * The sequence number of the last event.\n   */\n  last_enqueued_sequence_number?: number;\n  /**\n   * The enqueued time of the last event.\n   */\n  last_enqueued_time_utc?: number;\n  /**\n   * The retrieval time of the last event.\n   */\n  runtime_info_retrieval_time_utc?: number;\n  /**\n   * Any unknown delivery annotations.\n   */\n  [x: string]: any;\n}\n\n/**\n * Map containing message attributes that will be held in the message header.\n * @hidden\n */\nexport interface EventHubMessageAnnotations extends MessageAnnotations {\n  /**\n   * Annotation for the partition key set for the event.\n   */\n  \"x-opt-partition-key\"?: string | null;\n  /**\n   * Annontation for the sequence number of the event.\n   */\n  \"x-opt-sequence-number\"?: number;\n  /**\n   * Annotation for the enqueued time of the event.\n   */\n  \"x-opt-enqueued-time\"?: number;\n  /**\n   * Annotation for the offset of the event.\n   */\n  \"x-opt-offset\"?: string;\n  /**\n   * Any other annotation that can be added to the message.\n   */\n  [x: string]: any;\n}\n\n/**\n * Describes the structure of an event to be sent or received from the EventHub.\n * @hidden\n */\nexport interface EventDataInternal {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The enqueued time of the event.\n   */\n  enqueuedTimeUtc?: Date;\n  /**\n   * If specified EventHub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey?: string | null;\n  /**\n   * The offset of the event.\n   */\n  offset?: number;\n  /**\n   * The sequence number of the event.\n   */\n  sequenceNumber?: number;\n  /**\n   * The application specific properties.\n   */\n  properties?: { [property: string]: any };\n  /**\n   * The last sequence number of the event within the partition stream of the Event Hub.\n   */\n  lastSequenceNumber?: number;\n  /**\n   * The offset of the last enqueued event.\n   */\n  lastEnqueuedOffset?: string;\n  /**\n   * The enqueued UTC time of the last event.\n   */\n  lastEnqueuedTime?: Date;\n  /**\n   * The time when the runtime info was retrieved\n   */\n  retrievalTime?: Date;\n  /**\n   * The properties set by the service.\n   */\n  systemProperties?: { [property: string]: any };\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * Returns the underlying raw amqp message.\n   */\n  getRawAmqpMessage(): AmqpAnnotatedMessage;\n}\n\nconst messagePropertiesMap = {\n  message_id: \"messageId\",\n  user_id: \"userId\",\n  to: \"to\",\n  subject: \"subject\",\n  reply_to: \"replyTo\",\n  correlation_id: \"correlationId\",\n  content_type: \"contentType\",\n  content_encoding: \"contentEncoding\",\n  absolute_expiry_time: \"absoluteExpiryTime\",\n  creation_time: \"creationTime\",\n  group_id: \"groupId\",\n  group_sequence: \"groupSequence\",\n  reply_to_group_id: \"replyToGroupId\"\n} as const;\n\n/**\n * Converts the AMQP message to an EventData.\n * @param msg - The AMQP message that needs to be converted to EventData.\n * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body when body type is `content`.\n * @hidden\n */\nexport function fromRheaMessage(\n  msg: RheaMessage,\n  skipParsingBodyAsJson: boolean\n): EventDataInternal {\n  const rawMessage = AmqpAnnotatedMessage.fromRheaMessage(msg);\n  const { body, bodyType } = defaultDataTransformer.decode(msg.body, skipParsingBodyAsJson);\n  rawMessage.bodyType = bodyType;\n\n  const data: EventDataInternal = {\n    body,\n    getRawAmqpMessage() {\n      return rawMessage;\n    }\n  };\n\n  if (msg.message_annotations) {\n    for (const annotationKey of Object.keys(msg.message_annotations)) {\n      switch (annotationKey) {\n        case Constants.partitionKey:\n          data.partitionKey = msg.message_annotations[annotationKey];\n          break;\n        case Constants.sequenceNumber:\n          data.sequenceNumber = msg.message_annotations[annotationKey];\n          break;\n        case Constants.enqueuedTime:\n          data.enqueuedTimeUtc = new Date(msg.message_annotations[annotationKey]);\n          break;\n        case Constants.offset:\n          data.offset = msg.message_annotations[annotationKey];\n          break;\n        default:\n          if (!data.systemProperties) {\n            data.systemProperties = {};\n          }\n          data.systemProperties[annotationKey] = convertDatesToNumbers(\n            msg.message_annotations[annotationKey]\n          );\n          break;\n      }\n    }\n  }\n  if (msg.application_properties) {\n    data.properties = convertDatesToNumbers(msg.application_properties);\n  }\n  if (msg.delivery_annotations) {\n    data.lastEnqueuedOffset = msg.delivery_annotations.last_enqueued_offset;\n    data.lastSequenceNumber = msg.delivery_annotations.last_enqueued_sequence_number;\n    data.lastEnqueuedTime = new Date(msg.delivery_annotations.last_enqueued_time_utc as number);\n    data.retrievalTime = new Date(\n      msg.delivery_annotations.runtime_info_retrieval_time_utc as number\n    );\n  }\n\n  const messageProperties = Object.keys(messagePropertiesMap) as Array<\n    keyof typeof messagePropertiesMap\n  >;\n  for (const messageProperty of messageProperties) {\n    if (!data.systemProperties) {\n      data.systemProperties = {};\n    }\n    if (msg[messageProperty] != null) {\n      data.systemProperties[messagePropertiesMap[messageProperty]] = convertDatesToNumbers(\n        msg[messageProperty]\n      );\n    }\n  }\n\n  if (msg.content_type != null) {\n    data.contentType = msg.content_type;\n  }\n  if (msg.correlation_id != null) {\n    data.correlationId = msg.correlation_id;\n  }\n  if (msg.message_id != null) {\n    data.messageId = msg.message_id;\n  }\n\n  return data;\n}\n\n/**\n * Converts an EventData object to an AMQP message.\n * @param data - The EventData object that needs to be converted to an AMQP message.\n * @param partitionKey - An optional key to determine the partition that this event should land in.\n * @internal\n */\nexport function toRheaMessage(\n  data: EventData | AmqpAnnotatedMessage,\n  partitionKey?: string\n): RheaMessage {\n  let rheaMessage: RheaMessage;\n  if (isAmqpAnnotatedMessage(data)) {\n    rheaMessage = {\n      ...AmqpAnnotatedMessage.toRheaMessage(data),\n      body: defaultDataTransformer.encode(data.body, data.bodyType ?? \"data\")\n    };\n  } else {\n    let bodyType: BodyTypes = \"data\";\n    if (typeof (data as EventDataInternal).getRawAmqpMessage === \"function\") {\n      /*\n        If the event is being round-tripped, then we respect the `bodyType` of the\n        underlying AMQP message.\n      */\n      bodyType = (data as EventDataInternal).getRawAmqpMessage().bodyType ?? \"data\";\n    }\n\n    rheaMessage = {\n      body: defaultDataTransformer.encode(data.body, bodyType)\n    };\n    // As per the AMQP 1.0 spec If the message-annotations or delivery-annotations section is omitted,\n    // it is equivalent to a message-annotations section containing anempty map of annotations.\n    rheaMessage.message_annotations = {};\n\n    if (data.properties) {\n      rheaMessage.application_properties = data.properties;\n    }\n\n    if (isDefined(partitionKey)) {\n      rheaMessage.message_annotations[Constants.partitionKey] = partitionKey;\n      // Event Hub service cannot route messages to a specific partition based on the partition key\n      // if AMQP message header is an empty object. Hence we make sure that header is always present\n      // with atleast one property. Setting durable to true, helps us achieve that.\n      rheaMessage.durable = true;\n    }\n\n    if (data.contentType != null) {\n      rheaMessage.content_type = data.contentType;\n    }\n    if (data.correlationId != null) {\n      rheaMessage.correlation_id = data.correlationId;\n    }\n    if (data.messageId != null) {\n      if (\n        typeof data.messageId === \"string\" &&\n        data.messageId.length > Constants.maxMessageIdLength\n      ) {\n        throw new Error(\n          `Length of 'messageId' property on the event cannot be greater than ${Constants.maxMessageIdLength} characters.`\n        );\n      }\n      rheaMessage.message_id = data.messageId;\n    }\n  }\n\n  return rheaMessage;\n}\n\n/**\n * The interface that describes the data to be sent to Event Hub.\n * Use this as a reference when creating the object to be sent when using the `EventHubProducerClient`.\n * For example, `{ body: \"your-data\" }` or\n * ```\n * {\n *    body: \"your-data\",\n *    properties: {\n *       propertyName: \"property value\"\n *    }\n * }\n * ```\n */\nexport interface EventData {\n  /**\n   * The message body that needs to be sent.\n   * If the application reading the events is not using this SDK,\n   * convert your body payload to a byte array or Buffer for better\n   * cross-language compatibility.\n   */\n  body: any;\n\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n\n  /**\n   * Set of key value pairs that can be used to set properties specific to user application.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n}\n\n/**\n * The interface that describes the structure of the event received from Event Hub.\n * Use this as a reference when creating the `processEvents` function to process the events\n * recieved from an Event Hub when using the `EventHubConsumerClient`.\n */\nexport interface ReceivedEventData {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The application specific properties.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n  /**\n   * The enqueued time of the event.\n   */\n  enqueuedTimeUtc: Date;\n  /**\n   * When specified Event Hub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey: string | null;\n  /**\n   * The offset of the event.\n   */\n  offset: number;\n  /**\n   * The sequence number of the event.\n   */\n  sequenceNumber: number;\n  /**\n   * The properties set by the service.\n   */\n  systemProperties?: {\n    [key: string]: any;\n  };\n\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   */\n  messageId?: string | number | Buffer;\n\n  /**\n   * Returns the underlying raw amqp message.\n   */\n  getRawAmqpMessage(): AmqpAnnotatedMessage;\n}\n\n/**\n * @internal\n */\nexport function isAmqpAnnotatedMessage(possible: unknown): possible is AmqpAnnotatedMessage {\n  return (\n    isObjectWithProperties(possible, [\"body\", \"bodyType\"]) &&\n    !objectHasProperty(possible, \"getRawAmqpMessage\")\n  );\n}\n\n/**\n * Converts any Date objects into a number representing date.getTime().\n * Recursively checks for any Date objects in arrays and objects.\n * @internal\n */\nfunction convertDatesToNumbers<T = unknown>(thing: T): T {\n  // fast exit\n  if (!isDefined(thing)) return thing;\n\n  // When 'thing' is a Date, return the number representation\n  if (\n    typeof thing === \"object\" &&\n    objectHasProperty(thing, \"getTime\") &&\n    typeof thing.getTime === \"function\"\n  ) {\n    return thing.getTime();\n  }\n\n  /*\n    Examples:\n    [0, 'foo', new Date(), { nested: new Date()}]\n  */\n  if (Array.isArray(thing)) {\n    return (thing.map(convertDatesToNumbers) as unknown) as T;\n  }\n\n  /*\n    Examples:\n    { foo: new Date(), children: { nested: new Date() }}\n  */\n  if (typeof thing === \"object\" && isDefined(thing)) {\n    thing = { ...thing };\n    for (const key of Object.keys(thing)) {\n      (thing as any)[key] = convertDatesToNumbers((thing as any)[key]);\n    }\n  }\n\n  return thing;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants, ErrorNameConditionMapper, translate } from \"@azure/core-amqp\";\nimport { isDefined, objectHasProperty } from \"./util/typeGuards\";\n\n/**\n * Represents the position of an event in an Event Hub partition, typically used when calling the `subscribe()`\n * method on an `EventHubConsumerClient` to specify the position in the partition to begin receiving events from.\n *\n * To get an EventPosition representing the start or end of the stream, use the constants\n * `earliestEventPosition` and `latestEventPosition` respectively.\n *\n */\nexport interface EventPosition {\n  /**\n   * The offset of the event identified by this position.\n   * Expected to be undefined if the position is just created from a sequence number or an enqueued time.\n   *\n   * The offset is the relative position for an event in the context of the partition.\n   * The offset should not be considered a stable value.\n   * The same offset may refer to a different event as events reach the age limit for\n   * retention and are no longer visible within the partition.\n   */\n  offset?: number | \"@latest\";\n  /**\n   * Indicates if the specified offset is inclusive of the event which it identifies.\n   * This information is only relevent if the event position was identified by an offset or sequence number.\n   * Default value: `false`.\n   */\n  isInclusive?: boolean;\n  /**\n   * The enqueued time in UTC of the event identified by this position.\n   * When provided as a number this value is the number of milliseconds since the Unix Epoch.\n   * Expected to be undefined if the position is just created from a sequence number or an offset.\n   */\n  enqueuedOn?: Date | number;\n\n  /**\n   * The sequence number of the event identified by this position.\n   * Expected to be undefined if the position is just created from an offset or enqueued time.\n   */\n  sequenceNumber?: number;\n}\n\n/**\n * @internal\n * Gets the expression to be set as the filter clause when creating the receiver\n * @returns filterExpression\n */\nexport function getEventPositionFilter(eventPosition: EventPosition): string {\n  let result;\n  // order of preference\n  if (isDefined(eventPosition.offset)) {\n    result = eventPosition.isInclusive\n      ? `${Constants.offsetAnnotation} >= '${eventPosition.offset}'`\n      : `${Constants.offsetAnnotation} > '${eventPosition.offset}'`;\n  } else if (isDefined(eventPosition.sequenceNumber)) {\n    result = eventPosition.isInclusive\n      ? `${Constants.sequenceNumberAnnotation} >= '${eventPosition.sequenceNumber}'`\n      : `${Constants.sequenceNumberAnnotation} > '${eventPosition.sequenceNumber}'`;\n  } else if (isDefined(eventPosition.enqueuedOn)) {\n    const time =\n      eventPosition.enqueuedOn instanceof Date\n        ? eventPosition.enqueuedOn.getTime()\n        : eventPosition.enqueuedOn;\n    result = `${Constants.enqueuedTimeAnnotation} > '${time}'`;\n  }\n\n  if (!result) {\n    throw translate({\n      condition: ErrorNameConditionMapper.ArgumentError,\n      description: \"No starting position was set in the EventPosition.\"\n    });\n  }\n  return result;\n}\n\n/**\n * @internal\n */\nexport function isLatestPosition(eventPosition: EventPosition): boolean {\n  if (eventPosition.offset === \"@latest\") {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Gets the `EventPosition` corresponding to the location of the the first event present in the partition.\n * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the\n * first event in the partition which has not expired due to the retention policy.\n */\nexport const earliestEventPosition: EventPosition = {\n  offset: -1\n};\n\n/**\n * Gets the `EventPosition` corresponding to the end of the partition.\n * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the\n * event that is enqueued right after the method call.\n * @returns EventPosition\n */\nexport const latestEventPosition: EventPosition = {\n  offset: \"@latest\"\n};\n\n/**\n * @internal\n */\nexport function validateEventPositions(\n  position: EventPosition | { [partitionId: string]: EventPosition }\n): void {\n  if (!isDefined(position)) {\n    return;\n  }\n\n  const keys = Object.keys(position);\n\n  if (!keys.length) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.\"\n    );\n  }\n\n  if (isEventPosition(position)) {\n    validateEventPosition(position);\n    return;\n  }\n\n  const positions = position as { [partitionId: string]: EventPosition };\n  for (let i = 0; i < keys.length; i++) {\n    if (Object.prototype.hasOwnProperty.call(positions, keys[i])) {\n      validateEventPosition(positions[keys[i]]);\n    }\n  }\n}\n\n/**\n * Determines whether a position is an EventPosition.\n * Does not validate that the position is allowed.\n * @internal\n */\nexport function isEventPosition(position: unknown): position is EventPosition {\n  if (!position) {\n    return false;\n  }\n\n  if (objectHasProperty(position, \"offset\") && isDefined(position.offset)) {\n    return true;\n  }\n\n  if (objectHasProperty(position, \"sequenceNumber\") && isDefined(position.sequenceNumber)) {\n    return true;\n  }\n\n  if (objectHasProperty(position, \"enqueuedOn\") && isDefined(position.enqueuedOn)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction validateEventPosition(position: EventPosition): void {\n  if (!isDefined(position)) {\n    return;\n  }\n  const offsetPresent = isDefined(position.offset);\n  const sequenceNumberPresent = isDefined(position.sequenceNumber);\n  const enqueuedOnPresent = isDefined(position.enqueuedOn);\n\n  if (\n    (offsetPresent && sequenceNumberPresent) ||\n    (offsetPresent && enqueuedOnPresent) ||\n    (enqueuedOnPresent && sequenceNumberPresent)\n  ) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Set only one of offset, sequenceNumber or enqueuedOn properties.\"\n    );\n  }\n\n  if (!offsetPresent && !enqueuedOnPresent && !sequenceNumberPresent) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.\"\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logErrorStackTrace, logger } from \"./log\";\nimport {\n  EventContext,\n  OnAmqpEvent,\n  Receiver,\n  ReceiverOptions as RheaReceiverOptions,\n  types\n} from \"rhea-promise\";\nimport {\n  Constants,\n  MessagingError,\n  delay,\n  translate,\n  RetryConfig,\n  RetryOperationType,\n  retry,\n  StandardAbortMessage\n} from \"@azure/core-amqp\";\nimport { EventDataInternal, ReceivedEventData, fromRheaMessage } from \"./eventData\";\nimport { EventHubConsumerOptions } from \"./models/private\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { EventPosition, getEventPositionFilter } from \"./eventPosition\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\n\n/**\n * @hidden\n */\ninterface CreateReceiverOptions {\n  onMessage: OnAmqpEvent;\n  onError: OnAmqpEvent;\n  onClose: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSessionClose: OnAmqpEvent;\n  eventPosition?: EventPosition;\n}\n\n/**\n * A set of information about the last enqueued event of a partition, as observed by the consumer as\n * events are received from the Event Hubs service\n */\nexport interface LastEnqueuedEventProperties {\n  /**\n   * The sequence number of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  sequenceNumber?: number;\n  /**\n   * The date and time, in UTC, that the last event was enqueued into the Event Hub partition from\n   * which this event was received.\n   */\n  enqueuedOn?: Date;\n  /**\n   * The offset of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  offset?: string;\n  /**\n   * The date and time, in UTC, that the last event was retrieved from the Event Hub partition.\n   */\n  retrievedOn?: Date;\n}\n\n/**\n * Describes the message handler signature.\n * @internal\n */\nexport type OnMessage = (eventData: ReceivedEventData) => void;\n\n/**\n * Describes the error handler signature.\n * @internal\n */\nexport type OnError = (error: MessagingError | Error) => void;\n\n/**\n * Describes the abort handler signature.\n * @internal\n */\nexport type OnAbort = () => void;\n\n/**\n * Describes the EventHubReceiver that will receive event data from EventHub.\n * @internal\n */\nexport class EventHubReceiver extends LinkEntity {\n  /**\n   * The EventHub consumer group from which the receiver will\n   * receive messages. (Default: \"default\").\n   */\n  consumerGroup: string;\n  /**\n   * The receiver runtime info.\n   */\n  runtimeInfo: LastEnqueuedEventProperties;\n  /**\n   * The Receiver ownerLevel.\n   */\n  ownerLevel?: number;\n  /**\n   * The event position in the partition at which to start receiving messages.\n   */\n  eventPosition: EventPosition;\n  /**\n   * Optional properties that can be set while creating\n   * the EventHubConsumer.\n   */\n  options: EventHubConsumerOptions;\n  /**\n   * The RHEA AMQP-based receiver link.\n   */\n  private _receiver?: Receiver;\n  /**\n   * The message handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onMessage?: OnMessage;\n  /**\n   * The error handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onError?: OnError;\n  /**\n   * The abort handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onAbort?: OnAbort;\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal cancelling a receiver operation.\n   */\n  private _abortSignal?: AbortSignalLike;\n  /**\n   * The sequence number of the most recently received AMQP message.\n   */\n  private _checkpoint: number = -1;\n  /**\n   * A queue of events that were received from the AMQP link but not consumed externally by `EventHubConsumer`\n   */\n  private _internalQueue: ReceivedEventData[] = [];\n  /**\n   * Indicates that events in the internal queue are being processed to be consumed by `EventHubConsumer`\n   */\n  private _usingInternalQueue: boolean = false;\n  /**\n   * Indicates if messages are being received from this receiver.\n   */\n  private _isReceivingMessages: boolean = false;\n  /**\n   * Indicated if messages are being received in streaming mode.\n   */\n  private _isStreaming: boolean = false;\n  /**\n   * Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n  /**\n   * Returns sequenceNumber of the last event received from the service. This will not match the\n   * last event received by `EventHubConsumer` when the `_internalQueue` is not empty\n   * @readonly\n   */\n  get checkpoint(): number {\n    return this._checkpoint;\n  }\n\n  /**\n   * Indicates if messages are being received from this receiver.\n   * @readonly\n   */\n  get isReceivingMessages(): boolean {\n    return this._isReceivingMessages;\n  }\n\n  /**\n   * Indicates if the receiver has been closed.\n   */\n  get isClosed(): boolean {\n    return this._isClosed;\n  }\n\n  /**\n   * The last enqueued event information. This property will only\n   * be enabled when `trackLastEnqueuedEventProperties` option is set to true\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this.runtimeInfo;\n  }\n\n  /**\n   * Instantiates a receiver that can be used to receive events over an AMQP receiver link in\n   * either batching or streaming mode.\n   * @hidden\n   * @param context -        The connection context corresponding to the EventHubClient instance\n   * @param consumerGroup -  The consumer group from which the receiver should receive events from.\n   * @param partitionId -    The Partition ID from which to receive.\n   * @param eventPosition -  The position in the stream from where to start receiving events.\n   * @param options -      Receiver options.\n   */\n  constructor(\n    context: ConnectionContext,\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options: EventHubConsumerOptions = {}\n  ) {\n    super(context, {\n      partitionId: partitionId,\n      name: context.config.getReceiverAddress(partitionId, consumerGroup)\n    });\n    this.consumerGroup = consumerGroup;\n    this.address = context.config.getReceiverAddress(partitionId, this.consumerGroup);\n    this.audience = context.config.getReceiverAudience(partitionId, this.consumerGroup);\n    this.ownerLevel = options.ownerLevel;\n    this.eventPosition = eventPosition;\n    this.options = options;\n    this.runtimeInfo = {};\n  }\n\n  private _onAmqpMessage(context: EventContext): void {\n    if (!context.message) {\n      return;\n    }\n    const data: EventDataInternal = fromRheaMessage(\n      context.message,\n      !!this.options.skipParsingBodyAsJson\n    );\n    const rawMessage = data.getRawAmqpMessage();\n    const receivedEventData: ReceivedEventData = {\n      body: data.body,\n      properties: data.properties,\n      offset: data.offset!,\n      sequenceNumber: data.sequenceNumber!,\n      enqueuedTimeUtc: data.enqueuedTimeUtc!,\n      partitionKey: data.partitionKey!,\n      systemProperties: data.systemProperties,\n      getRawAmqpMessage() {\n        return rawMessage;\n      }\n    };\n    if (data.correlationId != null) {\n      receivedEventData.correlationId = data.correlationId;\n    }\n    if (data.contentType != null) {\n      receivedEventData.contentType = data.contentType;\n    }\n    if (data.messageId != null) {\n      receivedEventData.messageId = data.messageId;\n    }\n\n    this._checkpoint = receivedEventData.sequenceNumber;\n\n    if (this.options.trackLastEnqueuedEventProperties && data) {\n      this.runtimeInfo.sequenceNumber = data.lastSequenceNumber;\n      this.runtimeInfo.enqueuedOn = data.lastEnqueuedTime;\n      this.runtimeInfo.offset = data.lastEnqueuedOffset;\n      this.runtimeInfo.retrievedOn = data.retrievalTime;\n    }\n\n    // Add to internal queue if\n    // - There are no listeners, we are probably getting events due to pending credits\n    // - Or Events from internal queue are being processed, so add to it to ensure order of processing is retained\n    if (!this._onMessage || this._usingInternalQueue) {\n      this._internalQueue.push(receivedEventData);\n    } else {\n      if (this._isStreaming) {\n        this._addCredit(1);\n      }\n      this._onMessage(receivedEventData);\n    }\n  }\n\n  private _onAmqpError(context: EventContext): void {\n    const rheaReceiver = this._receiver || context.receiver;\n    const amqpError = rheaReceiver && rheaReceiver.error;\n    logger.verbose(\n      \"[%s] 'receiver_error' event occurred on the receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      amqpError\n    );\n\n    if (this._onError && amqpError) {\n      const error = translate(amqpError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private _onAmqpSessionError(context: EventContext): void {\n    const sessionError = context.session && context.session.error;\n    logger.verbose(\n      \"[%s] 'session_error' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      sessionError\n    );\n\n    if (this._onError && sessionError) {\n      const error = translate(sessionError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private async _onAmqpClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s'. \" +\n        \"Value for isItselfClosed on the receiver is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'receiver_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  private async _onAmqpSessionClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'session_close' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"Value for isSessionItselfClosed on the session is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isSessionItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'session_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  async abort(): Promise<void> {\n    const desc: string =\n      `[${this._context.connectionId}] The receive operation on the Receiver \"${this.name}\" with ` +\n      `address \"${this.address}\" has been cancelled by the user.`;\n    // Cancellation is user-intended, so log to info instead of warning.\n    logger.info(desc);\n    if (this._onError) {\n      const error = new AbortError(StandardAbortMessage);\n      this._onError(error);\n    }\n    this.clearHandlers();\n    await this.close();\n  }\n\n  /**\n   * Clears the user-provided handlers and updates the receiving messages flag.\n   * @hidden\n   */\n  clearHandlers(): void {\n    if (this._abortSignal && this._onAbort) {\n      this._abortSignal.removeEventListener(\"abort\", this._onAbort);\n    }\n\n    this._abortSignal = undefined;\n    this._onAbort = undefined;\n    this._onError = undefined;\n    this._onMessage = undefined;\n    this._isReceivingMessages = false;\n    this._isStreaming = false;\n  }\n\n  /**\n   * Closes the underlying AMQP receiver.\n   * @hidden\n   */\n  async close(): Promise<void> {\n    try {\n      this.clearHandlers();\n\n      if (!this._receiver) {\n        return;\n      }\n\n      const receiverLink = this._receiver;\n      this._deleteFromCache();\n      await this._closeLink(receiverLink);\n    } catch (err) {\n      const msg = `[${this._context.connectionId}] An error occurred while closing receiver ${this.name}: ${err?.name}: ${err?.message}`;\n      logger.warning(msg);\n      logErrorStackTrace(err);\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   * @hidden\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result = Boolean(this._receiver && this._receiver.isOpen());\n    logger.verbose(\n      \"[%s] Receiver '%s' with address '%s' is open? -> %s\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Registers the user's onMessage and onError handlers.\n   * Sends buffered events from the queue before adding additional credits to the AMQP link.\n   * @hidden\n   */\n  registerHandlers(\n    onMessage: OnMessage,\n    onError: OnError,\n    maximumCreditCount: number,\n    isStreaming: boolean,\n    abortSignal?: AbortSignalLike,\n    onAbort?: OnAbort\n  ): void {\n    this._abortSignal = abortSignal;\n    this._onAbort = onAbort;\n    this._onError = onError;\n    this._onMessage = onMessage;\n    this._isStreaming = isStreaming;\n    // indicate that messages are being received.\n    this._isReceivingMessages = true;\n\n    this._useInternalQueue(onMessage, abortSignal)\n      .then(async (processedEventCount) => {\n        if (this._onMessage !== onMessage) {\n          // the original handler has been removed, so no further action required.\n          return;\n        }\n\n        // check if more messages are required\n        if (!isStreaming && maximumCreditCount - processedEventCount <= 0) {\n          return;\n        }\n\n        if (!this.isOpen()) {\n          try {\n            await this.initialize({\n              abortSignal,\n              timeoutInMs: getRetryAttemptTimeoutInMs(this.options.retryOptions)\n            });\n          } catch (err) {\n            if (this._onError === onError) {\n              onError(err);\n            }\n            return;\n          }\n        } else {\n          logger.verbose(\n            \"[%s] Receiver link already present, hence reusing it.\",\n            this._context.connectionId\n          );\n        }\n        // add credits\n        const existingCredits = this._receiver ? this._receiver.credit : 0;\n        const prcoessedEventCountToExclude = isStreaming ? 0 : processedEventCount;\n        const creditsToAdd = Math.max(\n          maximumCreditCount - (existingCredits + prcoessedEventCountToExclude),\n          0\n        );\n        this._addCredit(creditsToAdd);\n        return;\n      })\n      .catch((err) => {\n        // something really unexpected happened, so attempt to call user's error handler\n        if (this._onError === onError) {\n          onError(err);\n        }\n      });\n  }\n\n  private _addCredit(credit: number): void {\n    if (this._receiver) {\n      this._receiver.addCredit(credit);\n    }\n  }\n\n  private _deleteFromCache(): void {\n    this._receiver = undefined;\n    delete this._context.receivers[this.name];\n    logger.verbose(\n      \"[%s] Deleted the receiver '%s' from the client cache.\",\n      this._context.connectionId,\n      this.name\n    );\n  }\n\n  private async _useInternalQueue(\n    onMessage: OnMessage,\n    abortSignal?: AbortSignalLike\n  ): Promise<number> {\n    let processedMessagesCount = 0;\n    // allow the event loop to process any blocking code outside\n    // this code path before sending any events.\n    await delay(0);\n    this._usingInternalQueue = true;\n    while (this._internalQueue.length) {\n      if (!this._onMessage) {\n        break;\n      }\n\n      if (abortSignal && abortSignal.aborted) {\n        break;\n      }\n\n      // These will not be equal if clearHandlers and registerHandlers were called\n      // in the same tick of the event loop. If onMessage isn't the currently active\n      // handler, it should stop getting messages from the queue.\n      if (this._onMessage !== onMessage) {\n        break;\n      }\n      const eventData = this._internalQueue.splice(0, 1)[0];\n      processedMessagesCount++;\n      onMessage(eventData);\n      // allow the event loop to process any blocking code outside\n      // this code path before sending the next event.\n      await delay(0);\n    }\n    this._usingInternalQueue = false;\n    return processedMessagesCount;\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   * @hidden\n   */\n  async initialize({\n    abortSignal,\n    timeoutInMs\n  }: {\n    abortSignal: AbortSignalLike | undefined;\n    timeoutInMs: number;\n  }): Promise<void> {\n    try {\n      if (!this.isOpen() && !this.isConnecting) {\n        this.isConnecting = true;\n\n        // Wait for the connectionContext to be ready to open the link.\n        await this._context.readyToOpenLink();\n        await this._negotiateClaim({ setTokenRenewal: false, abortSignal, timeoutInMs });\n\n        const receiverOptions: CreateReceiverOptions = {\n          onClose: (context: EventContext) => this._onAmqpClose(context),\n          onError: (context: EventContext) => this._onAmqpError(context),\n          onMessage: (context: EventContext) => this._onAmqpMessage(context),\n          onSessionClose: (context: EventContext) => this._onAmqpSessionClose(context),\n          onSessionError: (context: EventContext) => this._onAmqpSessionError(context)\n        };\n        if (this.checkpoint > -1) {\n          receiverOptions.eventPosition = { sequenceNumber: this.checkpoint };\n        }\n        const options = this._createReceiverOptions(receiverOptions);\n\n        logger.verbose(\n          \"[%s] Trying to create receiver '%s' with options %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        this._receiver = await this._context.connection.createReceiver({ ...options, abortSignal });\n        this.isConnecting = false;\n        logger.verbose(\n          \"[%s] Receiver '%s' created with receiver options: %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        // store the underlying link in a cache\n        this._context.receivers[this.name] = this;\n\n        this._ensureTokenRenewal();\n      } else {\n        logger.verbose(\n          \"[%s] The receiver '%s' with address '%s' is open -> %s and is connecting \" +\n            \"-> %s. Hence not reconnecting.\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          this.isOpen(),\n          this.isConnecting\n        );\n      }\n    } catch (err) {\n      this.isConnecting = false;\n      const error = translate(err);\n      logger.warning(\n        \"[%s] An error occured while creating the receiver '%s': %s\",\n        this._context.connectionId,\n        this.name,\n        `${error?.name}: ${error?.message}`\n      );\n      logErrorStackTrace(err);\n      throw error;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   * @hidden\n   */\n  private _createReceiverOptions(options: CreateReceiverOptions): RheaReceiverOptions {\n    const rcvrOptions: RheaReceiverOptions = {\n      name: this.name,\n      autoaccept: true,\n      source: {\n        address: this.address\n      },\n      credit_window: 0,\n      onMessage: options.onMessage,\n      onError: options.onError,\n      onClose: options.onClose,\n      onSessionError: options.onSessionError,\n      onSessionClose: options.onSessionClose\n    };\n\n    if (typeof this.ownerLevel === \"number\") {\n      rcvrOptions.properties = {\n        [Constants.attachEpoch]: types.wrap_long(this.ownerLevel)\n      };\n    }\n\n    if (this.options.trackLastEnqueuedEventProperties) {\n      rcvrOptions.desired_capabilities = Constants.enableReceiverRuntimeMetricName;\n    }\n\n    const eventPosition = options.eventPosition || this.eventPosition;\n    if (eventPosition) {\n      // Set filter on the receiver if event position is specified.\n      const filterClause = getEventPositionFilter(eventPosition);\n      if (filterClause) {\n        (rcvrOptions.source as any).filter = {\n          \"apache.org:selector-filter:string\": types.wrap_described(filterClause, 0x468c00000004)\n        };\n      }\n    }\n    return rcvrOptions;\n  }\n\n  /**\n   * Returns a promise that resolves to an array of events received from the service.\n   *\n   * @param maxMessageCount - The maximum number of messages to receive.\n   * @param maxWaitTimeInSeconds - The maximum amount of time to wait to build up the requested message count;\n   * If not provided, it defaults to 60 seconds.\n   * @param abortSignal - An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while receiving a message.\n   * @throws Error if the underlying connection or receiver has been closed.\n   * Create a new EventHubConsumer using the EventHubClient createConsumer method.\n   * @throws Error if the receiver is already receiving messages.\n   */\n  async receiveBatch(\n    maxMessageCount: number,\n    maxWaitTimeInSeconds: number = 60,\n    abortSignal?: AbortSignalLike\n  ): Promise<ReceivedEventData[]> {\n    // store events across multiple retries\n    const receivedEvents: ReceivedEventData[] = [];\n\n    const retrieveEvents = (): Promise<ReceivedEventData[]> => {\n      return new Promise((resolve, reject) => {\n        // if this consumer was closed,\n        // resolve the operation's promise with the events collected thus far in case\n        // the promise hasn't already been resolved.\n        if (this._isClosed || this._context.wasConnectionCloseCalled) {\n          return resolve(receivedEvents);\n        }\n\n        let timer: any;\n        const logOnAbort = (): void => {\n          const name = this.name;\n          const address = this.address;\n          const desc: string =\n            `[${this._context.connectionId}] The request operation on the Receiver \"${name}\" with ` +\n            `address \"${address}\" has been cancelled by the user.`;\n          // Cancellation is intentional so logging to 'info'.\n          logger.info(desc);\n        };\n\n        const rejectOnAbort = async (): Promise<void> => {\n          logOnAbort();\n          try {\n            await this.close();\n          } finally {\n            reject(new AbortError(StandardAbortMessage));\n          }\n        };\n\n        // operation has been cancelled, so exit immediately\n        if (abortSignal && abortSignal.aborted) {\n          return rejectOnAbort();\n        }\n\n        // updates the prefetch count so that the baseConsumer adds\n        // the correct number of credits to receive the same number of events.\n        const prefetchCount = Math.max(maxMessageCount - receivedEvents.length, 0);\n        if (prefetchCount === 0) {\n          return resolve(receivedEvents);\n        }\n\n        logger.verbose(\n          \"[%s] Receiver '%s', setting the prefetch count to %d.\",\n          this._context.connectionId,\n          this.name,\n          prefetchCount\n        );\n\n        const cleanUpBeforeReturn = (): void => {\n          this.clearHandlers();\n          clearTimeout(timer);\n        };\n\n        const onAbort = (): void => {\n          clearTimeout(timer);\n          rejectOnAbort();\n        };\n\n        this.registerHandlers(\n          (eventData) => {\n            receivedEvents.push(eventData);\n\n            // resolve the operation's promise after the requested\n            // number of events are received.\n            if (receivedEvents.length === maxMessageCount) {\n              logger.info(\n                \"[%s] Batching Receiver '%s', %d messages received within %d seconds.\",\n                this._context.connectionId,\n                this.name,\n                receivedEvents.length,\n                maxWaitTimeInSeconds\n              );\n              cleanUpBeforeReturn();\n              resolve(receivedEvents);\n            }\n          },\n          (err) => {\n            // restore events to the front of the internal queue.\n            while (receivedEvents.length) {\n              this._internalQueue.unshift(receivedEvents.pop()!);\n            }\n            cleanUpBeforeReturn();\n            if (err.name === \"AbortError\") {\n              rejectOnAbort();\n            } else {\n              reject(err);\n            }\n          },\n          maxMessageCount - receivedEvents.length,\n          false,\n          abortSignal,\n          onAbort\n        );\n\n        const addTimeout = (): void => {\n          const msg = \"[%s] Setting the wait timer for %d seconds for receiver '%s'.\";\n          logger.verbose(msg, this._context.connectionId, maxWaitTimeInSeconds, this.name);\n\n          // resolve the operation's promise after the requested\n          // max number of seconds have passed.\n          timer = setTimeout(() => {\n            logger.info(\n              \"[%s] Batching Receiver '%s', %d messages received when max wait time in seconds %d is over.\",\n              this._context.connectionId,\n              this.name,\n              receivedEvents.length,\n              maxWaitTimeInSeconds\n            );\n            cleanUpBeforeReturn();\n            resolve(receivedEvents);\n          }, maxWaitTimeInSeconds * 1000);\n        };\n\n        addTimeout();\n        if (abortSignal && !abortSignal.aborted) {\n          abortSignal.addEventListener(\"abort\", onAbort);\n        }\n      });\n    };\n\n    const retryOptions = this.options.retryOptions || {};\n\n    const config: RetryConfig<ReceivedEventData[]> = Object.defineProperties(\n      {\n        operation: retrieveEvents,\n        operationType: RetryOperationType.receiveMessage,\n        abortSignal: abortSignal,\n        retryOptions: retryOptions\n      },\n      {\n        connectionId: {\n          enumerable: true,\n          get: () => {\n            return this._context.connectionId;\n          }\n        },\n        connectionHost: {\n          enumerable: true,\n          get: () => {\n            return this._context.config.host;\n          }\n        }\n      }\n    );\n    return retry<ReceivedEventData[]>(config);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { extractSpanContextFromTraceParentHeader, getTraceParentHeader } from \"@azure/core-tracing\";\nimport { Span, SpanContext } from \"@azure/core-tracing\";\nimport { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { EventData, isAmqpAnnotatedMessage } from \"../eventData\";\n\n/**\n * @hidden\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * Populates the `EventData` with `SpanContext` info to support trace propagation.\n * Creates and returns a copy of the passed in `EventData` unless the `EventData`\n * has already been instrumented.\n * @param eventData - The `EventData` or `AmqpAnnotatedMessage` to instrument.\n * @param span - The `Span` containing the context to propagate tracing information.\n */\nexport function instrumentEventData(\n  eventData: EventData | AmqpAnnotatedMessage,\n  span: Span\n): EventData {\n  const props = isAmqpAnnotatedMessage(eventData)\n    ? eventData.applicationProperties\n    : eventData.properties;\n\n  if (props && props[TRACEPARENT_PROPERTY]) {\n    return eventData;\n  }\n\n  const copiedProps = { ...props };\n\n  // create a copy so the original isn't modified\n  if (isAmqpAnnotatedMessage(eventData)) {\n    eventData = { ...eventData, applicationProperties: copiedProps };\n  } else {\n    eventData = { ...eventData, properties: copiedProps };\n  }\n\n  const traceParent = getTraceParentHeader(span.spanContext());\n  if (traceParent) {\n    copiedProps[TRACEPARENT_PROPERTY] = traceParent;\n  }\n\n  return eventData;\n}\n\n/**\n * Extracts the `SpanContext` from an `EventData` if the context exists.\n * @param eventData - An individual `EventData` object.\n * @internal\n */\nexport function extractSpanContextFromEventData(eventData: EventData): SpanContext | undefined {\n  if (!eventData.properties || !eventData.properties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = eventData.properties[TRACEPARENT_PROPERTY];\n  return extractSpanContextFromTraceParentHeader(diagnosticId);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { CloseReason } from \"./models/public\";\nimport { EventPosition } from \"./eventPosition\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { EventHubReceiver } from \"./eventHubReceiver\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { MessagingError } from \"@azure/core-amqp\";\nimport { OperationOptions } from \"./util/operationOptions\";\nimport { SpanStatusCode, Link, Span, SpanKind } from \"@azure/core-tracing\";\nimport { extractSpanContextFromEventData } from \"./diagnostics/instrumentEventData\";\nimport { ReceivedEventData } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { createEventHubSpan } from \"./diagnostics/tracing\";\nimport { EventHubConnectionConfig } from \"./eventhubConnectionConfig\";\n\n/**\n * @internal\n */\nexport class PartitionPump {\n  private _partitionProcessor: PartitionProcessor;\n  private _processorOptions: CommonEventProcessorOptions;\n  private _receiver: EventHubReceiver | undefined;\n  private _isReceiving: boolean = false;\n  private _isStopped: boolean = false;\n  private _abortController: AbortController;\n  constructor(\n    private _context: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    private readonly _startPosition: EventPosition,\n    options: CommonEventProcessorOptions\n  ) {\n    this._partitionProcessor = partitionProcessor;\n    this._processorOptions = options;\n    this._abortController = new AbortController();\n  }\n\n  public get isReceiving(): boolean {\n    return this._isReceiving;\n  }\n\n  async start(): Promise<void> {\n    this._isReceiving = true;\n    try {\n      await this._partitionProcessor.initialize();\n    } catch (err) {\n      // swallow the error from the user-defined code\n      this._partitionProcessor.processError(err);\n    }\n\n    // this is intentionally not await'd - the _receiveEvents loop will continue to\n    // execute and can be stopped by calling .stop()\n    this._receiveEvents(this._partitionProcessor.partitionId);\n    logger.info(\n      `Successfully started the receiver for partition \"${this._partitionProcessor.partitionId}\".`\n    );\n  }\n\n  /**\n   * Creates a new `EventHubReceiver` and replaces any existing receiver.\n   * @param partitionId - The partition the receiver should read messages from.\n   * @param lastSeenSequenceNumber - The sequence number to begin receiving messages from (exclusive).\n   * If `-1`, then the PartitionPump's startPosition will be used instead.\n   */\n  private _setOrReplaceReceiver(\n    partitionId: string,\n    lastSeenSequenceNumber: number\n  ): EventHubReceiver {\n    // Determine what the new EventPosition should be.\n    // If this PartitionPump has received events, we'll start from the last\n    // seen sequenceNumber (exclusive).\n    // Otherwise, use the `_startPosition`.\n    const currentEventPosition: EventPosition =\n      lastSeenSequenceNumber >= 0\n        ? {\n            sequenceNumber: lastSeenSequenceNumber,\n            isInclusive: false\n          }\n        : this._startPosition;\n\n    // Set or replace the PartitionPump's receiver.\n    this._receiver = new EventHubReceiver(\n      this._context,\n      this._partitionProcessor.consumerGroup,\n      partitionId,\n      currentEventPosition,\n      {\n        ownerLevel: this._processorOptions.ownerLevel,\n        trackLastEnqueuedEventProperties: this._processorOptions.trackLastEnqueuedEventProperties,\n        retryOptions: this._processorOptions.retryOptions,\n        skipParsingBodyAsJson: this._processorOptions.skipParsingBodyAsJson\n      }\n    );\n\n    return this._receiver;\n  }\n\n  private async _receiveEvents(partitionId: string): Promise<void> {\n    let lastSeenSequenceNumber = -1;\n    let receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n\n    while (this._isReceiving) {\n      try {\n        // Check if the receiver was closed so we can recreate it.\n        if (receiver.isClosed) {\n          receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n        }\n\n        const receivedEvents = await receiver.receiveBatch(\n          this._processorOptions.maxBatchSize,\n          this._processorOptions.maxWaitTimeInSeconds,\n          this._abortController.signal\n        );\n\n        if (\n          this._processorOptions.trackLastEnqueuedEventProperties &&\n          receiver.lastEnqueuedEventProperties\n        ) {\n          this._partitionProcessor.lastEnqueuedEventProperties =\n            receiver.lastEnqueuedEventProperties;\n        }\n        // avoid calling user's processEvents handler if the pump was stopped while receiving events\n        if (!this._isReceiving) {\n          return;\n        }\n\n        if (receivedEvents.length) {\n          lastSeenSequenceNumber = receivedEvents[receivedEvents.length - 1].sequenceNumber;\n        }\n\n        const span = createProcessingSpan(\n          receivedEvents,\n          this._context.config,\n          this._processorOptions\n        );\n\n        await trace(() => this._partitionProcessor.processEvents(receivedEvents), span);\n      } catch (err) {\n        // check if this pump is still receiving\n        // it may not be if the EventProcessor was stopped during processEvents\n        if (!this._isReceiving) {\n          // no longer receiving, so close was called from somewhere else\n          return;\n        }\n\n        logger.warning(\n          `An error was thrown while receiving or processing events on partition \"${this._partitionProcessor.partitionId}\"`\n        );\n        logErrorStackTrace(err);\n        // forward error to user's processError and swallow errors they may throw\n        try {\n          await this._partitionProcessor.processError(err);\n        } catch (errorFromUser) {\n          // Using verbose over warning because this error is swallowed.\n          logger.verbose(\"An error was thrown by user's processError method: \", errorFromUser);\n        }\n\n        // close the partition processor if a non-retryable error was encountered\n        if (typeof err !== \"object\" || !(err as MessagingError).retryable) {\n          try {\n            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel\n            // started consuming the partition), update the closeReason\n            if (err.code === \"ReceiverDisconnectedError\") {\n              return await this.stop(CloseReason.OwnershipLost);\n            }\n            // this will close the pump and will break us out of the while loop\n            return await this.stop(CloseReason.Shutdown);\n          } catch (errorFromStop) {\n            // Using verbose over warning because this error is swallowed.\n            logger.verbose(\n              `An error occurred while closing the receiver with reason ${CloseReason.Shutdown}: `,\n              errorFromStop\n            );\n          }\n        }\n      }\n    }\n  }\n\n  async stop(reason: CloseReason): Promise<void> {\n    if (this._isStopped) {\n      return;\n    }\n    this._isStopped = true;\n    this._isReceiving = false;\n    try {\n      // Trigger the cancellation before closing the receiver,\n      // otherwise the receiver will remove the listener on the abortSignal\n      // before it has a chance to be emitted.\n      this._abortController.abort();\n\n      if (this._receiver) {\n        await this._receiver.close();\n      }\n      await this._partitionProcessor.close(reason);\n    } catch (err) {\n      logger.warning(`An error occurred while closing the receiver: ${err?.name}: ${err?.message}`);\n      logErrorStackTrace(err);\n      this._partitionProcessor.processError(err);\n      throw err;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function createProcessingSpan(\n  receivedEvents: ReceivedEventData[],\n  eventHubProperties: Pick<EventHubConnectionConfig, \"entityPath\" | \"host\">,\n  options?: OperationOptions\n): Span {\n  const links: Link[] = [];\n\n  for (const receivedEvent of receivedEvents) {\n    const spanContext = extractSpanContextFromEventData(receivedEvent);\n\n    if (spanContext == null) {\n      continue;\n    }\n\n    links.push({\n      context: spanContext,\n      attributes: {\n        enqueuedTime: receivedEvent.enqueuedTimeUtc.getTime()\n      }\n    });\n  }\n\n  const { span } = createEventHubSpan(\"process\", options, eventHubProperties, {\n    kind: SpanKind.CONSUMER,\n    links\n  });\n\n  return span;\n}\n\n/**\n * @internal\n */\nexport async function trace(fn: () => Promise<void>, span: Span): Promise<void> {\n  try {\n    await fn();\n    span.setStatus({ code: SpanStatusCode.OK });\n  } catch (err) {\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: err.message\n    });\n    throw err;\n  } finally {\n    span.end();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { EventPosition } from \"./eventPosition\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { CloseReason } from \"./models/public\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { PartitionPump } from \"./partitionPump\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { ConnectionContext } from \"./connectionContext\";\n\n/**\n * The PumpManager handles the creation and removal of PartitionPumps.\n * It also starts a PartitionPump when it is created, and stops a\n * PartitionPump when it is removed.\n * @internal\n */\nexport interface PumpManager {\n  /**\n   * Creates and starts a PartitionPump.\n   * @param startPosition - The position in the partition to start reading from.\n   * @param eventHubClient - The EventHubClient to forward to the PartitionPump.\n   * @param partitionProcessor - The PartitionProcessor to forward to the PartitionPump.\n   * @param abortSignal - Used to cancel pump creation.\n   */\n  createPump(\n    startPosition: EventPosition,\n    connectionContext: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    abortSignal: AbortSignalLike\n  ): Promise<void>;\n\n  /**\n   * Indicates whether the pump manager is actively receiving events from a given partition.\n   * @param partitionId - The partition to check.\n   */\n  isReceivingFromPartition(partitionId: string): boolean;\n\n  /**\n   * Stops all PartitionPumps and removes them from the internal map.\n   * @param reason - The reason for removing the pump.\n   */\n  removeAllPumps(reason: CloseReason): Promise<void>;\n}\n\n/**\n * The PumpManager handles the creation and removal of PartitionPumps.\n * It also starts a PartitionPump when it is created, and stops a\n * PartitionPump when it is removed.\n * @hidden\n * @internal\n */\nexport class PumpManagerImpl implements PumpManager {\n  private readonly _eventProcessorName: string;\n  private readonly _options: CommonEventProcessorOptions;\n  private _partitionIdToPumps: {\n    [partitionId: string]: PartitionPump | undefined;\n  } = {};\n\n  /**\n   * @hidden\n   */\n  constructor(eventProcessorName: string, eventProcessorOptions: CommonEventProcessorOptions) {\n    this._eventProcessorName = eventProcessorName;\n    this._options = eventProcessorOptions;\n  }\n\n  /**\n   * Returns a list of partitionIds that are actively receiving messages.\n   * @hidden\n   */\n  public receivingFromPartitions(): string[] {\n    return Object.keys(this._partitionIdToPumps).filter((id) => {\n      const pump = this._partitionIdToPumps[id];\n      return Boolean(pump && pump.isReceiving);\n    });\n  }\n\n  /**\n   * Indicates whether the pump manager is actively receiving events from a given partition.\n   * @internal\n   */\n  public isReceivingFromPartition(partitionId: string): boolean {\n    const pump = this._partitionIdToPumps[partitionId];\n    return Boolean(pump && pump.isReceiving);\n  }\n\n  /**\n   * Creates and starts a PartitionPump.\n   * @param startPosition - The position in the partition to start reading from.\n   * @param connectionContext - The ConnectionContext to forward to the PartitionPump.\n   * @param partitionProcessor - The PartitionProcessor to forward to the PartitionPump.\n   * @hidden\n   */\n  public async createPump(\n    startPosition: EventPosition,\n    connectionContext: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    const partitionId = partitionProcessor.partitionId;\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `${this._eventProcessorName}] The subscription was closed before creating the pump for partition ${partitionId}.`\n      );\n      return;\n    }\n    // attempt to get an existing pump\n    const existingPump = this._partitionIdToPumps[partitionId];\n    if (existingPump) {\n      if (existingPump.isReceiving) {\n        logger.verbose(\n          `[${this._eventProcessorName}] [${partitionId}] The existing pump is running.`\n        );\n        return;\n      }\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] The existing pump is not running.`\n      );\n      await this.removePump(partitionId, CloseReason.OwnershipLost);\n    }\n\n    logger.verbose(`[${this._eventProcessorName}] [${partitionId}] Creating a new pump.`);\n\n    const pump = new PartitionPump(\n      connectionContext,\n      partitionProcessor,\n      startPosition,\n      this._options\n    );\n\n    try {\n      // Set the pump before starting it in case the user\n      // closes the subscription while `start()` is in progress.\n      this._partitionIdToPumps[partitionId] = pump;\n      await pump.start();\n    } catch (err) {\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] An error occured while adding/updating a pump: ${err}`\n      );\n      logErrorStackTrace(err);\n    }\n  }\n\n  /**\n   * Stop a PartitionPump and removes it from the internal map.\n   * @param partitionId - The partitionId to remove the associated PartitionPump from.\n   * @param reason - The reason for removing the pump.\n   * @hidden\n   */\n  public async removePump(partitionId: string, reason: CloseReason): Promise<void> {\n    try {\n      const pump = this._partitionIdToPumps[partitionId];\n      if (pump) {\n        delete this._partitionIdToPumps[partitionId];\n        logger.verbose(`[${this._eventProcessorName}] [${partitionId}] Stopping the pump.`);\n        await pump.stop(reason);\n      } else {\n        logger.verbose(\n          `[${this._eventProcessorName}] [${partitionId}] No pump was found to remove.`\n        );\n      }\n    } catch (err) {\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] An error occured while removing a pump: ${err}`\n      );\n      logErrorStackTrace(err);\n    }\n  }\n\n  /**\n   * Stops all PartitionPumps and removes them from the internal map.\n   * @param reason - The reason for removing the pump.\n   * @hidden\n   */\n  public async removeAllPumps(reason: CloseReason): Promise<void> {\n    const partitionIds = Object.keys(this._partitionIdToPumps);\n\n    logger.verbose(`[${this._eventProcessorName}] Removing all pumps due to reason ${reason}.`);\n\n    const tasks: PromiseLike<void>[] = [];\n    for (const partitionId of partitionIds) {\n      const pump = this._partitionIdToPumps[partitionId];\n      if (pump) {\n        tasks.push(pump.stop(reason));\n      }\n    }\n\n    try {\n      await Promise.all(tasks);\n    } catch (err) {\n      logger.verbose(\n        `[${this._eventProcessorName}] An error occured while removing all pumps: ${err}`\n      );\n      logErrorStackTrace(err);\n    } finally {\n      this._partitionIdToPumps = {};\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CheckpointStore } from \"./eventProcessor\";\nimport { CloseReason } from \"./models/public\";\nimport { ReceivedEventData } from \"./eventData\";\nimport { LastEnqueuedEventProperties } from \"./eventHubReceiver\";\nimport {\n  BasicPartitionProperties,\n  PartitionContext,\n  SubscriptionEventHandlers\n} from \"./eventHubConsumerClientModels\";\nimport { logger } from \"./log\";\n\n/**\n * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n * partition of a consumer group in an Event Hub instance.\n *\n * When the `updateCheckpoint()` method on the `PartitionProcessor` class is called by the user, a\n * `Checkpoint` is created internally. It is then stored in the storage solution implemented by the\n * `CheckpointManager` chosen by the user when creating an `EventProcessor`.\n *\n * Users are never expected to interact with `Checkpoint` directly. This interface exists to support the\n * internal workings of `EventProcessor` and `CheckpointManager`.\n **/\nexport interface Checkpoint {\n  /**\n   * The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The event hub name\n   */\n  eventHubName: string;\n  /**\n   * The consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * The identifier of the Event Hub partition\n   */\n  partitionId: string;\n  /**\n   * The sequence number of the event\n   */\n  sequenceNumber: number;\n  /**\n   * The offset of the event.\n   */\n  offset: number;\n}\n\n/**\n * The `PartitionProcessor` is responsible for processing events received from Event Hubs when using `EventProcessor`\n *\n * The EventProcessor creates a new instance of the PartitionProcessor for each partition of the event hub it starts processing. When you extend the `PartitionProcessor` in order to customize it as you see fit,\n * - Override the `processEvents()` method to add the code to process the received events. This is also a good place to update the checkpoints using the `updateCheckpoint()` method\n * - Optionally override the `processError()` method to handle any error that might have occurred when processing the events.\n * - Optionally override the `initialize()` method to implement any set up related tasks you would want to carry out before starting to receive events from the partition\n * - Optionally override the `close()` method to implement any tear down or clean up tasks you would want to carry out.\n * @internal\n */\nexport class PartitionProcessor implements PartitionContext {\n  private _lastEnqueuedEventProperties?: LastEnqueuedEventProperties;\n\n  constructor(\n    private _eventHandlers: SubscriptionEventHandlers,\n    private _checkpointStore: CheckpointStore,\n    private _context: BasicPartitionProperties & {\n      eventProcessorId: string;\n    }\n  ) {}\n\n  /**\n   * Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true\n   * when creating an instance of EventProcessor\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this._lastEnqueuedEventProperties!;\n  }\n\n  /**\n   * Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true\n   * when creating an instance of EventProcessor\n   */\n  public set lastEnqueuedEventProperties(properties: LastEnqueuedEventProperties) {\n    this._lastEnqueuedEventProperties = properties;\n  }\n\n  /**\n   * The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get fullyQualifiedNamespace(): string {\n    return this._context.fullyQualifiedNamespace;\n  }\n\n  /**\n   * The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get consumerGroup(): string {\n    return this._context.consumerGroup!;\n  }\n\n  /**\n   * The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get eventHubName(): string {\n    return this._context.eventHubName;\n  }\n\n  /**\n   * The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get partitionId(): string {\n    return this._context.partitionId;\n  }\n\n  /**\n   * The unique identifier of the `EventProcessor` that has spawned the current instance of `PartitionProcessor`. This is set by the `EventProcessor`\n   */\n  public get eventProcessorId(): string {\n    return this._context.eventProcessorId;\n  }\n\n  /**\n   * This method is called when the `EventProcessor` takes ownership of a new partition and before any\n   * events are received.\n   */\n  async initialize(): Promise<void> {\n    if (this._eventHandlers.processInitialize) {\n      await this._eventHandlers.processInitialize(this);\n    }\n  }\n\n  /**\n   * This method is called before the partition processor is closed by the EventProcessor.\n   *\n   * @param reason - The reason for closing this partition processor.\n   */\n  async close(reason: CloseReason): Promise<void> {\n    if (this._eventHandlers.processClose) {\n      await this._eventHandlers.processClose(reason, this);\n    }\n  }\n\n  /**\n   * This method is called when new events are received.\n   *\n   * This is also a good place to update checkpoints as appropriate.\n   *\n   * @param event - The received events to be processed.\n   */\n  async processEvents(events: ReceivedEventData[]): Promise<void> {\n    await this._eventHandlers.processEvents(events, this);\n  }\n\n  /**\n   * This method is called when an error occurs while receiving events from Event Hubs.\n   *\n   * @param error - The error to be processed.\n   */\n  async processError(error: Error): Promise<void> {\n    if (this._eventHandlers.processError) {\n      try {\n        await this._eventHandlers.processError(error, this);\n      } catch (err) {\n        logger.verbose(`Error thrown from user's processError handler : ${err}`);\n      }\n    }\n  }\n\n  /**\n   * Updates the checkpoint using the event data.\n   *\n   * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n   * partition of a consumer group in an Event Hub instance.\n   *\n   * @param eventData - The event that you want to update the checkpoint with.\n   */\n  public async updateCheckpoint(eventData: ReceivedEventData): Promise<void> {\n    const checkpoint: Checkpoint = {\n      fullyQualifiedNamespace: this._context.fullyQualifiedNamespace,\n      eventHubName: this._context.eventHubName,\n      consumerGroup: this._context.consumerGroup,\n      partitionId: this._context.partitionId,\n      sequenceNumber: eventData.sequenceNumber,\n      offset: eventData.offset\n    };\n\n    await this._checkpointStore!.updateCheckpoint(checkpoint);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay } from \"@azure/core-amqp\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\n\n/**\n * @param delayInMs - The number of milliseconds to be delayed.\n * @param abortSignal - The abortSignal associated with the containing operation.\n * @internal\n */\nexport async function delayWithoutThrow(\n  delayInMs: number,\n  abortSignal?: AbortSignalLike\n): Promise<void> {\n  try {\n    await delay(delayInMs, abortSignal);\n  } catch {\n    /* no-op to swallow AbortError */\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport { PumpManager, PumpManagerImpl } from \"./pumpManager\";\nimport { AbortController, AbortSignalLike, AbortError } from \"@azure/abort-controller\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { Checkpoint, PartitionProcessor } from \"./partitionProcessor\";\nimport { SubscriptionEventHandlers } from \"./eventHubConsumerClientModels\";\nimport { EventPosition, isEventPosition, latestEventPosition } from \"./eventPosition\";\nimport { delayWithoutThrow } from \"./util/delayWithoutThrow\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { CloseReason } from \"./models/public\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LoadBalancingStrategy } from \"./loadBalancerStrategies/loadBalancingStrategy\";\nimport { OperationOptions } from \"./util/operationOptions\";\n\n/**\n * An interface representing the details on which instance of a `EventProcessor` owns processing\n * of a given partition from a consumer group of an Event Hub instance.\n *\n * **Note**: This is used internally by the `EventProcessor` and user never has to create it directly.\n */\nexport interface PartitionOwnership {\n  /**\n   * The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The event hub name\n   */\n  eventHubName: string;\n  /**\n   * The consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * The identifier of the Event Hub partition.\n   */\n  partitionId: string;\n  /**\n   * The unique identifier of the event processor.\n   */\n  ownerId: string;\n  /**\n   * The last modified time.\n   */\n  lastModifiedTimeInMs?: number;\n  /**\n   * The unique identifier for the operation.\n   */\n  etag?: string;\n}\n\n/**\n * A checkpoint store stores and retrieves partition ownership information and checkpoint details\n * for each partition in a given consumer group of an event hub instance.\n *\n * Users are not meant to implement an `CheckpointStore`.\n * Users are expected to choose existing implementations of this interface, instantiate it, and pass\n * it to the `EventHubConsumerClient` class constructor when instantiating a client.\n * Users are not expected to use any of the methods on a checkpoint store, these are used internally by\n * the client.\n *\n * Implementations of `CheckpointStore` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.\n */\nexport interface CheckpointStore {\n  /**\n   * Called to get the list of all existing partition ownership from the underlying data store. Could return empty\n   * results if there are is no existing ownership information.\n   *\n   * @param fullyQualifiedNamespace - The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName - The event hub name.\n   * @param consumerGroup - The consumer group name.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   * @returns A list of partition ownership details of all the partitions that have/had an owner.\n   */\n  listOwnership(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string,\n    options?: OperationOptions\n  ): Promise<PartitionOwnership[]>;\n  /**\n   * Called to claim ownership of a list of partitions. This will return the list of partitions that were owned\n   * successfully.\n   *\n   * @param partitionOwnership - The list of partition ownership this instance is claiming to own.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   * @returns A list of partitions this instance successfully claimed ownership.\n   */\n  claimOwnership(\n    partitionOwnership: PartitionOwnership[],\n    options?: OperationOptions\n  ): Promise<PartitionOwnership[]>;\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint - The checkpoint.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   */\n  updateCheckpoint(checkpoint: Checkpoint, options?: OperationOptions): Promise<void>;\n\n  /**\n   * Lists all the checkpoints in a data store for a given namespace, eventhub and consumer group.\n   *\n   * @param fullyQualifiedNamespace - The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName - The event hub name.\n   * @param consumerGroup - The consumer group name.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   * @returns A list of checkpoints for a given namespace, eventhub, and consumer group.\n   */\n  listCheckpoints(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string,\n    options?: OperationOptions\n  ): Promise<Checkpoint[]>;\n}\n\n/**\n * A set of options to pass to the constructor of `EventProcessor`.\n * You can specify\n * - `maxBatchSize`: The max size of the batch of events passed each time to user code for processing.\n * - `maxWaitTimeInSeconds`: The maximum amount of time to wait to build up the requested message count before\n * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n *\n * Example usage with default values:\n * ```ts\n * {\n *     maxBatchSize: 1,\n *     maxWaitTimeInSeconds: 60,\n * }\n * ```\n * @internal\n */\nexport interface FullEventProcessorOptions extends CommonEventProcessorOptions {\n  /**\n   * An optional pump manager to use, rather than instantiating one internally\n   * @internal\n   */\n  pumpManager?: PumpManager;\n  /**\n   * The amount of time between load balancing attempts.\n   */\n  loopIntervalInMs: number;\n  /**\n   * A specific partition to target.\n   */\n  processingTarget?: string;\n}\n\n/**\n * Event Processor based applications consist of one or more instances of EventProcessor which have been\n * configured to consume events from the same Event Hub and consumer group. They balance the\n * workload across different instances by distributing the partitions to be processed among themselves.\n * They also allow the user to track progress when events are processed using checkpoints.\n *\n * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n * partition of a consumer group in an Event Hub instance.\n *\n * You need the below to create an instance of `EventProcessor`\n * - The name of the consumer group from which you want to process events\n * - An instance of `EventHubClient` class that was created for the Event Hub instance.\n * - A user implemented class that extends the `PartitionProcessor` class. To get started, you can use the\n * base class `PartitionProcessor` which simply logs the incoming events. To provide your code to process incoming\n * events, extend this class and override the `processEvents()` method. For example:\n * ```js\n * class SamplePartitionProcessor extends PartitionProcessor {\n *     async processEvents(events) {\n *        // user code to process events here\n *        // Information on the partition being processed is available as properties on the `SamplePartitionProcessor` class\n *        // use `this.updateCheckpoint()` method to update checkpoints as needed\n *     }\n * }\n * ```\n * - An instance of `CheckpointStore`. See &commat;azure/eventhubs-checkpointstore-blob for an implementation.\n * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.\n * Implementations of `CheckpointStore` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.\n *\n * @internal\n */\nexport class EventProcessor {\n  private _processorOptions: FullEventProcessorOptions;\n  private _pumpManager: PumpManager;\n  private _id: string;\n  private _isRunning: boolean = false;\n  private _loopTask?: PromiseLike<void>;\n  private _abortController?: AbortController;\n  /**\n   * A specific partition to target.\n   */\n  private _processingTarget?: string;\n  /**\n   * Determines which partitions to claim as part of load balancing.\n   */\n  private _loadBalancingStrategy: LoadBalancingStrategy;\n  /**\n   * The amount of time between load balancing attempts.\n   */\n  private _loopIntervalInMs: number;\n  private _eventHubName: string;\n  private _fullyQualifiedNamespace: string;\n\n  /**\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param eventHubClient - An instance of `EventHubClient` that was created for the Event Hub instance.\n   * @param PartitionProcessorClass - A user-provided class that extends the `PartitionProcessor` class.\n   * This class will be responsible for processing and checkpointing events.\n   * @param checkpointStore - An instance of `CheckpointStore`. See &commat;azure/eventhubs-checkpointstore-blob for an implementation.\n   * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.\n   * @param options - A set of options to configure the Event Processor\n   * - `maxBatchSize`         : The max size of the batch of events passed each time to user code for processing.\n   * - `maxWaitTimeInSeconds` : The maximum amount of time to wait to build up the requested message count before\n   * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n   */\n  constructor(\n    private _consumerGroup: string,\n    private _context: ConnectionContext,\n    private _subscriptionEventHandlers: SubscriptionEventHandlers,\n    private _checkpointStore: CheckpointStore,\n    options: FullEventProcessorOptions\n  ) {\n    if (options.ownerId) {\n      this._id = options.ownerId;\n      logger.verbose(`Starting event processor with ID ${this._id}`);\n    } else {\n      this._id = uuid();\n      logger.verbose(`Starting event processor with autogenerated ID ${this._id}`);\n    }\n\n    this._eventHubName = this._context.config.entityPath;\n    this._fullyQualifiedNamespace = this._context.config.host;\n    this._processorOptions = options;\n    this._pumpManager =\n      options.pumpManager || new PumpManagerImpl(this._id, this._processorOptions);\n    this._processingTarget = options.processingTarget;\n    this._loopIntervalInMs = options.loopIntervalInMs;\n    this._loadBalancingStrategy = options.loadBalancingStrategy;\n  }\n\n  /**\n   * The unique identifier for the EventProcessor.\n   */\n  get id(): string {\n    return this._id;\n  }\n\n  private _createPartitionOwnershipRequest(\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIdToClaim: string\n  ): PartitionOwnership {\n    const previousPartitionOwnership = partitionOwnershipMap.get(partitionIdToClaim);\n    const partitionOwnership: PartitionOwnership = {\n      ownerId: this._id,\n      partitionId: partitionIdToClaim,\n      fullyQualifiedNamespace: this._fullyQualifiedNamespace,\n      consumerGroup: this._consumerGroup,\n      eventHubName: this._eventHubName,\n      etag: previousPartitionOwnership ? previousPartitionOwnership.etag : undefined\n    };\n\n    return partitionOwnership;\n  }\n\n  /*\n   * Claim ownership of the given partition if it's available\n   */\n  private async _claimOwnership(\n    ownershipRequest: PartitionOwnership,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `[${this._id}] Subscription was closed before claiming ownership of ${ownershipRequest.partitionId}.`\n      );\n      return;\n    }\n    logger.info(\n      `[${this._id}] Attempting to claim ownership of partition ${ownershipRequest.partitionId}.`\n    );\n    try {\n      const claimedOwnerships = await this._checkpointStore.claimOwnership([ownershipRequest]);\n\n      // can happen if the partition was claimed out from underneath us - we shouldn't\n      // attempt to spin up a processor.\n      if (!claimedOwnerships.length) {\n        return;\n      }\n\n      logger.info(\n        `[${this._id}] Successfully claimed ownership of partition ${ownershipRequest.partitionId}.`\n      );\n\n      await this._startPump(ownershipRequest.partitionId, abortSignal);\n    } catch (err) {\n      logger.warning(\n        `[${this.id}] Failed to claim ownership of partition ${ownershipRequest.partitionId}`\n      );\n      logErrorStackTrace(err);\n      await this._handleSubscriptionError(err);\n    }\n  }\n\n  private async _startPump(partitionId: string, abortSignal: AbortSignalLike): Promise<void> {\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `[${this._id}] The subscription was closed before starting to read from ${partitionId}.`\n      );\n      return;\n    }\n\n    if (this._pumpManager.isReceivingFromPartition(partitionId)) {\n      logger.verbose(\n        `[${this._id}] There is already an active partitionPump for partition \"${partitionId}\", skipping pump creation.`\n      );\n      return;\n    }\n\n    logger.verbose(\n      `[${this._id}] [${partitionId}] Calling user-provided PartitionProcessorFactory.`\n    );\n\n    const partitionProcessor = new PartitionProcessor(\n      this._subscriptionEventHandlers,\n      this._checkpointStore,\n      {\n        fullyQualifiedNamespace: this._fullyQualifiedNamespace,\n        eventHubName: this._eventHubName,\n        consumerGroup: this._consumerGroup,\n        partitionId: partitionId,\n        eventProcessorId: this.id\n      }\n    );\n\n    const eventPosition = await this._getStartingPosition(partitionId);\n    await this._pumpManager.createPump(\n      eventPosition,\n      this._context,\n      partitionProcessor,\n      abortSignal\n    );\n\n    logger.verbose(`[${this._id}] PartitionPump created successfully.`);\n  }\n\n  private async _getStartingPosition(partitionIdToClaim: string): Promise<EventPosition> {\n    const availableCheckpoints = await this._checkpointStore.listCheckpoints(\n      this._fullyQualifiedNamespace,\n      this._eventHubName,\n      this._consumerGroup\n    );\n\n    const validCheckpoints = availableCheckpoints.filter(\n      (chk) => chk.partitionId === partitionIdToClaim\n    );\n\n    if (validCheckpoints.length > 0) {\n      return { offset: validCheckpoints[0].offset };\n    }\n\n    logger.verbose(\n      `No checkpoint found for partition ${partitionIdToClaim}. Looking for fallback.`\n    );\n    return getStartPosition(partitionIdToClaim, this._processorOptions.startPosition);\n  }\n\n  private async _runLoopForSinglePartition(\n    partitionId: string,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    while (!abortSignal.aborted) {\n      try {\n        await this._startPump(partitionId, abortSignal);\n      } catch (err) {\n        logger.warning(\n          `[${this._id}] An error occured within the EventProcessor loop: ${err?.name}: ${err?.message}`\n        );\n        logErrorStackTrace(err);\n        await this._handleSubscriptionError(err);\n      } finally {\n        // sleep for some time after which we can attempt to create a pump again.\n        logger.verbose(\n          `[${this._id}] Pausing the EventProcessor loop for ${this._loopIntervalInMs} ms.`\n        );\n        // swallow errors from delay since it's fine for delay to exit early\n        await delayWithoutThrow(this._loopIntervalInMs, abortSignal);\n      }\n    }\n    this._isRunning = false;\n  }\n\n  /**\n   * Every loop to this method will result in this EventProcessor owning at most one new partition.\n   *\n   * The load is considered balanced when no active EventProcessor owns 2 partitions more than any other active\n   * EventProcessor. Given that each invocation to this method results in ownership claim of at most one partition,\n   * this algorithm converges gradually towards a steady state.\n   *\n   * When a new partition is claimed, this method is also responsible for starting a partition pump that creates an\n   * EventHubConsumer for processing events from that partition.\n   */\n  private async _runLoopWithLoadBalancing(\n    loadBalancingStrategy: LoadBalancingStrategy,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    let cancelLoopResolver;\n    // This provides a mechanism for exiting the loop early\n    // if the subscription has had `close` called.\n    const cancelLoopPromise = new Promise<void>((resolve) => {\n      cancelLoopResolver = resolve;\n      if (abortSignal.aborted) {\n        resolve();\n        return;\n      }\n\n      abortSignal.addEventListener(\"abort\", resolve);\n    });\n\n    // Periodically check if any partitions need to be claimed and claim them.\n    while (!abortSignal.aborted) {\n      const iterationStartTimeInMs = Date.now();\n      try {\n        const { partitionIds } = await this._context.managementSession!.getEventHubProperties({\n          abortSignal: abortSignal\n        });\n        await this._performLoadBalancing(loadBalancingStrategy, partitionIds, abortSignal);\n      } catch (err) {\n        logger.warning(\n          `[${this._id}] An error occured within the EventProcessor loop: ${err?.name}: ${err?.message}`\n        );\n        logErrorStackTrace(err);\n        // Protect against the scenario where the user awaits on subscription.close() from inside processError.\n        await Promise.race([this._handleSubscriptionError(err), cancelLoopPromise]);\n      } finally {\n        // Sleep for some time, then continue the loop.\n        const iterationDeltaInMs = Date.now() - iterationStartTimeInMs;\n        const delayDurationInMs = Math.max(this._loopIntervalInMs - iterationDeltaInMs, 0);\n        logger.verbose(\n          `[${this._id}] Pausing the EventProcessor loop for ${delayDurationInMs} ms.`\n        );\n        // Swallow the error since it's fine to exit early from the delay.\n        await delayWithoutThrow(delayDurationInMs, abortSignal);\n      }\n    }\n\n    if (cancelLoopResolver) {\n      abortSignal.removeEventListener(\"abort\", cancelLoopResolver);\n    }\n    this._isRunning = false;\n  }\n\n  private async _performLoadBalancing(\n    loadBalancingStrategy: LoadBalancingStrategy,\n    partitionIds: string[],\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    if (abortSignal.aborted) throw new AbortError(\"The operation was aborted.\");\n\n    // Retrieve current partition ownership details from the datastore.\n    const partitionOwnership = await this._checkpointStore.listOwnership(\n      this._fullyQualifiedNamespace,\n      this._eventHubName,\n      this._consumerGroup\n    );\n\n    if (abortSignal.aborted) throw new AbortError(\"The operation was aborted.\");\n\n    const partitionOwnershipMap = new Map<string, PartitionOwnership>();\n    const nonAbandonedPartitionOwnershipMap = new Map<string, PartitionOwnership>();\n    const partitionsToRenew: string[] = [];\n\n    // Separate abandoned ownerships from claimed ownerships.\n    // We only want to pass active partition ownerships to the\n    // load balancer, but we need to hold onto the abandoned\n    // partition ownerships because we need the etag to claim them.\n    for (const ownership of partitionOwnership) {\n      partitionOwnershipMap.set(ownership.partitionId, ownership);\n      if (!isAbandoned(ownership)) {\n        nonAbandonedPartitionOwnershipMap.set(ownership.partitionId, ownership);\n      }\n      if (\n        ownership.ownerId === this._id &&\n        this._pumpManager.isReceivingFromPartition(ownership.partitionId)\n      ) {\n        partitionsToRenew.push(ownership.partitionId);\n      }\n    }\n\n    // Pass the list of all the partition ids and the collection of claimed partition ownerships\n    // to the load balance strategy.\n    // The load balancing strategy only needs to know the full list of partitions,\n    // and which of those are currently claimed.\n    // Since abandoned partitions are no longer claimed, we exclude them.\n    const partitionsToClaim = loadBalancingStrategy.getPartitionsToCliam(\n      this._id,\n      nonAbandonedPartitionOwnershipMap,\n      partitionIds\n    );\n    partitionsToClaim.push(...partitionsToRenew);\n\n    const uniquePartitionsToClaim = new Set(partitionsToClaim);\n    for (const partitionToClaim of uniquePartitionsToClaim) {\n      const partitionOwnershipRequest = this._createPartitionOwnershipRequest(\n        partitionOwnershipMap,\n        partitionToClaim\n      );\n\n      await this._claimOwnership(partitionOwnershipRequest, abortSignal);\n    }\n  }\n\n  /**\n   * This is called when there are errors that are not specific to a partition (ex: load balancing)\n   */\n  private async _handleSubscriptionError(err: Error): Promise<void> {\n    // filter out any internal \"expected\" errors\n    if (err.name === \"AbortError\") {\n      return;\n    }\n\n    if (this._subscriptionEventHandlers.processError) {\n      try {\n        await this._subscriptionEventHandlers.processError(err, {\n          fullyQualifiedNamespace: this._fullyQualifiedNamespace,\n          eventHubName: this._eventHubName,\n          consumerGroup: this._consumerGroup,\n          partitionId: \"\",\n          updateCheckpoint: async () => {\n            /* no-op */\n          }\n        });\n      } catch (errorFromUser) {\n        logger.verbose(\n          `[${this._id}] An error was thrown from the user's processError handler: ${errorFromUser}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Starts the `EventProcessor`. Based on the number of instances of `EventProcessor` that are running for the\n   * same consumer group, the partitions are distributed among these instances to process events.\n   *\n   * For each partition, the user provided `PartitionProcessor` is instantiated.\n   *\n   * Subsequent calls to start will be ignored if this event processor is already running.\n   * Calling `start()` after `stop()` is called will restart this event processor.\n   *\n   */\n  start(): void {\n    if (this._isRunning) {\n      logger.verbose(`[${this._id}] Attempted to start an already running EventProcessor.`);\n      return;\n    }\n\n    this._isRunning = true;\n    this._abortController = new AbortController();\n    logger.verbose(`[${this._id}] Starting an EventProcessor.`);\n\n    if (this._processingTarget) {\n      logger.verbose(`[${this._id}] Single partition target: ${this._processingTarget}`);\n      this._loopTask = this._runLoopForSinglePartition(\n        this._processingTarget,\n        this._abortController.signal\n      );\n    } else {\n      logger.verbose(`[${this._id}] Multiple partitions, using load balancer`);\n      this._loopTask = this._runLoopWithLoadBalancing(\n        this._loadBalancingStrategy,\n        this._abortController.signal\n      );\n    }\n  }\n\n  isRunning(): boolean {\n    return this._isRunning;\n  }\n\n  /**\n   * Stops processing events for all partitions owned by this event processor.\n   * All `PartitionProcessor` will be shutdown and any open resources will be closed.\n   *\n   * Subsequent calls to stop will be ignored if the event processor is not running.\n   *\n   */\n  async stop(): Promise<void> {\n    logger.verbose(`[${this._id}] Stopping an EventProcessor.`);\n    if (this._abortController) {\n      // cancel the event processor loop\n      this._abortController.abort();\n    }\n\n    try {\n      // remove all existing pumps\n      await this._pumpManager.removeAllPumps(CloseReason.Shutdown);\n\n      // waits for the event processor loop to complete\n      // will complete immediately if _loopTask is undefined\n      if (this._loopTask) {\n        await this._loopTask;\n      }\n    } catch (err) {\n      logger.verbose(`[${this._id}] An error occured while stopping the EventProcessor: ${err}`);\n    } finally {\n      logger.verbose(`[${this._id}] EventProcessor stopped.`);\n    }\n\n    if (this._processingTarget) {\n      logger.verbose(`[${this._id}] No partitions owned, skipping abandoning.`);\n    } else {\n      await this.abandonPartitionOwnerships();\n    }\n  }\n\n  private async abandonPartitionOwnerships(): Promise<PartitionOwnership[]> {\n    logger.verbose(`[${this._id}] Abandoning owned partitions`);\n    const allOwnerships = await this._checkpointStore.listOwnership(\n      this._fullyQualifiedNamespace,\n      this._eventHubName,\n      this._consumerGroup\n    );\n    const ourOwnerships = allOwnerships.filter((ownership) => ownership.ownerId === this._id);\n    // unclaim any partitions that we currently own\n    for (const ownership of ourOwnerships) {\n      ownership.ownerId = \"\";\n    }\n    return this._checkpointStore.claimOwnership(ourOwnerships);\n  }\n}\n\nfunction isAbandoned(ownership: PartitionOwnership): boolean {\n  return ownership.ownerId === \"\";\n}\n\nfunction getStartPosition(\n  partitionIdToClaim: string,\n  startPositions?: EventPosition | { [partitionId: string]: EventPosition }\n): EventPosition {\n  if (startPositions == null) {\n    return latestEventPosition;\n  }\n\n  if (isEventPosition(startPositions)) {\n    return startPositions;\n  }\n\n  const startPosition = (startPositions as { [partitionId: string]: EventPosition })[\n    partitionIdToClaim\n  ];\n\n  if (startPosition == null) {\n    return latestEventPosition;\n  }\n\n  return startPosition;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Used by EventHubConsumerClient to prevent accidentally spinning up multiple\n * subscriptions against the same set of partitions.\n *\n * This is needed now that EventHubConsumerClient only uses a single CheckpointStore\n * instance - otherwise users will see unpredictable results as their event processor\n * continually steals/overwrites checkpointing and ownership with itself.\n *\n * @internal\n */\nexport class PartitionGate {\n  private _partitions = new Set<string>();\n\n  /**\n   * Adds a partition, throwing an Error if there is a conflict with partitions (including \"all\")\n   * that are already added.\n   *\n   * @param partitionId - A partition ID or the constant \"all\"\n   */\n  add(partitionId: string | \"all\"): void {\n    if (\n      (partitionId === \"all\" && this._partitions.size > 0) ||\n      this._partitions.has(partitionId) ||\n      this._partitions.has(\"all\")\n    ) {\n      throw new Error(`Partition already has a subscriber.`);\n    }\n\n    this._partitions.add(partitionId);\n  }\n\n  /**\n   * Removes a partition\n   *\n   * @param partitionId - A partition ID or the constant \"all\"\n   */\n  remove(partitionId: string | \"all\"): void {\n    this._partitions.delete(partitionId);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PartitionOwnership } from \"../eventProcessor\";\nimport { LoadBalancingStrategy } from \"./loadBalancingStrategy\";\n\n/**\n * The UnbalancedLoadBalancingStrategy does no actual load balancing.\n * It is intended to be used when you want to avoid load balancing\n * and consume a set of partitions.\n * @internal\n */\nexport class UnbalancedLoadBalancingStrategy implements LoadBalancingStrategy {\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the full set of partitions in the Event Hub.\n   * @param _ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param _claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  public getPartitionsToCliam(\n    _ourOwnerId: string,\n    _claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[] {\n    return partitionIds;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PartitionOwnership } from \"../eventProcessor\";\nimport { logger } from \"../log\";\n\n/**\n * Determines which partitions to claim as part of load balancing.\n * @internal\n */\nexport interface LoadBalancingStrategy {\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the full set of partitions in the Event Hub.\n   * @param ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  getPartitionsToCliam(\n    ownerId: string,\n    claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[];\n}\n\n/**\n * Counts of the EventProcessors that currently own partitions.\n * @internal\n */\ninterface EventProcessorCounts {\n  /**\n   * The # of EventProcessors that only own the required # of\n   * partitions.\n   */\n  haveRequiredPartitions: number;\n  /**\n   * The # of EventProcessors that currently own the required #\n   * of partitions + 1 additional (ie, handling the case where\n   * the number of partitions is not evenly divisible by the # of\n   * EventProcessors).\n   */\n  haveAdditionalPartition: number;\n  /**\n   * EventProcessors which have more than the required or even required + 1\n   * number of partitions. These will eventually be downsized by other\n   * EventProcessors as they acquire their required number of partitions.\n   */\n  haveTooManyPartitions: number;\n}\n\n/**\n * This method will create a new map of partition id and PartitionOwnership containing only those partitions\n * that are actively owned.\n * All entries in the original map that haven't been modified for a duration of time greater than the allowed\n * inactivity time limit are assumed to be owned by dead event processors.\n * These will not be included in the map returned by this method.\n *\n * @param partitionOwnershipMap - The existing PartitionOwnerships mapped by partition.\n * @param expirationIntervalInMs - The length of time a PartitionOwnership claim is valid.\n * @hidden\n */\nfunction getActivePartitionOwnerships(\n  partitionOwnershipMap: Map<string, PartitionOwnership>,\n  expirationIntervalInMs: number\n): Map<string, PartitionOwnership> {\n  const activePartitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n  partitionOwnershipMap.forEach((partitionOwnership: PartitionOwnership, partitionId: string) => {\n    // If lastModifiedtimeInMs is missing, assume it is inactive.\n    if (\n      typeof partitionOwnership.lastModifiedTimeInMs === \"undefined\" ||\n      partitionOwnership.lastModifiedTimeInMs === null\n    ) {\n      return;\n    }\n\n    const timeSincePartitionClaimed = Date.now() - partitionOwnership.lastModifiedTimeInMs;\n    if (timeSincePartitionClaimed < expirationIntervalInMs && partitionOwnership.ownerId) {\n      activePartitionOwnershipMap.set(partitionId, partitionOwnership);\n    }\n  });\n\n  return activePartitionOwnershipMap;\n}\n\n/**\n * Calculates the minimum number of partitions each EventProcessor should own,\n * and the number of EventProcessors that should have an extra partition assigned.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @param partitionIds - The full list of the Event Hub's partition ids.\n * @internal\n */\nfunction calculateBalancedLoadCounts(\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>,\n  partitionIds: string[]\n): { minPartitionsPerOwner: number; requiredNumberOfOwnersWithExtraPartition: number } {\n  // Calculate the minimum number of partitions every EventProcessor should own when the load\n  // is evenly distributed.\n  const minPartitionsPerOwner = Math.floor(partitionIds.length / ownerToOwnershipMap.size);\n\n  // If the number of partitions in the Event Hub is not evenly divisible by the number of active\n  // EventProcesrrors, some EventProcessors may own 1 partition in addition to the minimum when the\n  // load is balanced.\n  // Calculate the number of EventProcessors that can own an additional partition.\n  const requiredNumberOfOwnersWithExtraPartition = partitionIds.length % ownerToOwnershipMap.size;\n\n  return {\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition\n  };\n}\n\n/**\n * Counts the EventProcessors and tallies them by type.\n *\n * To be in balance we need to make sure that each EventProcessor is only consuming\n * their fair share.\n *\n * When the partitions are divvied up we will sometimes end up with some EventProcessors\n * that will have 1 more partition than others.\n * This can happen if the number of partitions is not evenly divisible by the number of EventProcessors.\n *\n * So this function largely exists to support isLoadBalanced() and\n * shouldOwnMorePartitions(), both of which depend on knowing if our current list\n * of EventProcessors is actually in the proper state.\n *\n * @param minPartitionsPerOwner - The number of required partitions per EventProcessor.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @internal\n */\nfunction getEventProcessorCounts(\n  minPartitionsPerOwner: number,\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>\n): EventProcessorCounts {\n  const counts: EventProcessorCounts = {\n    haveRequiredPartitions: 0,\n    haveAdditionalPartition: 0,\n    haveTooManyPartitions: 0\n  };\n\n  for (const ownershipList of ownerToOwnershipMap.values()) {\n    const numberOfPartitions = ownershipList.length;\n\n    // there are basically three kinds of partition counts\n    // for a processor:\n\n    if (numberOfPartitions === minPartitionsPerOwner) {\n      // 1. Has _exactly_ the required number of partitions\n      counts.haveRequiredPartitions++;\n    } else if (numberOfPartitions === minPartitionsPerOwner + 1) {\n      // 2. Has the required number plus one extra (correct in cases)\n      // where the # of partitions is not evenly divisible by the\n      // number of processors.\n      counts.haveAdditionalPartition++;\n    } else if (numberOfPartitions > minPartitionsPerOwner + 1) {\n      // 3. has more than the possible # of partitions required\n      counts.haveTooManyPartitions++;\n    }\n  }\n\n  return counts;\n}\n\n/**\n * Validates that we are currently in a balanced state - all EventProcessors own the\n * minimum required number of partitions (and additional partitions, if the # of partitions\n * is not evenly divisible by the # of EventProcessors).\n *\n * @param requiredNumberOfOwnersWithExtraPartition - The # of EventProcessors that process an additional partition, in addition to the required minimum.\n * @param totalExpectedProcessors - The total # of EventProcessors we expect.\n * @param eventProcessorCounts - EventProcessor counts, grouped by criteria.\n * @internal\n */\nfunction isLoadBalanced(\n  requiredNumberOfOwnersWithExtraPartition: number,\n  totalExpectedEventProcessors: number,\n  { haveAdditionalPartition, haveRequiredPartitions }: EventProcessorCounts\n): boolean {\n  return (\n    haveAdditionalPartition === requiredNumberOfOwnersWithExtraPartition &&\n    haveRequiredPartitions + haveAdditionalPartition === totalExpectedEventProcessors\n  );\n}\n\n/**\n * Determines the number of new partitions to claim for this particular processor.\n *\n * @param minRequired - The minimum required number of partitions.\n * @param requiredNumberOfOwnersWithExtraPartition - The current number of processors that should have an additional partition.\n * @param numPartitionsOwnedByUs - The number of partitions we currently own.\n * @param eventProcessorCounts - Processors, grouped by criteria.\n * @internal\n */\nfunction getNumberOfPartitionsToClaim(\n  minRequiredPartitionCount: number,\n  requiredNumberOfOwnersWithExtraPartition: number,\n  numPartitionsOwnedByUs: number,\n  { haveAdditionalPartition, haveTooManyPartitions }: EventProcessorCounts\n): number {\n  let actualRequiredPartitionCount = minRequiredPartitionCount;\n\n  if (\n    requiredNumberOfOwnersWithExtraPartition > 0 &&\n    // Eventually the `haveTooManyPartitions` will decay into `haveAdditionalPartition`\n    // EventProcessors as partitions are balanced to consumers that aren't at par.\n    // We can consider them to be `haveAdditionalPartition` EventProcessors for our purposes.\n    haveAdditionalPartition + haveTooManyPartitions < requiredNumberOfOwnersWithExtraPartition\n  ) {\n    // Overall we don't have enough EventProcessors that are taking on an additional partition\n    // so we should attempt to.\n    actualRequiredPartitionCount = minRequiredPartitionCount + 1;\n  }\n  return actualRequiredPartitionCount - numPartitionsOwnedByUs;\n}\n\n/**\n * Determines which partitions can be stolen from other owners while maintaining\n * a balanced state.\n * @param numberOfPartitionsToClaim - The number of partitions the owner needs to claim to reach a balanced state.\n * @param minPartitionsPerOwner - The minimum number of partitions each owner needs for the partition load to be balanced.\n * @param requiredNumberOfOwnersWithExtraPartition - The number of owners that should have 1 extra partition.\n * @param ourOwnerId - The id of _our_ owner.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @internal\n */\nfunction findPartitionsToSteal(\n  numberOfPartitionsToClaim: number,\n  minPartitionsPerOwner: number,\n  requiredNumberOfOwnersWithExtraPartition: number,\n  ourOwnerId: string,\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>\n): string[] {\n  const partitionsToSteal: string[] = [];\n  // Create a list of PartitionOwnership lists that we can steal from.\n  const listOfPartitionOwnerships: Array<PartitionOwnership[]> = [];\n  ownerToOwnershipMap.forEach((partitionOwnerships, ownerId) => {\n    if (ownerId === ourOwnerId || partitionOwnerships.length <= minPartitionsPerOwner) return;\n    listOfPartitionOwnerships.push(partitionOwnerships);\n  });\n\n  // Sort the list in descending order based on the length of each element.\n  listOfPartitionOwnerships.sort((a, b) => {\n    if (a.length > b.length) return -1;\n    if (a.length < b.length) return 1;\n    return 0;\n  });\n\n  // Attempt to steal partitions from EventProcessors that have the most partitions 1st,\n  // then work our way down.\n  let ownersEncounteredWithExtraPartitions = 0;\n  let currentPartitionOwnershipList = listOfPartitionOwnerships.shift();\n  while (numberOfPartitionsToClaim > 0 && currentPartitionOwnershipList) {\n    let ownersExpectedPartitionCount = minPartitionsPerOwner;\n    // Determine if the current owner should be allowed to have an extra partition.\n    if (ownersEncounteredWithExtraPartitions < requiredNumberOfOwnersWithExtraPartition) {\n      ownersExpectedPartitionCount++;\n    }\n    ownersEncounteredWithExtraPartitions++;\n\n    let numberAvailableToSteal =\n      currentPartitionOwnershipList.length - ownersExpectedPartitionCount;\n    // Claim as many random partitions as possible.\n    while (Math.min(numberOfPartitionsToClaim, numberAvailableToSteal)) {\n      const indexToClaim = Math.floor(Math.random() * currentPartitionOwnershipList.length);\n      partitionsToSteal.push(currentPartitionOwnershipList.splice(indexToClaim, 1)[0].partitionId);\n      numberOfPartitionsToClaim--;\n      numberAvailableToSteal--;\n    }\n\n    // Move on to the next list of PartitionOwnership.\n    currentPartitionOwnershipList = listOfPartitionOwnerships.shift();\n  }\n\n  return partitionsToSteal;\n}\n\n/**\n * Identifies all of the partitions that can be claimed by the specified owner for\n * that owner to reach a balanced state.\n * @param OwnerId - The id we should assume is _our_ id when checking for ownership.\n * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n * @param partitionIds - Partitions to assign owners to.\n * @param expirationIntervalInMs - The length of time a partition claim is valid.\n * @returns Partition ids that may be claimed.\n * @internal\n */\nexport function listAvailablePartitions(\n  ownerId: string,\n  claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n  partitionIds: string[],\n  expirationIntervalInMs: number\n): string[] {\n  if (!partitionIds.length) {\n    return [];\n  }\n\n  // Collect only the PartitionOwnership that have been updated within the expiration interval.\n  // Any PartitionOwnership that has been updated outside the expiration interval can be claimed.\n  const activePartitionOwnershipMap = getActivePartitionOwnerships(\n    claimedPartitionOwnershipMap,\n    expirationIntervalInMs\n  );\n  logger.verbose(\n    `[${ownerId}] Number of active ownership records: ${activePartitionOwnershipMap.size}.`\n  );\n\n  if (activePartitionOwnershipMap.size === 0) {\n    // All partitions in this Event Hub are available to claim.\n    return partitionIds;\n  }\n\n  // Map ownerIds to the partitions they own so that we can determine how many each owner has.\n  const ownerToOwnershipMap = new Map<string, PartitionOwnership[]>();\n  for (const activeOwnership of activePartitionOwnershipMap.values()) {\n    const partitionOwnershipList = ownerToOwnershipMap.get(activeOwnership.ownerId) || [];\n\n    partitionOwnershipList.push(activeOwnership);\n    ownerToOwnershipMap.set(activeOwnership.ownerId, partitionOwnershipList);\n  }\n\n  // Add the current EventProcessor to the map of owners to ownerships if it doesn't exist.\n  if (!ownerToOwnershipMap.has(ownerId)) {\n    ownerToOwnershipMap.set(ownerId, []);\n  }\n\n  logger.info(`[${ownerId}] Number of active event processors: ${ownerToOwnershipMap.size}.`);\n\n  const {\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition\n  } = calculateBalancedLoadCounts(ownerToOwnershipMap, partitionIds);\n\n  logger.verbose(\n    `[${ownerId}] Expected minimum number of partitions per event processor: ${minPartitionsPerOwner},` +\n      `expected number of event processors with additional partition: ${requiredNumberOfOwnersWithExtraPartition}.`\n  );\n\n  // Get some stats representing the current state the world with regards to how balanced the\n  // partitions are across EventProcessors.\n  const eventProcessorCounts = getEventProcessorCounts(minPartitionsPerOwner, ownerToOwnershipMap);\n\n  if (\n    isLoadBalanced(\n      requiredNumberOfOwnersWithExtraPartition,\n      ownerToOwnershipMap.size,\n      eventProcessorCounts\n    )\n  ) {\n    // When the partitions are evenly distributed, no change required.\n    return [];\n  }\n\n  let numberOfPartitionsToClaim = getNumberOfPartitionsToClaim(\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition,\n    ownerToOwnershipMap.get(ownerId)!.length,\n    eventProcessorCounts\n  );\n\n  if (numberOfPartitionsToClaim <= 0) {\n    return [];\n  }\n\n  const partitionsToClaim: string[] = [];\n  const unclaimedPartitionIds = partitionIds.filter((id) => !activePartitionOwnershipMap.has(id));\n\n  // Prioritize getting unclaimed partitions first.\n  while (Math.min(numberOfPartitionsToClaim, unclaimedPartitionIds.length)) {\n    const indexToClaim = Math.floor(Math.random() * unclaimedPartitionIds.length);\n    partitionsToClaim.push(unclaimedPartitionIds.splice(indexToClaim, 1)[0]);\n    numberOfPartitionsToClaim--;\n  }\n\n  if (numberOfPartitionsToClaim === 0) {\n    return partitionsToClaim;\n  }\n\n  // Find partitions that can be stolen from other EventProcessors.\n  const partitionsToSteal = findPartitionsToSteal(\n    numberOfPartitionsToClaim,\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition,\n    ownerId,\n    ownerToOwnershipMap\n  );\n\n  return partitionsToClaim.concat(partitionsToSteal);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PartitionOwnership } from \"../eventProcessor\";\nimport { LoadBalancingStrategy, listAvailablePartitions } from \"./loadBalancingStrategy\";\n\n/**\n * @internal\n */\nexport class GreedyLoadBalancingStrategy implements LoadBalancingStrategy {\n  /**\n   * Creates an instance of GreedyLoadBalancingStrategy.\n   *\n   * @param _partitionOwnershipExpirationIntervalInMs - The length of time a partition claim is valid.\n   */\n  constructor(private readonly _partitionOwnershipExpirationIntervalInMs: number) {}\n\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the new set of partitions to add.\n   * @param ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  public getPartitionsToCliam(\n    ourOwnerId: string,\n    claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[] {\n    return listAvailablePartitions(\n      ourOwnerId,\n      claimedPartitionOwnershipMap,\n      partitionIds,\n      this._partitionOwnershipExpirationIntervalInMs\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PartitionOwnership } from \"../eventProcessor\";\nimport { LoadBalancingStrategy, listAvailablePartitions } from \"./loadBalancingStrategy\";\n\n/**\n * The BalancedLoadBalancerStrategy is meant to be used when the user\n * wants to reach a load balanced state with less partition 'thrashing'.\n *\n * Partition thrashing - where a partition changes owners - is minimized\n * by only returning a single partition to claim at a time.\n * This minimizes the number of times a partition should need to be stolen.\n * @internal\n */\nexport class BalancedLoadBalancingStrategy implements LoadBalancingStrategy {\n  /**\n   * Creates an instance of BalancedLoadBalancingStrategy.\n   *\n   * @param _partitionOwnershipExpirationIntervalInMs - The length of time a partition claim is valid.\n   */\n  constructor(private readonly _partitionOwnershipExpirationIntervalInMs: number) {}\n\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the full set of partitions in the Event Hub.\n   * @param ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  public getPartitionsToCliam(\n    ourOwnerId: string,\n    claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[] {\n    const claimablePartitions = listAvailablePartitions(\n      ourOwnerId,\n      claimedPartitionOwnershipMap,\n      partitionIds,\n      this._partitionOwnershipExpirationIntervalInMs\n    );\n\n    if (!claimablePartitions.length) {\n      return [];\n    }\n\n    const randomIndex = Math.floor(Math.random() * claimablePartitions.length);\n    return [claimablePartitions[randomIndex]];\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionContext, createConnectionContext } from \"./connectionContext\";\nimport {\n  EventHubConsumerClientOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions,\n  GetPartitionPropertiesOptions,\n  LoadBalancingOptions\n} from \"./models/public\";\nimport { InMemoryCheckpointStore } from \"./inMemoryCheckpointStore\";\nimport { CheckpointStore, EventProcessor, FullEventProcessorOptions } from \"./eventProcessor\";\nimport { Constants } from \"@azure/core-amqp\";\nimport { logger } from \"./log\";\n\nimport {\n  SubscribeOptions,\n  Subscription,\n  SubscriptionEventHandlers\n} from \"./eventHubConsumerClientModels\";\nimport { TokenCredential, NamedKeyCredential, SASCredential } from \"@azure/core-auth\";\nimport { EventHubProperties, PartitionProperties } from \"./managementClient\";\nimport { PartitionGate } from \"./impl/partitionGate\";\nimport { v4 as uuid } from \"uuid\";\nimport { validateEventPositions } from \"./eventPosition\";\nimport { LoadBalancingStrategy } from \"./loadBalancerStrategies/loadBalancingStrategy\";\nimport { UnbalancedLoadBalancingStrategy } from \"./loadBalancerStrategies/unbalancedStrategy\";\nimport { GreedyLoadBalancingStrategy } from \"./loadBalancerStrategies/greedyStrategy\";\nimport { BalancedLoadBalancingStrategy } from \"./loadBalancerStrategies/balancedStrategy\";\nimport { isCredential } from \"./util/typeGuards\";\n\nconst defaultConsumerClientOptions: Required<Pick<\n  FullEventProcessorOptions,\n  \"maxWaitTimeInSeconds\" | \"maxBatchSize\"\n>> = {\n  // to support our current \"process single event only\" workflow we'll also purposefully\n  // only request a single event at a time.\n  maxBatchSize: 1,\n  maxWaitTimeInSeconds: 60\n};\n\n/**\n * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n *\n * There are multiple ways to create an `EventHubConsumerClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.\n *\n * Optionally, you can also pass:\n * - An options bag to configure the retry policy or proxy settings.\n * - A checkpoint store that is used by the client to read checkpoints to determine the position from where it should\n * resume receiving events when your application gets restarted. The checkpoint store is also used by the client\n * to load balance multiple instances of your application.\n */\nexport class EventHubConsumerClient {\n  /**\n   * Describes the amqp connection context for the client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * The options passed by the user when creating the EventHubClient instance.\n   */\n  private _clientOptions: EventHubConsumerClientOptions;\n  private _partitionGate = new PartitionGate();\n  private _id = uuid();\n\n  /**\n   * The Subscriptions that were spawned by calling `subscribe()`.\n   * Subscriptions that have been stopped by the user will not\n   * be present in this set.\n   */\n  private _subscriptions = new Set<Subscription>();\n\n  /**\n   * The name of the default consumer group in the Event Hubs service.\n   */\n  static defaultConsumerGroupName: string = Constants.defaultConsumerGroup;\n\n  private _checkpointStore: CheckpointStore;\n  private _userChoseCheckpointStore: boolean;\n\n  /**\n   * Options for configuring load balancing.\n   */\n  private readonly _loadBalancingOptions: Required<LoadBalancingOptions>;\n\n  /**\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._context.config.entityPath;\n  }\n\n  /**\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._context.config.host;\n  }\n\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    options?: EventHubConsumerClientOptions\n  ); // #1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions\n  ); // #1.1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    options?: EventHubConsumerClientOptions\n  ); // #2\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions\n  ); // #2.1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service.\n   * See &commat;azure/identity for creating credentials that support AAD auth.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    options?: EventHubConsumerClientOptions\n  ); // #3\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service.\n   * See &commat;azure/identity for creating credentials that support AAD auth.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions\n  ); // #3.1\n  constructor(\n    private _consumerGroup: string,\n    connectionStringOrFullyQualifiedNamespace2: string,\n    checkpointStoreOrEventHubNameOrOptions3?:\n      | CheckpointStore\n      | EventHubConsumerClientOptions\n      | string,\n    checkpointStoreOrCredentialOrOptions4?:\n      | CheckpointStore\n      | EventHubConsumerClientOptions\n      | TokenCredential\n      | NamedKeyCredential\n      | SASCredential,\n    checkpointStoreOrOptions5?: CheckpointStore | EventHubConsumerClientOptions,\n    options6?: EventHubConsumerClientOptions\n  ) {\n    if (isCredential(checkpointStoreOrCredentialOrOptions4)) {\n      // #3 or 3.1\n      logger.info(\"Creating EventHubConsumerClient with TokenCredential.\");\n\n      if (isCheckpointStore(checkpointStoreOrOptions5)) {\n        // 3.1\n        this._checkpointStore = checkpointStoreOrOptions5;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions = options6 || {};\n      } else {\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions = checkpointStoreOrOptions5 || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3 as string,\n        checkpointStoreOrCredentialOrOptions4,\n        this._clientOptions\n      );\n    } else if (typeof checkpointStoreOrEventHubNameOrOptions3 === \"string\") {\n      // #2 or 2.1\n      logger.info(\"Creating EventHubConsumerClient with connection string and event hub name.\");\n\n      if (isCheckpointStore(checkpointStoreOrCredentialOrOptions4)) {\n        // 2.1\n        this._checkpointStore = checkpointStoreOrCredentialOrOptions4;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions = (checkpointStoreOrOptions5 as EventHubConsumerClientOptions) || {};\n      } else {\n        // 2\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions = checkpointStoreOrCredentialOrOptions4 || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3,\n        this._clientOptions\n      );\n    } else {\n      // #1 or 1.1\n      logger.info(\"Creating EventHubConsumerClient with connection string.\");\n\n      if (isCheckpointStore(checkpointStoreOrEventHubNameOrOptions3)) {\n        // 1.1\n        this._checkpointStore = checkpointStoreOrEventHubNameOrOptions3;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions =\n          (checkpointStoreOrCredentialOrOptions4 as EventHubConsumerClientOptions) || {};\n      } else {\n        // 1\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions =\n          (checkpointStoreOrEventHubNameOrOptions3 as EventHubConsumerClientOptions) || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        this._clientOptions\n      );\n    }\n    this._loadBalancingOptions = {\n      // default options\n      strategy: \"balanced\",\n      updateIntervalInMs: 10000,\n      partitionOwnershipExpirationIntervalInMs: 60000,\n      // options supplied by user\n      ...this._clientOptions?.loadBalancingOptions\n    };\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    // Stop all the actively running subscriptions.\n    const activeSubscriptions = Array.from(this._subscriptions);\n    await Promise.all(\n      activeSubscriptions.map((subscription) => {\n        return subscription.close();\n      })\n    );\n    // Close the connection via the connection context.\n    return this._context.close();\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<Array<string>> {\n    return this._context\n      .managementSession!.getEventHubProperties({\n        ...options,\n        retryOptions: this._clientOptions.retryOptions\n      })\n      .then((eventHubProperties) => {\n        return eventHubProperties.partitionIds;\n      });\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId - The id of the partition for which information is required.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    return this._context.managementSession!.getPartitionProperties(partitionId, {\n      ...options,\n      retryOptions: this._clientOptions.retryOptions\n    });\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._context.managementSession!.getEventHubProperties({\n      ...options,\n      retryOptions: this._clientOptions.retryOptions\n    });\n  }\n\n  /**\n   * Subscribe to events from all partitions.\n   *\n   * If checkpoint store is provided to the `EventHubConsumerClient` and there are multiple\n   * instances of your application, then each instance will subscribe to a subset of the\n   * partitions such that the load is balanced amongst them.\n   *\n   * Call close() on the returned object to stop receiving events.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubConsumerClient(consumerGroup, connectionString, eventHubName);\n   * const subscription = client.subscribe(\n   *  {\n   *    processEvents: (events, context) => { console.log(\"Received event count: \", events.length) },\n   *    processError: (err, context) => { console.log(\"Error: \", err) }\n   *  },\n   *  { startPosition: earliestEventPosition }\n   * );\n   * ```\n   *\n   * @param handlers - Handlers for the lifecycle of the subscription - subscription initialization\n   *                 per partition, receiving events, handling errors and the closing\n   *                 of a subscription per partition.\n   * @param options - Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }`\n   */\n  subscribe(handlers: SubscriptionEventHandlers, options?: SubscribeOptions): Subscription; // #1\n  /**\n   * Subscribe to events from a single partition.\n   * Call close() on the returned object to stop receiving events.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubConsumerClient(consumerGroup, connectionString, eventHubName);\n   * const subscription = client.subscribe(\n   *  partitionId,\n   *  {\n   *    processEvents: (events, context) => { console.log(\"Received event count: \", events.length) },\n   *    processError: (err, context) => { console.log(\"Error: \", err) }\n   *  },\n   *  { startPosition: earliestEventPosition }\n   * );\n   * ```\n   *\n   * @param partitionId - The id of the partition to subscribe to.\n   * @param handlers - Handlers for the lifecycle of the subscription - subscription initialization\n   *                 of the partition, receiving events, handling errors and the closing\n   *                 of a subscription to the partition.\n   * @param options - Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }`\n   */\n\n  subscribe(\n    partitionId: string,\n    handlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ): Subscription; // #2\n  subscribe(\n    handlersOrPartitionId1?: SubscriptionEventHandlers | string,\n    optionsOrHandlers2?: SubscribeOptions | SubscriptionEventHandlers,\n    possibleOptions3?: SubscribeOptions\n  ): Subscription {\n    let eventProcessor: EventProcessor;\n    let targetedPartitionId: string;\n\n    if (isSubscriptionEventHandlers(handlersOrPartitionId1)) {\n      // #1: subscribe overload - read from all partitions\n      const options = optionsOrHandlers2 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForAllPartitions(\n        handlersOrPartitionId1,\n        options\n      ));\n    } else if (isSubscriptionEventHandlers(optionsOrHandlers2)) {\n      // #2: subscribe overload (read from specific partition IDs), don't coordinate\n      const options = possibleOptions3 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForSinglePartition(\n        // cast to string as downstream code expects partitionId to be string, but JS users could have given us anything.\n        // we don't validate the user input and instead rely on service throwing errors if any\n        String(handlersOrPartitionId1),\n        optionsOrHandlers2,\n        possibleOptions3\n      ));\n    } else {\n      throw new TypeError(\"Unhandled subscribe() overload\");\n    }\n\n    eventProcessor.start();\n\n    const subscription = {\n      get isRunning() {\n        return eventProcessor.isRunning();\n      },\n      close: () => {\n        this._partitionGate.remove(targetedPartitionId);\n        this._subscriptions.delete(subscription);\n        return eventProcessor.stop();\n      }\n    };\n    this._subscriptions.add(subscription);\n    return subscription;\n  }\n\n  /**\n   * Gets the LoadBalancing strategy that should be used based on what the user provided.\n   */\n  private _getLoadBalancingStrategy(): LoadBalancingStrategy {\n    if (!this._userChoseCheckpointStore) {\n      // The default behavior when a checkpointstore isn't provided\n      // is to always grab all the partitions.\n      return new UnbalancedLoadBalancingStrategy();\n    }\n\n    const partitionOwnershipExpirationIntervalInMs = this._loadBalancingOptions\n      .partitionOwnershipExpirationIntervalInMs;\n    if (this._loadBalancingOptions?.strategy === \"greedy\") {\n      return new GreedyLoadBalancingStrategy(partitionOwnershipExpirationIntervalInMs);\n    }\n\n    // The default behavior when a checkpointstore is provided is\n    // to grab one partition at a time.\n    return new BalancedLoadBalancingStrategy(partitionOwnershipExpirationIntervalInMs);\n  }\n\n  private createEventProcessorForAllPartitions(\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ): { targetedPartitionId: string; eventProcessor: EventProcessor } {\n    this._partitionGate.add(\"all\");\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        \"EventHubConsumerClient subscribing to all partitions, using a checkpoint store.\"\n      );\n    } else {\n      logger.verbose(\"EventHubConsumerClient subscribing to all partitions, no checkpoint store.\");\n    }\n\n    const loadBalancingStrategy = this._getLoadBalancingStrategy();\n    const eventProcessor = this._createEventProcessor(\n      this._context,\n      subscriptionEventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...(options as SubscribeOptions),\n        ownerLevel: getOwnerLevel(options, this._userChoseCheckpointStore),\n        // make it so all the event processors process work with the same overarching owner ID\n        // this allows the EventHubConsumer to unify all the work for any processors that it spawns\n        ownerId: this._id,\n        retryOptions: this._clientOptions.retryOptions,\n        loadBalancingStrategy,\n        loopIntervalInMs: this._loadBalancingOptions.updateIntervalInMs\n      }\n    );\n\n    return { targetedPartitionId: \"all\", eventProcessor };\n  }\n\n  private createEventProcessorForSinglePartition(\n    partitionId: string,\n    eventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ): { targetedPartitionId: string; eventProcessor: EventProcessor } {\n    this._partitionGate.add(partitionId);\n\n    const subscribeOptions = options as SubscribeOptions | undefined;\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), using a checkpoint store.`\n      );\n    } else {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), no checkpoint store.`\n      );\n    }\n\n    const eventProcessor = this._createEventProcessor(\n      this._context,\n      eventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...options,\n        processingTarget: partitionId,\n        ownerLevel: getOwnerLevel(subscribeOptions, this._userChoseCheckpointStore),\n        retryOptions: this._clientOptions.retryOptions,\n        loadBalancingStrategy: new UnbalancedLoadBalancingStrategy(),\n        loopIntervalInMs: this._loadBalancingOptions.updateIntervalInMs ?? 10000\n      }\n    );\n\n    return { targetedPartitionId: partitionId, eventProcessor };\n  }\n\n  private _createEventProcessor(\n    connectionContext: ConnectionContext,\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    checkpointStore: CheckpointStore,\n    options: FullEventProcessorOptions\n  ): EventProcessor {\n    return new EventProcessor(\n      this._consumerGroup,\n      connectionContext,\n      subscriptionEventHandlers,\n      checkpointStore,\n      options\n    );\n  }\n}\n\n/**\n * @internal\n */\nexport function isCheckpointStore(possible: CheckpointStore | any): possible is CheckpointStore {\n  if (!possible) {\n    return false;\n  }\n\n  const checkpointStore = possible as CheckpointStore;\n\n  return (\n    typeof checkpointStore.claimOwnership === \"function\" &&\n    typeof checkpointStore.listCheckpoints === \"function\" &&\n    typeof checkpointStore.listOwnership === \"function\" &&\n    typeof checkpointStore.updateCheckpoint === \"function\"\n  );\n}\n\n/**\n * @internal\n */\nfunction isSubscriptionEventHandlers(\n  possible: any | SubscriptionEventHandlers\n): possible is SubscriptionEventHandlers {\n  return typeof (possible as SubscriptionEventHandlers).processEvents === \"function\";\n}\n\nfunction getOwnerLevel(\n  options: SubscribeOptions | undefined,\n  userChoseCheckpointStore: boolean\n): number | undefined {\n  if (options && options.ownerLevel) {\n    return options.ownerLevel;\n  }\n\n  if (userChoseCheckpointStore) {\n    return 0;\n  } else {\n    return undefined;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { EventData, isAmqpAnnotatedMessage, toRheaMessage } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { MessageAnnotations, message, Message as RheaMessage } from \"rhea-promise\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { Span, SpanContext } from \"@azure/core-tracing\";\nimport { TRACEPARENT_PROPERTY, instrumentEventData } from \"./diagnostics/instrumentEventData\";\nimport { convertTryAddOptionsForCompatibility, createMessageSpan } from \"./diagnostics/tracing\";\nimport { isDefined, isObjectWithProperties } from \"./util/typeGuards\";\nimport { OperationTracingOptions } from \"@azure/core-tracing\";\n\n/**\n * The amount of bytes to reserve as overhead for a small message.\n */\nconst smallMessageOverhead = 5;\n/**\n * The amount of bytes to reserve as overhead for a large message.\n */\nconst largeMessageOverhead = 8;\n/**\n * The maximum number of bytes that a message may be to be considered small.\n */\nconst smallMessageMaxBytes = 255;\n\n/**\n * Checks if the provided eventDataBatch is an instance of `EventDataBatch`.\n * @param eventDataBatch - The instance of `EventDataBatch` to verify.\n * @internal\n */\nexport function isEventDataBatch(eventDataBatch: unknown): eventDataBatch is EventDataBatch {\n  return (\n    isObjectWithProperties(eventDataBatch, [\"count\", \"sizeInBytes\", \"tryAdd\"]) &&\n    typeof eventDataBatch.tryAdd === \"function\" &&\n    typeof eventDataBatch.count === \"number\" &&\n    typeof eventDataBatch.sizeInBytes === \"number\"\n  );\n}\n\n/**\n * Options to configure the behavior of the `tryAdd` method on the `EventDataBatch` class.\n */\nexport interface TryAddOptions {\n  /**\n   * The options to use when creating Spans for tracing.\n   */\n  tracingOptions?: OperationTracingOptions;\n\n  /**\n   * @deprecated Tracing options have been moved to the `tracingOptions` property.\n   */\n  parentSpan?: Span | SpanContext;\n}\n\n/**\n * An interface representing a batch of events which can be used to send events to Event Hub.\n *\n * To create the batch, use the `createBatch()` method on the `EventHubProducerClient`.\n * To send the batch, use the `sendBatch()` method on the same client.\n * To fill the batch, use the `tryAdd()` method on the batch itself.\n *\n */\nexport interface EventDataBatch {\n  /**\n   * A value that is hashed and used by the Azure Event Hubs service to determine the partition to\n   * which the events are sent. Use the `createBatch()` method on the `EventHubProducerClient` to\n   * set the partitionKey.\n   * @readonly\n   * @internal\n   */\n  readonly partitionKey?: string;\n\n  /**\n   * Id of the partition to which the batch of events are sent. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the partitionId.\n   * @readonly\n   * @internal\n   */\n  readonly partitionId?: string;\n\n  /**\n   * Size of the batch in bytes after the events added to it have been encoded into a single AMQP\n   * message.\n   * @readonly\n   */\n  readonly sizeInBytes: number;\n\n  /**\n   * Number of events added to the batch.\n   * @readonly\n   */\n  readonly count: number;\n\n  /**\n   * The maximum size of the batch, in bytes. The `tryAdd` function on the batch will return `false`\n   * if the event being added causes the size of the batch to exceed this limit. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the maxSizeInBytes.\n   * @readonly\n   */\n  readonly maxSizeInBytes: number;\n\n  /**\n   * Adds an event to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData -  An individual event data object or AmqpAnnotatedMessage.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  tryAdd(eventData: EventData | AmqpAnnotatedMessage, options?: TryAddOptions): boolean;\n\n  /**\n   * The AMQP message containing encoded events that were added to the batch.\n   * Used internally by the `sendBatch()` method on the `EventHubProducerClient`.\n   * This is not meant for the user to use directly.\n   *\n   * @internal\n   */\n  _generateMessage(): Buffer;\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * Used internally by the `sendBatch()` method to set up the right spans in traces if tracing is enabled.\n   * @internal\n   */\n  readonly _messageSpanContexts: SpanContext[];\n}\n\n/**\n * An internal class representing a batch of events which can be used to send events to Event Hub.\n *\n * @internal\n */\nexport class EventDataBatchImpl implements EventDataBatch {\n  /**\n   * Describes the amqp connection context for the Client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * The Id of the partition to which the batch is expected to be sent to.\n   * Specifying this will throw an error if the batch was created using a `paritionKey`.\n   */\n  private _partitionId?: string;\n  /**\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the batch was created using a `paritionId`.\n   */\n  private _partitionKey?: string;\n  /**\n   * The maximum size allowed for the batch.\n   */\n  private _maxSizeInBytes: number;\n  /**\n   * Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * Number of events in the batch.\n   */\n  private _count: number;\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: SpanContext[] = [];\n  /**\n   * The message annotations to apply on the batch envelope.\n   * This will reflect the message annotations on the first event\n   * that was added to the batch.\n   * A common annotation is the partition key.\n   */\n  private _batchAnnotations?: MessageAnnotations;\n\n  /**\n   * EventDataBatch should not be constructed using `new EventDataBatch()`\n   * Use the `createBatch()` method on your `EventHubProducer` instead.\n   * @internal\n   */\n  constructor(\n    context: ConnectionContext,\n    maxSizeInBytes: number,\n    partitionKey?: string,\n    partitionId?: string\n  ) {\n    this._context = context;\n    this._maxSizeInBytes = maxSizeInBytes;\n    this._partitionKey = isDefined(partitionKey) ? String(partitionKey) : partitionKey;\n    this._partitionId = isDefined(partitionId) ? String(partitionId) : partitionId;\n    this._sizeInBytes = 0;\n    this._count = 0;\n  }\n\n  /**\n   * The maximum size of the batch, in bytes.\n   * @readonly\n   */\n  get maxSizeInBytes(): number {\n    return this._maxSizeInBytes;\n  }\n\n  /**\n   * The partitionKey set during `EventDataBatch` creation. This value is hashed to\n   * produce a partition assignment when the producer is created without a `partitionId`\n   * @readonly\n   */\n  get partitionKey(): string | undefined {\n    return this._partitionKey;\n  }\n\n  /**\n   * The partitionId set during `EventDataBatch` creation.\n   * If this value is set then partitionKey can not be set.\n   * @readonly\n   */\n  get partitionId(): string | undefined {\n    return this._partitionId;\n  }\n\n  /**\n   * Size of the `EventDataBatch` instance after the events added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * Number of events in the `EventDataBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * @internal\n   */\n  get _messageSpanContexts(): SpanContext[] {\n    return this._spanContexts;\n  }\n\n  /**\n   * Generates an AMQP message that contains the provided encoded events and annotations.\n   * @param encodedEvents - The already encoded events to include in the AMQP batch.\n   * @param annotations - The message annotations to set on the batch.\n   */\n  private _generateBatch(encodedEvents: Buffer[], annotations?: MessageAnnotations): Buffer {\n    const batchEnvelope: RheaMessage = {\n      body: message.data_sections(encodedEvents)\n    };\n    if (annotations) {\n      batchEnvelope.message_annotations = annotations;\n    }\n    return message.encode(batchEnvelope);\n  }\n\n  /**\n   * Generates the single AMQP message which is the result of encoding all the events\n   * added into the `EventDataBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  _generateMessage(): Buffer {\n    return this._generateBatch(this._encodedMessages, this._batchAnnotations);\n  }\n\n  /**\n   * Tries to add an event data to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData -  An individual event data object.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  public tryAdd(eventData: EventData | AmqpAnnotatedMessage, options: TryAddOptions = {}): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"tryAdd\", \"eventData\", eventData);\n    options = convertTryAddOptionsForCompatibility(options);\n\n    // check if the event has already been instrumented\n    const previouslyInstrumented = Boolean(\n      (isAmqpAnnotatedMessage(eventData)\n        ? eventData.applicationProperties\n        : eventData.properties)?.[TRACEPARENT_PROPERTY] // Event Data maps properties to applicationProperties.\n    );\n    let spanContext: SpanContext | undefined;\n    if (!previouslyInstrumented) {\n      const { span: messageSpan } = createMessageSpan(options, this._context.config);\n      eventData = instrumentEventData(eventData, messageSpan);\n      spanContext = messageSpan.spanContext();\n      messageSpan.end();\n    }\n\n    // Convert EventData to RheaMessage.\n    const amqpMessage = toRheaMessage(eventData, this._partitionKey);\n    const encodedMessage = message.encode(amqpMessage);\n\n    let currentSize = this._sizeInBytes;\n    // The first time an event is added, we need to calculate\n    // the overhead of creating an AMQP batch, including the\n    // message_annotations that are taken from the 1st message.\n    if (this.count === 0) {\n      if (amqpMessage.message_annotations) {\n        this._batchAnnotations = amqpMessage.message_annotations;\n      }\n\n      // Figure out the overhead of creating a batch by generating an empty batch\n      // with the expected batch annotations.\n      currentSize += this._generateBatch([], this._batchAnnotations).length;\n    }\n\n    const messageSize = encodedMessage.length;\n    const messageOverhead =\n      messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;\n    currentSize += messageSize + messageOverhead;\n\n    // Check if the size of the batch exceeds the maximum allowed size\n    // once we add the new event to it.\n    if (currentSize > this._maxSizeInBytes) {\n      return false;\n    }\n\n    // The event will fit in the batch, so it is now safe to store it.\n    this._encodedMessages.push(encodedMessage);\n    if (spanContext) {\n      this._spanContexts.push(spanContext);\n    }\n\n    this._sizeInBytes = currentSize;\n    this._count++;\n    return true;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport {\n  AmqpError,\n  AwaitableSender,\n  AwaitableSenderOptions,\n  EventContext,\n  OnAmqpEvent,\n  message,\n  Message as RheaMessage\n} from \"rhea-promise\";\nimport {\n  delay,\n  ErrorNameConditionMapper,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  defaultCancellableLock,\n  retry,\n  translate\n} from \"@azure/core-amqp\";\nimport { EventData, toRheaMessage } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { EventHubProducerOptions } from \"./models/private\";\nimport { SendOptions } from \"./models/public\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { EventDataBatch, isEventDataBatch } from \"./eventDataBatch\";\n\n/**\n * Describes the EventHubSender that will send event data to EventHub.\n * @internal\n */\nexport class EventHubSender extends LinkEntity {\n  /**\n   * The unique lock name per connection that is used to acquire the\n   * lock for establishing a sender link by an entity on that connection.\n   * @readonly\n   */\n  readonly senderLock: string = `sender-${uuid()}`;\n  /**\n   * The handler function to handle errors that happen on the\n   * underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpError: OnAmqpEvent;\n  /**\n   * The handler function to handle \"sender_close\" event\n   * that happens on the underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpClose: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEvent;\n  /**\n   * The AMQP sender link.\n   */\n  private _sender?: AwaitableSender;\n\n  /**\n   * Creates a new EventHubSender instance.\n   * @hidden\n   * @param context - The connection context.\n   * @param partitionId - The EventHub partition id to which the sender\n   * wants to send the event data.\n   */\n  constructor(context: ConnectionContext, partitionId?: string) {\n    super(context, {\n      name: context.config.getSenderAddress(partitionId),\n      partitionId: partitionId\n    });\n    this.address = context.config.getSenderAddress(partitionId);\n    this.audience = context.config.getSenderAudience(partitionId);\n\n    this._onAmqpError = (eventContext: EventContext) => {\n      const senderError = eventContext.sender && eventContext.sender.error;\n      logger.verbose(\n        \"[%s] 'sender_error' event occurred on the sender '%s' with address '%s'. \" +\n          \"The associated error is: %O\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        senderError\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onSessionError = (eventContext: EventContext) => {\n      const sessionError = eventContext.session && eventContext.session.error;\n      logger.verbose(\n        \"[%s] 'session_error' event occurred on the session of sender '%s' with address '%s'. \" +\n          \"The associated error is: %O\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        sessionError\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onAmqpClose = async (eventContext: EventContext) => {\n      const sender = this._sender || eventContext.sender!;\n      logger.verbose(\n        \"[%s] 'sender_close' event occurred on the sender '%s' with address '%s'. \" +\n          \"Value for isItselfClosed on the receiver is: '%s' \" +\n          \"Value for isConnecting on the session is: '%s'.\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        sender ? sender.isItselfClosed().toString() : undefined,\n        this.isConnecting\n      );\n      if (sender && !this.isConnecting) {\n        // Call close to clean up timers & other resources\n        await sender.close().catch((err) => {\n          logger.verbose(\n            \"[%s] Error when closing sender [%s] after 'sender_close' event: %O\",\n            this._context.connectionId,\n            this.name,\n            err\n          );\n        });\n      }\n    };\n\n    this._onSessionClose = async (eventContext: EventContext) => {\n      const sender = this._sender || eventContext.sender!;\n      logger.verbose(\n        \"[%s] 'session_close' event occurred on the session of sender '%s' with address '%s'. \" +\n          \"Value for isSessionItselfClosed on the session is: '%s' \" +\n          \"Value for isConnecting on the session is: '%s'.\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        sender ? sender.isSessionItselfClosed().toString() : undefined,\n        this.isConnecting\n      );\n      if (sender && !this.isConnecting) {\n        // Call close to clean up timers & other resources\n        await sender.close().catch((err) => {\n          logger.verbose(\n            \"[%s] Error when closing sender [%s] after 'session_close' event: %O\",\n            this._context.connectionId,\n            this.name,\n            err\n          );\n        });\n      }\n    };\n  }\n\n  /**\n   * Deletes the sender from the context. Clears the token renewal timer. Closes the sender link.\n   * @hidden\n   * @returns Promise<void>\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._sender) {\n        logger.info(\n          \"[%s] Closing the Sender for the entity '%s'.\",\n          this._context.connectionId,\n          this._context.config.entityPath\n        );\n        const senderLink = this._sender;\n        this._deleteFromCache();\n        await this._closeLink(senderLink);\n      }\n    } catch (err) {\n      const msg = `[${this._context.connectionId}] An error occurred while closing sender ${this.name}: ${err?.name}: ${err?.message}`;\n      logger.warning(msg);\n      logErrorStackTrace(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Determines whether the AMQP sender link is open. If open then returns true else returns false.\n   * @hidden\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result = Boolean(this._sender && this._sender.isOpen());\n    logger.verbose(\n      \"[%s] Sender '%s' with address '%s' is open? -> %s\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n  /**\n   * Returns maximum message size on the AMQP sender link.\n   * @param abortSignal - An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   * @returns Promise<number>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  async getMaxMessageSize(\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n    } = {}\n  ): Promise<number> {\n    const sender = await this._getLink(options);\n\n    return sender.maxMessageSize;\n  }\n\n  /**\n   * Send a batch of EventData to the EventHub. The \"message_annotations\",\n   * \"application_properties\" and \"properties\" of the first message will be set as that\n   * of the envelope (batch message).\n   * @hidden\n   * @param events -  An array of EventData objects to be sent in a Batch message.\n   * @param options - Options to control the way the events are batched along with request options\n   */\n  async send(\n    events: EventData[] | EventDataBatch,\n    options?: SendOptions & EventHubProducerOptions\n  ): Promise<void> {\n    try {\n      logger.info(\n        \"[%s] Sender '%s', trying to send EventData[].\",\n        this._context.connectionId,\n        this.name\n      );\n\n      let encodedBatchMessage: Buffer | undefined;\n      if (isEventDataBatch(events)) {\n        if (events.count === 0) {\n          logger.info(\n            `[${this._context.connectionId}] Empty batch was passsed. No events to send.`\n          );\n          return;\n        }\n        encodedBatchMessage = events._generateMessage();\n      } else {\n        if (events.length === 0) {\n          logger.info(`[${this._context.connectionId}] Empty array was passed. No events to send.`);\n          return;\n        }\n        const partitionKey = (options && options.partitionKey) || undefined;\n        const messages: RheaMessage[] = [];\n        // Convert EventData to RheaMessage.\n        for (let i = 0; i < events.length; i++) {\n          const rheaMessage = toRheaMessage(events[i], partitionKey);\n          messages[i] = rheaMessage;\n        }\n        // Encode every amqp message and then convert every encoded message to amqp data section\n        const batchMessage: RheaMessage = {\n          body: message.data_sections(messages.map(message.encode))\n        };\n\n        // Set message_annotations of the first message as\n        // that of the envelope (batch message).\n        if (messages[0].message_annotations) {\n          batchMessage.message_annotations = messages[0].message_annotations;\n        }\n\n        // Finally encode the envelope (batch message).\n        encodedBatchMessage = message.encode(batchMessage);\n      }\n      logger.info(\n        \"[%s] Sender '%s', sending encoded batch message.\",\n        this._context.connectionId,\n        this.name,\n        encodedBatchMessage\n      );\n      return await this._trySendBatch(encodedBatchMessage, options);\n    } catch (err) {\n      logger.warning(\n        `An error occurred while sending the batch message ${err?.name}: ${err?.message}`\n      );\n      logErrorStackTrace(err);\n      throw err;\n    }\n  }\n\n  private _deleteFromCache(): void {\n    this._sender = undefined;\n    delete this._context.senders[this.name];\n    logger.verbose(\n      \"[%s] Deleted the sender '%s' with address '%s' from the client cache.\",\n      this._context.connectionId,\n      this.name,\n      this.address\n    );\n  }\n\n  private _createSenderOptions(newName?: boolean): AwaitableSenderOptions {\n    if (newName) this.name = `${uuid()}`;\n    const srOptions: AwaitableSenderOptions = {\n      name: this.name,\n      target: {\n        address: this.address\n      },\n      onError: this._onAmqpError,\n      onClose: this._onAmqpClose,\n      onSessionError: this._onSessionError,\n      onSessionClose: this._onSessionClose\n    };\n    logger.verbose(\"Creating sender with options: %O\", srOptions);\n    return srOptions;\n  }\n\n  /**\n   * Tries to send the message to EventHub if there is enough credit to send them\n   * and the circular buffer has available space to settle the message after sending them.\n   *\n   * We have implemented a synchronous send over here in the sense that we shall be waiting\n   * for the message to be accepted or rejected and accordingly resolve or reject the promise.\n   * @hidden\n   * @param rheaMessage - The message to be sent to EventHub.\n   * @returns Promise<void>\n   */\n  private async _trySendBatch(\n    rheaMessage: RheaMessage | Buffer,\n    options: SendOptions & EventHubProducerOptions = {}\n  ): Promise<void> {\n    const abortSignal: AbortSignalLike | undefined = options.abortSignal;\n    const retryOptions = options.retryOptions || {};\n    const timeoutInMs = getRetryAttemptTimeoutInMs(retryOptions);\n    retryOptions.timeoutInMs = timeoutInMs;\n\n    const sendEventPromise = async (): Promise<void> => {\n      const initStartTime = Date.now();\n      const sender = await this._getLink(options);\n      const timeTakenByInit = Date.now() - initStartTime;\n      logger.verbose(\n        \"[%s] Sender '%s', credit: %d available: %d\",\n        this._context.connectionId,\n        this.name,\n        sender.credit,\n        sender.session.outgoing.available()\n      );\n\n      let waitTimeForSendable = 1000;\n      if (!sender.sendable() && timeoutInMs - timeTakenByInit > waitTimeForSendable) {\n        logger.verbose(\n          \"%s Sender '%s', waiting for 1 second for sender to become sendable\",\n          this._context.connectionId,\n          this.name\n        );\n\n        await delay(waitTimeForSendable);\n\n        logger.verbose(\n          \"%s Sender '%s' after waiting for a second, credit: %d available: %d\",\n          this._context.connectionId,\n          this.name,\n          sender.credit,\n          sender.session?.outgoing?.available()\n        );\n      } else {\n        waitTimeForSendable = 0;\n      }\n\n      if (!sender.sendable()) {\n        // let us retry to send the message after some time.\n        const msg =\n          `[${this._context.connectionId}] Sender \"${this.name}\", ` +\n          `cannot send the message right now. Please try later.`;\n        logger.warning(msg);\n        const amqpError: AmqpError = {\n          condition: ErrorNameConditionMapper.SenderBusyError,\n          description: msg\n        };\n        throw translate(amqpError);\n      }\n\n      logger.verbose(\n        \"[%s] Sender '%s', sending message with id '%s'.\",\n        this._context.connectionId,\n        this.name\n      );\n      if (timeoutInMs <= timeTakenByInit + waitTimeForSendable) {\n        const desc: string =\n          `${this._context.connectionId} Sender \"${this.name}\" ` +\n          `with address \"${this.address}\", was not able to send the message right now, due ` +\n          `to operation timeout.`;\n        logger.warning(desc);\n        const e: AmqpError = {\n          condition: ErrorNameConditionMapper.ServiceUnavailableError,\n          description: desc\n        };\n        throw translate(e);\n      }\n\n      try {\n        const delivery = await sender.send(rheaMessage, {\n          format: 0x80013700,\n          timeoutInSeconds: (timeoutInMs - timeTakenByInit - waitTimeForSendable) / 1000,\n          abortSignal\n        });\n        logger.info(\n          \"[%s] Sender '%s', sent message with delivery id: %d\",\n          this._context.connectionId,\n          this.name,\n          delivery.id\n        );\n      } catch (err) {\n        throw err.innerError || err;\n      }\n    };\n\n    const config: RetryConfig<void> = {\n      operation: sendEventPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.sendMessage,\n      abortSignal: abortSignal,\n      retryOptions: retryOptions\n    };\n\n    try {\n      await retry<void>(config);\n    } catch (err) {\n      const translatedError = translate(err);\n      logger.warning(\n        \"[%s] Sender '%s', An error occurred while sending the message %s\",\n        this._context.connectionId,\n        this.name,\n        `${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  private async _getLink(\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n    } = {}\n  ): Promise<AwaitableSender> {\n    if (this.isOpen() && this._sender) {\n      return this._sender;\n    }\n    const retryOptions = options.retryOptions || {};\n    const timeoutInMs = getRetryAttemptTimeoutInMs(retryOptions);\n    retryOptions.timeoutInMs = timeoutInMs;\n    const senderOptions = this._createSenderOptions();\n\n    const startTime = Date.now();\n    const createLinkPromise = async (): Promise<AwaitableSender> => {\n      return defaultCancellableLock.acquire(\n        this.senderLock,\n        () => {\n          const taskStartTime = Date.now();\n          const taskTimeoutInMs = timeoutInMs - (taskStartTime - startTime);\n          return this._init({\n            ...senderOptions,\n            abortSignal: options.abortSignal,\n            timeoutInMs: taskTimeoutInMs\n          });\n        },\n        { abortSignal: options.abortSignal, timeoutInMs: timeoutInMs }\n      );\n    };\n\n    const config: RetryConfig<AwaitableSender> = {\n      operation: createLinkPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.senderLink,\n      abortSignal: options.abortSignal,\n      retryOptions: retryOptions\n    };\n\n    try {\n      return await retry<AwaitableSender>(config);\n    } catch (err) {\n      const translatedError = translate(err);\n      logger.warning(\n        \"[%s] An error occurred while creating the sender %s: %s\",\n        this._context.connectionId,\n        this.name,\n        `${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  /**\n   * Initializes the sender session on the connection.\n   * Should only be called from _createLinkIfNotOpen\n   * @hidden\n   */\n  private async _init(\n    options: AwaitableSenderOptions & {\n      abortSignal: AbortSignalLike | undefined;\n      timeoutInMs: number;\n    }\n  ): Promise<AwaitableSender> {\n    try {\n      if (!this.isOpen() || !this._sender) {\n        // Wait for the connectionContext to be ready to open the link.\n        await this._context.readyToOpenLink();\n        await this._negotiateClaim({\n          setTokenRenewal: false,\n          abortSignal: options.abortSignal,\n          timeoutInMs: options.timeoutInMs\n        });\n\n        logger.verbose(\n          \"[%s] Trying to create sender '%s'...\",\n          this._context.connectionId,\n          this.name\n        );\n\n        const sender = await this._context.connection.createAwaitableSender(options);\n        this._sender = sender;\n        logger.verbose(\n          \"[%s] Sender '%s' created with sender options: %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        sender.setMaxListeners(1000);\n\n        // It is possible for someone to close the sender and then start it again.\n        // Thus make sure that the sender is present in the client cache.\n        if (!this._context.senders[this.name]) this._context.senders[this.name] = this;\n        this._ensureTokenRenewal();\n        return sender;\n      } else {\n        logger.verbose(\n          \"[%s] The sender '%s' with address '%s' is open -> %s. Hence not reconnecting.\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          this.isOpen()\n        );\n        return this._sender;\n      }\n    } catch (err) {\n      const translatedError = translate(err);\n      logger.warning(\n        \"[%s] An error occurred while creating the sender %s: %s\",\n        this._context.connectionId,\n        this.name,\n        `${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  /**\n   * Creates a new sender to the given event hub, and optionally to a given partition if it is\n   * not present in the context or returns the one present in the context.\n   * @hidden\n   * @param partitionId - Partition ID to which it will send event data.\n   */\n  static create(context: ConnectionContext, partitionId?: string): EventHubSender {\n    const ehSender: EventHubSender = new EventHubSender(context, partitionId);\n    if (!context.senders[ehSender.name]) {\n      context.senders[ehSender.name] = ehSender;\n    }\n    return context.senders[ehSender.name];\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { NamedKeyCredential, SASCredential, TokenCredential } from \"@azure/core-auth\";\nimport { SpanStatusCode, Link, Span, SpanContext, SpanKind } from \"@azure/core-tracing\";\nimport { ConnectionContext, createConnectionContext } from \"./connectionContext\";\nimport { instrumentEventData, TRACEPARENT_PROPERTY } from \"./diagnostics/instrumentEventData\";\nimport { createMessageSpan } from \"./diagnostics/tracing\";\nimport { EventData } from \"./eventData\";\nimport { EventDataBatch, EventDataBatchImpl, isEventDataBatch } from \"./eventDataBatch\";\nimport { EventHubSender } from \"./eventHubSender\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { EventHubProperties, PartitionProperties } from \"./managementClient\";\nimport {\n  CreateBatchOptions,\n  EventHubClientOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions,\n  GetPartitionPropertiesOptions,\n  SendBatchOptions\n} from \"./models/public\";\nimport { throwErrorIfConnectionClosed, throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { isCredential, isDefined } from \"./util/typeGuards\";\nimport { OperationOptions } from \"./util/operationOptions\";\nimport { createEventHubSpan } from \"./diagnostics/tracing\";\n\n/**\n * The `EventHubProducerClient` class is used to send events to an Event Hub.\n *\n * There are multiple ways to create an `EventHubProducerClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.\n *\n * Optionally, you can also pass an options bag to configure the retry policy or proxy settings.\n *\n */\nexport class EventHubProducerClient {\n  /**\n   * Describes the amqp connection context for the client.\n   */\n  private _context: ConnectionContext;\n\n  /**\n   * The options passed by the user when creating the EventHubClient instance.\n   */\n  private _clientOptions: EventHubClientOptions;\n  /**\n   * Map of partitionId to senders\n   */\n  private _sendersMap: Map<string, EventHubSender>;\n  /**\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._context.config.entityPath;\n  }\n\n  /**\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._context.config.host;\n  }\n\n  /**\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(connectionString: string, options?: EventHubClientOptions); // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  /**\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(connectionString: string, eventHubName: string, options?: EventHubClientOptions); // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  /**\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service.\n   * See &commat;azure/identity for creating credentials that support AAD auth.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    options?: EventHubClientOptions // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    eventHubNameOrOptions2?: string | EventHubClientOptions,\n    credentialOrOptions3?:\n      | TokenCredential\n      | NamedKeyCredential\n      | SASCredential\n      | EventHubClientOptions,\n    options4?: EventHubClientOptions // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  ) {\n    this._context = createConnectionContext(\n      fullyQualifiedNamespaceOrConnectionString1,\n      eventHubNameOrOptions2,\n      credentialOrOptions3,\n      options4\n    );\n    if (typeof eventHubNameOrOptions2 !== \"string\") {\n      this._clientOptions = eventHubNameOrOptions2 || {};\n    } else if (!isCredential(credentialOrOptions3)) {\n      this._clientOptions = credentialOrOptions3 || {};\n    } else {\n      this._clientOptions = options4 || {};\n    }\n\n    this._sendersMap = new Map();\n  }\n\n  /**\n   * Creates an instance of `EventDataBatch` to which one can add events until the maximum supported size is reached.\n   * The batch can be passed to the {@link sendBatch} method of the `EventHubProducerClient` to be sent to Azure Event Hubs.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubProducerClient(connectionString);\n   * let batch = await client.createBatch();\n   * for (let i = 0; i < messages.length; i++) {\n   *  if (!batch.tryAdd(messages[i])) {\n   *    await client.sendBatch(batch);\n   *    batch = await client.createBatch();\n   *    if (!batch.tryAdd(messages[i])) {\n   *      throw new Error(\"Message too big to fit\")\n   *    }\n   *    if (i === messages.length - 1) {\n   *      await client.sendBatch(batch);\n   *    }\n   *   }\n   * }\n   * ```\n   *\n   * @param options -  Configures the behavior of the batch.\n   * - `partitionKey`  : A value that is hashed and used by the Azure Event Hubs service to determine the partition to which\n   * the events need to be sent.\n   * - `partitionId`   : Id of the partition to which the batch of events need to be sent.\n   * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   * - `abortSignal`   : A signal the request to cancel the operation.\n   * @returns Promise<EventDataBatch>\n   * @throws Error if both `partitionId` and `partitionKey` are set in the options.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal in the options.\n   */\n  async createBatch(options: CreateBatchOptions = {}): Promise<EventDataBatch> {\n    throwErrorIfConnectionClosed(this._context);\n\n    if (isDefined(options.partitionId) && isDefined(options.partitionKey)) {\n      throw new Error(\"partitionId and partitionKey cannot both be set when creating a batch\");\n    }\n\n    let sender = this._sendersMap.get(\"\");\n    if (!sender) {\n      sender = EventHubSender.create(this._context);\n      this._sendersMap.set(\"\", sender);\n    }\n\n    let maxMessageSize = await sender.getMaxMessageSize({\n      retryOptions: this._clientOptions.retryOptions,\n      abortSignal: options.abortSignal\n    });\n\n    if (options.maxSizeInBytes) {\n      if (options.maxSizeInBytes > maxMessageSize) {\n        const error = new Error(\n          `Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`\n        );\n        logger.warning(`[${this._context.connectionId}] ${error.message}`);\n        logErrorStackTrace(error);\n        throw error;\n      }\n      maxMessageSize = options.maxSizeInBytes;\n    }\n    return new EventDataBatchImpl(\n      this._context,\n      maxMessageSize,\n      options.partitionKey,\n      options.partitionId\n    );\n  }\n\n  /**\n   * Sends an array of events to the associated Event Hub.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubProducerClient(connectionString);\n   * await client.sendBatch(messages);\n   * ```\n   *\n   * @param batch - An array of {@link EventData} or `AmqpAnnotatedMessage`.\n   * @param options - A set of options that can be specified to influence the way in which\n   * events are sent to the associated Event Hub.\n   * - `abortSignal`  : A signal the request to cancel the send operation.\n   * - `partitionId`  : The partition this batch will be sent to. If set, `partitionKey` can not be set.\n   * - `partitionKey` : A value that is hashed to produce a partition assignment. If set, `partitionId` can not be set.\n   *\n   * @returns Promise<void>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while sending a message.\n   * @throws Error if the underlying connection or sender has been closed.\n   */\n  async sendBatch(\n    batch: EventData[] | AmqpAnnotatedMessage[],\n    options?: SendBatchOptions\n  ): Promise<void>;\n  /**\n   * Sends a batch of events to the associated Event Hub.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubProducerClient(connectionString);\n   * let batch = await client.createBatch();\n   * for (let i = 0; i < messages.length; i++) {\n   *  if (!batch.tryAdd(messages[i])) {\n   *    await client.sendBatch(batch);\n   *    batch = await client.createBatch();\n   *    if (!batch.tryAdd(messages[i])) {\n   *      throw new Error(\"Message too big to fit\")\n   *    }\n   *    if (i === messages.length - 1) {\n   *      await client.sendBatch(batch);\n   *    }\n   *   }\n   * }\n   * ```\n   * @param batch - A batch of events that you can create using the {@link createBatch} method.\n   * @param options - A set of options that can be specified to influence the way in which\n   * events are sent to the associated Event Hub.\n   * - `abortSignal`  : A signal the request to cancel the send operation.\n   *\n   * @returns Promise<void>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while sending a message.\n   * @throws Error if the underlying connection or sender has been closed.\n   */\n  async sendBatch(batch: EventDataBatch, options?: OperationOptions): Promise<void>; // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  async sendBatch(\n    batch: EventDataBatch | EventData[],\n    options: SendBatchOptions | OperationOptions = {}\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"sendBatch\", \"batch\", batch);\n\n    let partitionId: string | undefined;\n    let partitionKey: string | undefined;\n\n    // link message span contexts\n    let spanContextsToLink: SpanContext[] = [];\n\n    if (isEventDataBatch(batch)) {\n      // For batches, partitionId and partitionKey would be set on the batch.\n      partitionId = batch.partitionId;\n      partitionKey = batch.partitionKey;\n      const unexpectedOptions = options as SendBatchOptions;\n      if (unexpectedOptions.partitionKey && partitionKey !== unexpectedOptions.partitionKey) {\n        throw new Error(\n          `The partitionKey (${unexpectedOptions.partitionKey}) set on sendBatch does not match the partitionKey (${partitionKey}) set when creating the batch.`\n        );\n      }\n      if (unexpectedOptions.partitionId && unexpectedOptions.partitionId !== partitionId) {\n        throw new Error(\n          `The partitionId (${unexpectedOptions.partitionId}) set on sendBatch does not match the partitionId (${partitionId}) set when creating the batch.`\n        );\n      }\n\n      spanContextsToLink = batch._messageSpanContexts;\n    } else {\n      if (!Array.isArray(batch)) {\n        batch = [batch];\n      }\n\n      // For arrays of events, partitionId and partitionKey would be set in the options.\n      const expectedOptions = options as SendBatchOptions;\n      partitionId = expectedOptions.partitionId;\n      partitionKey = expectedOptions.partitionKey;\n\n      for (let i = 0; i < batch.length; i++) {\n        const event = batch[i];\n        if (!event.properties || !event.properties[TRACEPARENT_PROPERTY]) {\n          const { span: messageSpan } = createMessageSpan(options, this._context.config);\n          // since these message spans are created from same context as the send span,\n          // these message spans don't need to be linked.\n          // replace the original event with the instrumented one\n          batch[i] = instrumentEventData(batch[i], messageSpan);\n          messageSpan.end();\n        }\n      }\n    }\n    if (isDefined(partitionId) && isDefined(partitionKey)) {\n      throw new Error(\n        `The partitionId (${partitionId}) and partitionKey (${partitionKey}) cannot both be specified.`\n      );\n    }\n\n    if (isDefined(partitionId)) {\n      partitionId = String(partitionId);\n    }\n    if (isDefined(partitionKey)) {\n      partitionKey = String(partitionKey);\n    }\n\n    let sender = this._sendersMap.get(partitionId || \"\");\n    if (!sender) {\n      sender = EventHubSender.create(this._context, partitionId);\n      this._sendersMap.set(partitionId || \"\", sender);\n    }\n\n    const sendSpan = this._createSendSpan(options, spanContextsToLink);\n\n    try {\n      const result = await sender.send(batch, {\n        ...options,\n        partitionId,\n        partitionKey,\n        retryOptions: this._clientOptions.retryOptions\n      });\n      sendSpan.setStatus({ code: SpanStatusCode.OK });\n      return result;\n    } catch (error) {\n      sendSpan.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: error.message\n      });\n      throw error;\n    } finally {\n      sendSpan.end();\n    }\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    await this._context.close();\n\n    for (const pair of this._sendersMap) {\n      await pair[1].close();\n    }\n    this._sendersMap.clear();\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._context.managementSession!.getEventHubProperties({\n      ...options,\n      retryOptions: this._clientOptions.retryOptions\n    });\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<Array<string>> {\n    return this._context\n      .managementSession!.getEventHubProperties({\n        ...options,\n        retryOptions: this._clientOptions.retryOptions\n      })\n      .then((eventHubProperties) => {\n        return eventHubProperties.partitionIds;\n      });\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId - The id of the partition for which information is required.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    return this._context.managementSession!.getPartitionProperties(partitionId, {\n      ...options,\n      retryOptions: this._clientOptions.retryOptions\n    });\n  }\n\n  private _createSendSpan(\n    operationOptions: OperationOptions,\n    spanContextsToLink: SpanContext[] = []\n  ): Span {\n    const links: Link[] = spanContextsToLink.map((context) => {\n      return {\n        context\n      };\n    });\n\n    const { span } = createEventHubSpan(\"send\", operationOptions, this._context.config, {\n      kind: SpanKind.CLIENT,\n      links\n    });\n\n    return span;\n  }\n}\n"],"names":["isTokenCredential","isNamedKeyCredential","isSASCredential","createClientLogger","os.type","os.release","parseConnectionString","Constants","uuid","defaultCancellableLock","isSasTokenProvider","TokenType","createSpanFunction","SpanKind","setSpan","context","setSpanContext","SpanStatusCode","translate","RequestResponseLink","SenderEvents","ReceiverEvents","generate_uuid","RetryOperationType","retry","ConnectionConfig","ConnectionContextBase","ConnectionEvents","createSasTokenProvider","CloseReason","message","Buffer","AmqpAnnotatedMessage","ErrorNameConditionMapper","AbortError","StandardAbortMessage","delay","types","getTraceParentHeader","extractSpanContextFromTraceParentHeader","AbortController"],"mappings":"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"}