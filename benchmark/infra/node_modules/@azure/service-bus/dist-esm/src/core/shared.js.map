{"version":3,"file":"shared.js","sourceRoot":"","sources":["../../../src/core/shared.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAGlC,OAAO,EAAE,wBAAwB,EAAE,MAAM,oBAAoB,CAAC;AAC9D,OAAO,EAAE,cAAc,EAAE,MAAM,QAAQ,CAAC;AAoBxC;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,gBAAgB,CAC9B,SAAiB,EACjB,QAA8B,EAC9B,sBAA4D;IAE5D,IAAI,QAAQ,EAAE;QACZ,MAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC;QACvB,MAAM,KAAK,GAAG,QAAQ,CAAC,YAAY,CAAC;QACpC,MAAM,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC;QACxC,cAAc,CAAC,OAAO,CACpB,wEAAwE,GAAG,WAAW,EACtF,SAAS,EACT,EAAE,EACF,OAAO,EACP,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAC3C,CAAC;QACF,IAAI,OAAO,IAAI,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;YAC7C,MAAM,OAAO,GAAG,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAA4B,CAAC;YAC1E,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAC5B,cAAc,CAAC,OAAO,CACpB,oEAAoE,EACpE,SAAS,EACT,EAAE,CACH,CAAC;YACF,MAAM,YAAY,GAAG,sBAAsB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YACvD,cAAc,CAAC,OAAO,CACpB,+DAA+D,EAC/D,SAAS,EACT,EAAE,EACF,YAAY,CACb,CAAC;YACF,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;gBAC9E,MAAM,KAAK,GAAG,wBAAwB,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACpD,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;aAC9B;YAED,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;SAC1B;KACF;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,qBAAqB,CACnC,IAAY,EACZ,WAAwB,EACxB,MAAc,EACd,QAA0B;IAE1B,MAAM,WAAW,mBACf,IAAI;QACJ,2GAA2G;QAC3G,8HAA8H;QAC9H,UAAU,EAAE,WAAW,KAAK,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK;QAC7D,uDAAuD;QACvD,eAAe,EAAE,WAAW,KAAK,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC3D,6DAA6D;QAC7D,eAAe,EAAE,WAAW,KAAK,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAC3D,MAAM,EACN,aAAa,EAAE,CAAC,IACb,QAAQ,CACZ,CAAC;IAEF,OAAO,WAAW,CAAC;AACrB,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Delivery, ReceiverOptions, Source } from \"rhea-promise\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { receiverLogger } from \"../log\";\nimport { ReceiveMode } from \"../models\";\n\n/**\n * @internal\n */\nexport type ReceiverHandlers = Pick<\n  ReceiverOptions,\n  \"onMessage\" | \"onError\" | \"onClose\" | \"onSessionError\" | \"onSessionClose\" | \"onSettled\"\n>;\n\n/**\n * @internal\n */\nexport interface DeferredPromiseAndTimer {\n  resolve: (value?: any) => void;\n  reject: (reason?: any) => void;\n  timer: NodeJS.Timer;\n}\n\n/**\n * This is the shared onSettled handler for all of the receiver implementations.\n *\n * The sequence is basically:\n * 1. User calls `await <ServiceBusMessage instance>.complete()`     (or other settlement methods)\n * 2. This creates a `Promise` that gets stored in the _deliveryDispositionMap\n * 3. When the service acknowledges the settlement this method gets called for that message.\n * 4. We resolve() the promise from the _deliveryDispositionMap.\n * 5. User's code after the settlement continues.\n *\n * @internal\n */\nexport function onMessageSettled(\n  logPrefix: string,\n  delivery: Delivery | undefined,\n  deliveryDispositionMap: Map<number, DeferredPromiseAndTimer>\n): void {\n  if (delivery) {\n    const id = delivery.id;\n    const state = delivery.remote_state;\n    const settled = delivery.remote_settled;\n    receiverLogger.verbose(\n      \"%s Delivery with id %d, remote_settled: %s, remote_state: %o has been \" + \"received.\",\n      logPrefix,\n      id,\n      settled,\n      state && state.error ? state.error : state\n    );\n    if (settled && deliveryDispositionMap.has(id)) {\n      const promise = deliveryDispositionMap.get(id) as DeferredPromiseAndTimer;\n      clearTimeout(promise.timer);\n      receiverLogger.verbose(\n        \"%s Found the delivery with id %d in the map and cleared the timer.\",\n        logPrefix,\n        id\n      );\n      const deleteResult = deliveryDispositionMap.delete(id);\n      receiverLogger.verbose(\n        \"%s Successfully deleted the delivery with id %d from the map.\",\n        logPrefix,\n        id,\n        deleteResult\n      );\n      if (state && state.error && (state.error.condition || state.error.description)) {\n        const error = translateServiceBusError(state.error);\n        return promise.reject(error);\n      }\n\n      return promise.resolve();\n    }\n  }\n}\n\n/**\n * Creates the options that need to be specified while creating an AMQP receiver link.\n *\n * @internal\n */\nexport function createReceiverOptions(\n  name: string,\n  receiveMode: ReceiveMode,\n  source: Source,\n  handlers: ReceiverHandlers\n): ReceiverOptions {\n  const rcvrOptions: ReceiverOptions = {\n    name,\n    // \"autoaccept\" being true in the \"receiveAndDelete\" mode sets the \"settled\" flag to true on the deliveries\n    // which helps in clearing the circular buffer(size=2048) as it is needed to receive messages after 2048 of them are received.\n    autoaccept: receiveMode === \"receiveAndDelete\" ? true : false,\n    // receiveAndDelete -> first(0), peekLock -> second (1)\n    rcv_settle_mode: receiveMode === \"receiveAndDelete\" ? 0 : 1,\n    // receiveAndDelete -> settled (1), peekLock -> unsettled (0)\n    snd_settle_mode: receiveMode === \"receiveAndDelete\" ? 1 : 0,\n    source,\n    credit_window: 0,\n    ...handlers,\n  };\n\n  return rcvrOptions;\n}\n"]}