{"version":3,"file":"streamingReceiver.js","sourceRoot":"","sources":["../../../src/core/streamingReceiver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { MessageReceiver, OnAmqpEventAsPromise, ReceiveOptions } from \"./messageReceiver\";\nimport { ConnectionContext } from \"../connectionContext\";\n\nimport { ReceiverHelper } from \"./receiverHelper\";\n\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport {\n  RetryOperationType,\n  MessagingError,\n  RetryOptions,\n  ConditionErrorNameMapper,\n} from \"@azure/core-amqp\";\nimport { OperationOptionsBase, trace } from \"../modelsToBeSharedWithEventHubs\";\nimport { receiverLogger as logger } from \"../log\";\nimport { AmqpError, EventContext, OnAmqpEvent } from \"rhea-promise\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { abandonMessage, completeMessage, retryForever } from \"../receivers/receiverCommon\";\nimport { ReceiverHandlers } from \"./shared\";\nimport {\n  InternalMessageHandlers,\n  InternalProcessErrorArgs,\n  MessageHandlers,\n  ProcessErrorArgs,\n  SubscribeOptions,\n} from \"../models\";\nimport { createProcessingSpan } from \"../diagnostics/instrumentServiceBusMessage\";\nimport { AbortError } from \"@azure/abort-controller\";\n\n/**\n * @internal\n */\nexport interface StreamingReceiverInitArgs\n  extends ReceiveOptions,\n    Pick<OperationOptionsBase, \"abortSignal\"> {\n  messageHandlers: MessageHandlers;\n}\n\n/**\n * @internal\n * Describes the streaming receiver where the user can receive the message\n * by providing handler functions.\n */\nexport class StreamingReceiver extends MessageReceiver {\n  /**\n   * The maximum number of messages that should be\n   * processed concurrently while in streaming mode. Once this limit has been reached, more\n   * messages will not be received until the user's message handler has completed processing current message.\n   * Default: 1\n   */\n  maxConcurrentCalls: number = 1;\n\n  /**\n   * Indicates whether the receiver is already actively\n   * running `onDetached`.\n   * This is expected to be true while the receiver attempts\n   * to bring its link back up due to a retryable issue.\n   */\n  private _isDetaching: boolean = false;\n  /**\n   *Retry policy options that determine the mode, number of retries, retry interval etc.\n   */\n  private _retryOptions: RetryOptions;\n\n  private _receiverHelper: ReceiverHelper;\n\n  /**\n   * The user's message handlers, wrapped so any thrown exceptions are properly logged\n   * or forwarded to the user's processError handler.\n   */\n  private _messageHandlers: () => Required<InternalMessageHandlers> = () => {\n    throw new Error(\"messageHandlers are not set.\");\n  };\n\n  /**\n   * The subscribe(options) passed when the subscribe call originally happened. Stored\n   * so _subscribeImpl() can re-use them later if we have to restart our subscription\n   * when detach/reattaching.\n   */\n  private _subscribeOptions: SubscribeOptions | undefined;\n\n  /**\n   * Used so we can stub out retry in tests.\n   */\n  private _retryForeverFn: typeof retryForever = retryForever;\n\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_close\" event.\n   */\n  private _onAmqpClose: OnAmqpEventAsPromise;\n\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEventAsPromise;\n\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_error\" event.\n   */\n  private _onAmqpError: OnAmqpEvent;\n\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"message\" event.\n   */\n  protected _onAmqpMessage: OnAmqpEventAsPromise;\n\n  /**\n   * Whether we are currently subscribed (or subscribing) for receiving messages.\n   * (this is irrespective of receiver state, etc... - it's just a simple flag to prevent\n   * multiple subscribe() calls from happening on this instance)\n   */\n  public get isSubscribeActive(): boolean {\n    return !this._receiverHelper.isSuspended();\n  }\n\n  /**\n   * Instantiate a new Streaming receiver for receiving messages with handlers.\n   *\n   * @param connectionContext - The client entity context.\n   * @param options - Options for how you'd like to connect.\n   */\n  constructor(connectionContext: ConnectionContext, entityPath: string, options: ReceiveOptions) {\n    super(connectionContext, entityPath, \"streaming\", options);\n\n    if (typeof options?.maxConcurrentCalls === \"number\" && options?.maxConcurrentCalls > 0) {\n      this.maxConcurrentCalls = options.maxConcurrentCalls;\n    }\n\n    this._retryOptions = options?.retryOptions || {};\n\n    this._receiverHelper = new ReceiverHelper(() => ({\n      receiver: this.link,\n      logPrefix: this.logPrefix,\n    }));\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      const receiver = this.link || context.receiver!;\n\n      logger.logError(\n        receiverError,\n        `${this.logPrefix} 'receiver_close' event occurred. The associated error is`\n      );\n\n      this._lockRenewer?.stopAll(this);\n\n      if (receiver && !receiver.isItselfClosed()) {\n        await this.onDetached(receiverError);\n      } else {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver '%s' with address '%s' \" +\n            \"because the sdk initiated it. Hence not calling detached from the _onAmqpClose\" +\n            \"() handler.\",\n          this.logPrefix,\n          this.name,\n          this.address\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const receiver = this.link || context.receiver!;\n      const sessionError = context.session && context.session.error;\n\n      logger.logError(\n        sessionError,\n        `${this.logPrefix} 'session_close' event occurred. The associated error is`\n      );\n\n      this._lockRenewer?.stopAll(this);\n\n      if (receiver && !receiver.isSessionItselfClosed()) {\n        await this.onDetached(sessionError);\n      } else {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the session of receiver '%s' with address \" +\n            \"'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose\" +\n            \"() handler.\",\n          this.logPrefix,\n          this.name,\n          this.address\n        );\n      }\n    };\n\n    this._onAmqpError = (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        logger.logError(\n          sbError,\n          `${this.logPrefix} 'receiver_error' event occurred. The associated error is`\n        );\n        this._messageHandlers().processError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n        });\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError) as MessagingError;\n        logger.logError(\n          sbError,\n          `${this.logPrefix} 'session_error' event occurred. The associated error is`\n        );\n        this._messageHandlers().processError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n        });\n      }\n    };\n\n    this._onAmqpMessage = async (context: EventContext) => {\n      // If the receiver got closed in PeekLock mode, avoid processing the message as we\n      // cannot settle the message.\n      if (this.receiveMode === \"peekLock\" && (!this.link || !this.link.isOpen())) {\n        logger.verbose(\n          \"%s Not calling the user's message handler for the current message \" +\n            \"as the receiver is closed\",\n          this.logPrefix\n        );\n        return;\n      }\n\n      const bMessage: ServiceBusMessageImpl = new ServiceBusMessageImpl(\n        context.message!,\n        context.delivery!,\n        true,\n        this.receiveMode,\n        options.skipParsingBodyAsJson ?? false\n      );\n\n      this._lockRenewer?.start(this, bMessage, (err) => {\n        this._messageHandlers().processError({\n          error: err,\n          errorSource: \"renewLock\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n        });\n      });\n\n      try {\n        await this._messageHandlers().processMessage(bMessage);\n      } catch (err) {\n        logger.logError(\n          err,\n          \"%s An error occurred while running user's message handler for the message \" +\n            \"with id '%s' on the receiver '%s'\",\n          this.logPrefix,\n          bMessage.messageId,\n          this.name\n        );\n\n        // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,\n        // doing this here. Otherwise, this should be done in finally.\n        this._lockRenewer?.stop(this, bMessage);\n        const error = translateServiceBusError(err) as MessagingError;\n        // Nothing much to do if user's message handler throws. Let us try abandoning the message.\n        if (\n          !bMessage.delivery.remote_settled &&\n          error.code !== ConditionErrorNameMapper[\"com.microsoft:message-lock-lost\"] &&\n          this.receiveMode === \"peekLock\" &&\n          this.isOpen() // only try to abandon the messages if the connection is still open\n        ) {\n          try {\n            logger.logError(\n              error,\n              \"%s Abandoning the message with id '%s' on the receiver '%s' since \" +\n                \"an error occured: %O.\",\n              this.logPrefix,\n              bMessage.messageId,\n              this.name,\n              error\n            );\n            await abandonMessage(\n              bMessage,\n              this._context,\n              entityPath,\n              undefined,\n              this._retryOptions\n            );\n          } catch (abandonError) {\n            const translatedError = translateServiceBusError(abandonError);\n            logger.logError(\n              translatedError,\n              \"%s An error occurred while abandoning the message with id '%s' on the \" +\n                \"receiver '%s'\",\n              this.logPrefix,\n              bMessage.messageId,\n              this.name\n            );\n            this._messageHandlers().processError({\n              error: translatedError,\n              errorSource: \"abandon\",\n              entityPath: this.entityPath,\n              fullyQualifiedNamespace: this._context.config.host,\n            });\n          }\n        }\n        return;\n      } finally {\n        try {\n          this._receiverHelper.addCredit(1);\n        } catch (err) {\n          // if we're aborting out of the receive operation we don't need to report it (the user already\n          // knows the link is being torn down or stopped)\n          if (err.name !== \"AbortError\") {\n            logger.logError(\n              err,\n              `[${this.logPrefix}] Failed to add credit after receiving message`\n            );\n            await this._reportInternalError(err);\n          }\n        }\n      }\n\n      // If we've made it this far, then user's message handler completed fine. Let us try\n      // completing the message.\n      if (\n        this.autoComplete &&\n        this.receiveMode === \"peekLock\" &&\n        !bMessage.delivery.remote_settled\n      ) {\n        try {\n          logger.verbose(\n            \"%s Auto completing the message with id '%s' on \" + \"the receiver.\",\n            this.logPrefix,\n            bMessage.messageId\n          );\n          await completeMessage(bMessage, this._context, entityPath, this._retryOptions);\n        } catch (completeError) {\n          const translatedError = translateServiceBusError(completeError);\n          logger.logError(\n            translatedError,\n            \"%s An error occurred while completing the message with id '%s' on the \" +\n              \"receiver '%s'\",\n            this.logPrefix,\n            bMessage.messageId,\n            this.name\n          );\n          this._messageHandlers().processError({\n            error: translatedError,\n            errorSource: \"complete\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n          });\n        }\n      }\n    };\n  }\n\n  private _reportInternalError(error: Error): Promise<void> {\n    const messageHandlers = this._messageHandlers();\n\n    if (messageHandlers.forwardInternalErrors) {\n      const errorArgs: InternalProcessErrorArgs = {\n        error,\n        entityPath: this.entityPath,\n        errorSource: \"internal\",\n        fullyQualifiedNamespace: this._context.config.host,\n      };\n\n      return messageHandlers.processError(errorArgs as ProcessErrorArgs);\n    }\n\n    return Promise.resolve();\n  }\n\n  private _getHandlers(): ReceiverHandlers {\n    return {\n      onMessage: (context: EventContext) =>\n        this._onAmqpMessage(context).catch((err) => this._reportInternalError(err)),\n      onClose: (context: EventContext) =>\n        this._onAmqpClose(context).catch((err) => this._reportInternalError(err)),\n      onSessionClose: (context: EventContext) =>\n        this._onSessionClose(context).catch((err) => this._reportInternalError(err)),\n      onError: this._onAmqpError,\n      onSessionError: this._onSessionError,\n    };\n  }\n\n  async stopReceivingMessages(): Promise<void> {\n    await this._receiverHelper.suspend();\n\n    if (this._subscribeCallPromise) {\n      await this._subscribeCallPromise;\n    }\n  }\n\n  async close(): Promise<void> {\n    await this._receiverHelper.suspend();\n    return super.close();\n  }\n\n  private _subscribeCallPromise: Promise<void> | undefined;\n\n  /**\n   * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.\n   *\n   * Any errors thrown by this function will also be sent to the messageHandlers.processError function\n   * _and_ thrown, ultimately from this method.\n   *\n   * NOTE: This function retries _infinitely_ until success! It is completely up to the user to break\n   * out of this retry cycle otherwise by:\n   * 1. closing the receiver\n   * 2. Calling `close` on the subscription instance they received when they initially called subscribe().\n   * 3. aborting the abortSignal they passed in when calling subscribe (this also applies to initialization calls in onDetach)\n   *\n   * @param onMessage - The message handler to receive servicebus messages.\n   * @param onError - The error handler to receive an error that occurs while receivin messages.\n   */\n  async subscribe(\n    messageHandlers: InternalMessageHandlers,\n    subscribeOptions: SubscribeOptions | undefined\n  ): Promise<void> {\n    // these options and message handlers will be re-used if/when onDetach is called.\n    this._subscribeOptions = subscribeOptions;\n    this._setMessageHandlers(messageHandlers, subscribeOptions);\n\n    let promiseResolve: (() => void) | undefined;\n    this._subscribeCallPromise = new Promise((resolve) => {\n      promiseResolve = resolve;\n    });\n\n    try {\n      this._receiverHelper.resume();\n      return await this._subscribeImpl(\"subscribe\");\n    } catch (err) {\n      // callers aren't going to be in a good position to forward this error properly\n      // so we do it here.\n      await this._messageHandlers().processError({\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host,\n        errorSource: \"receive\",\n        error: err,\n      });\n\n      throw err;\n    } finally {\n      promiseResolve?.();\n      this._subscribeCallPromise = undefined;\n    }\n  }\n\n  /**\n   * Wraps the individual message handlers with tracing and proper error handling\n   * and assigns them to `this._messageHandlers`\n   *\n   * @param userHandlers - The user's message handlers\n   * @param operationOptions - The subscribe(options)\n   */\n  private _setMessageHandlers(\n    userHandlers: InternalMessageHandlers,\n    operationOptions: OperationOptionsBase | undefined\n  ): void {\n    const messageHandlers = {\n      processError: async (args: ProcessErrorArgs) => {\n        try {\n          args.error = translateServiceBusError(args.error);\n          await userHandlers.processError(args);\n        } catch (err) {\n          await this._reportInternalError(err);\n          logger.logError(err, `An error was thrown from the user's processError handler`);\n        }\n      },\n      processMessage: async (message: ServiceBusMessageImpl) => {\n        try {\n          const span = createProcessingSpan(message, this, this._context.config, operationOptions);\n          return await trace(() => userHandlers.processMessage(message), span);\n        } catch (err) {\n          this._messageHandlers().processError({\n            error: err,\n            errorSource: \"processMessageCallback\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n          });\n          throw err;\n        }\n      },\n      postInitialize: async () => {\n        if (!userHandlers.postInitialize) {\n          return;\n        }\n\n        return userHandlers.postInitialize().catch((err) =>\n          this._messageHandlers().processError({\n            error: err,\n            errorSource: \"processMessageCallback\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n          })\n        );\n      },\n      preInitialize: async () => {\n        if (!userHandlers.preInitialize) {\n          return;\n        }\n\n        return userHandlers.preInitialize().catch((err) =>\n          this._messageHandlers().processError({\n            error: err,\n            errorSource: \"processMessageCallback\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n          })\n        );\n      },\n      forwardInternalErrors: userHandlers.forwardInternalErrors ?? false,\n    };\n\n    this._messageHandlers = () => messageHandlers;\n  }\n\n  /**\n   * Subscribes using the already assigned `this._messageHandlers` and `this._subscribeOptions`\n   *\n   * @returns A promise that will resolve when a link is created and we successfully add credits to it.\n   */\n  private async _subscribeImpl(caller: \"detach\" | \"subscribe\"): Promise<void> {\n    try {\n      // we don't expect to ever get an error from retryForever but bugs\n      // do happen.\n      return await this._retryForeverFn({\n        retryConfig: {\n          connectionId: this._context.connection.id,\n          operationType: RetryOperationType.receiverLink,\n          abortSignal: this._subscribeOptions?.abortSignal,\n          retryOptions: this._retryOptions,\n          operation: () => this._initAndAddCreditOperation(caller),\n        },\n        onError: (err) =>\n          this._messageHandlers().processError({\n            error: err,\n            errorSource: \"receive\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n          }),\n        logPrefix: this.logPrefix,\n        logger,\n      });\n    } catch (err) {\n      try {\n        await this._receiverHelper.suspend();\n      } catch (error) {\n        logger.logError(error, `${this.logPrefix} receiver.suspend threw an error`);\n      }\n\n      throw err;\n    }\n  }\n\n  /**\n   * Initializes the link and adds credits. If any of these operations fail any created link will\n   * be closed.\n   *\n   * @param caller - The caller which dictates whether or not we create a new name for our created link.\n   * @param catchAndReportError - A function and reports an error but does not throw it.\n   */\n  private async _initAndAddCreditOperation(caller: \"detach\" | \"subscribe\"): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n\n    await this._messageHandlers().preInitialize();\n\n    if (this._receiverHelper.isSuspended()) {\n      // user has suspended us while we were initializing\n      // the connection. Abort this attempt - if they attempt\n      // resubscribe we'll just reinitialize.\n      throw new AbortError(\"Receiver was suspended during initialization.\");\n    }\n\n    await this._init(\n      this._createReceiverOptions(caller === \"detach\", this._getHandlers()),\n      this._subscribeOptions?.abortSignal\n    );\n\n    try {\n      await this._messageHandlers().postInitialize();\n      this._receiverHelper.addCredit(this.maxConcurrentCalls);\n    } catch (err) {\n      try {\n        await this.closeLink();\n      } catch (error) {\n        await this._messageHandlers().processError({\n          error,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n        });\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Will reconnect the receiver link if necessary.\n   * @param receiverError - The receiver error or connection error, if any.\n   */\n  async onDetached(receiverError?: AmqpError | Error): Promise<void> {\n    try {\n      logger.verbose(`${this.logPrefix} onDetached: reinitializing link.`);\n\n      // User explicitly called `close` on the receiver, so link is already closed\n      // and we can exit early.\n      if (this.wasClosedPermanently) {\n        logger.verbose(\n          `${this.logPrefix} onDetached: link has been closed permanently, not reinitializing. `\n        );\n        return;\n      }\n\n      // Prevent multiple onDetached invocations from running concurrently.\n      if (this._isDetaching) {\n        // This can happen when the network connection goes down for some amount of time.\n        // The first connection `disconnect` will trigger `onDetached` and attempt to retry\n        // creating the connection/receiver link.\n        // While those retry attempts fail (until the network connection comes back up),\n        // we'll continue to see connection `disconnect` errors.\n        // These should be ignored until the already running `onDetached` completes\n        // its retry attempts or errors.\n        logger.verbose(\n          `${this.logPrefix} onDetached: Call to detached on streaming receiver '${this.name}' is already in progress.`\n        );\n        return;\n      }\n\n      this._isDetaching = true;\n\n      const translatedError = receiverError\n        ? translateServiceBusError(receiverError)\n        : receiverError;\n      logger.logError(\n        translatedError,\n        `${this.logPrefix} onDetached: Reinitializing receiver because of error`\n      );\n\n      // Clears the token renewal timer. Closes the link and its session if they are open.\n      // Removes the link and its session if they are present in rhea's cache.\n      await this.closeLink();\n    } catch (err) {\n      logger.verbose(\n        `${this.logPrefix} onDetached: Encountered an error when closing the previous link: `,\n        err\n      );\n    }\n\n    try {\n      await this._subscribeImpl(\"detach\");\n    } finally {\n      this._isDetaching = false;\n    }\n  }\n\n  protected removeLinkFromContext(): void {\n    delete this._context.messageReceivers[this.name];\n  }\n}\n"]}