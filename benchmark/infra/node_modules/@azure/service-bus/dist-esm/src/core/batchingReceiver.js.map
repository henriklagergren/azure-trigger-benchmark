{"version":3,"file":"batchingReceiver.js","sourceRoot":"","sources":["../../../src/core/batchingReceiver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { receiverLogger as logger } from \"../log\";\nimport {\n  AmqpError,\n  EventContext,\n  OnAmqpEvent,\n  ReceiverEvents,\n  SessionEvents,\n  Receiver as RheaPromiseReceiver,\n  Session,\n} from \"rhea-promise\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { MessageReceiver, OnAmqpEventAsPromise, ReceiveOptions } from \"./messageReceiver\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { checkAndRegisterWithAbortSignal } from \"../util/utils\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { createAndEndProcessingSpan } from \"../diagnostics/instrumentServiceBusMessage\";\nimport { ReceiveMode } from \"../models\";\nimport { ServiceBusError, translateServiceBusError } from \"../serviceBusError\";\n\n/**\n * Describes the batching receiver where the user can receive a specified number of messages for\n * a predefined time.\n * @internal\n */\nexport class BatchingReceiver extends MessageReceiver {\n  /**\n   * Instantiate a new BatchingReceiver.\n   *\n   * @param connectionContext - The client entity context.\n   * @param options - Options for how you'd like to connect.\n   */\n  constructor(connectionContext: ConnectionContext, entityPath: string, options: ReceiveOptions) {\n    super(connectionContext, entityPath, \"batching\", options);\n\n    this._batchingReceiverLite = new BatchingReceiverLite(\n      connectionContext,\n      entityPath,\n      async (abortSignal?: AbortSignalLike): Promise<MinimalReceiver | undefined> => {\n        let lastError: Error | AmqpError | undefined;\n\n        const rcvrOptions = this._createReceiverOptions(false, {\n          onError: (context) => {\n            lastError = context?.receiver?.error;\n          },\n          onSessionError: (context) => {\n            lastError = context?.session?.error;\n          },\n          onClose: async () => {\n            /** Nothing to do here - the next call will just fail so they'll get an appropriate error from somewhere else. */\n          },\n          onSessionClose: async () => {\n            /** Nothing to do here - the next call will just fail so they'll get an appropriate error from somewhere else. */\n          },\n          onMessage: async () => {\n            /** Nothing to do here -  we don't add credits initially so we don't need to worry about handling any messages.*/\n          },\n        });\n\n        await this._init(rcvrOptions, abortSignal);\n\n        if (lastError != null) {\n          throw lastError;\n        }\n\n        return this.link;\n      },\n      this.receiveMode,\n      options.skipParsingBodyAsJson ?? false\n    );\n  }\n\n  private _batchingReceiverLite: BatchingReceiverLite;\n\n  get isReceivingMessages(): boolean {\n    return this._batchingReceiverLite.isReceivingMessages;\n  }\n\n  /**\n   * To be called when connection is disconnected to gracefully close ongoing receive request.\n   * @param connectionError - The connection error if any.\n   */\n  async onDetached(connectionError?: AmqpError | Error): Promise<void> {\n    await this.closeLink();\n\n    if (connectionError == null) {\n      connectionError = new Error(\n        \"Unknown error occurred on the AMQP connection while receiving messages.\"\n      );\n    }\n\n    this._batchingReceiverLite.terminate(connectionError);\n  }\n\n  /**\n   * Receives a batch of messages from a ServiceBus Queue/Topic.\n   * @param maxMessageCount - The maximum number of messages to receive.\n   * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.\n   * @param maxWaitTimeInMs - The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.\n   * @param maxTimeAfterFirstMessageInMs - The total amount of time to wait after the first message\n   * has been received. Defaults to 1 second.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * @returns A promise that resolves with an array of Message objects.\n   */\n  async receive(\n    maxMessageCount: number,\n    maxWaitTimeInMs: number,\n    maxTimeAfterFirstMessageInMs: number,\n    options: OperationOptionsBase\n  ): Promise<ServiceBusMessageImpl[]> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      logger.verbose(\n        \"[%s] Receiver '%s', setting max concurrent calls to 0.\",\n        this.logPrefix,\n        this.name\n      );\n\n      const messages = await this._batchingReceiverLite.receiveMessages({\n        maxMessageCount,\n        maxWaitTimeInMs,\n        maxTimeAfterFirstMessageInMs,\n        ...options,\n      });\n\n      if (this._lockRenewer) {\n        for (const message of messages) {\n          this._lockRenewer.start(this, message, (_error) => {\n            // the auto lock renewer already logs this in a detailed way. So this hook is mainly here\n            // to potentially forward the error to the user (which we're not doing yet)\n          });\n        }\n      }\n\n      return messages;\n    } catch (error) {\n      logger.logError(error, \"[%s] Rejecting receiveMessages()\", this.logPrefix);\n      throw error;\n    }\n  }\n\n  static create(\n    context: ConnectionContext,\n    entityPath: string,\n    options: ReceiveOptions\n  ): BatchingReceiver {\n    throwErrorIfConnectionClosed(context);\n    const bReceiver = new BatchingReceiver(context, entityPath, options);\n    context.messageReceivers[bReceiver.name] = bReceiver;\n    return bReceiver;\n  }\n\n  protected removeLinkFromContext(): void {\n    delete this._context.messageReceivers[this.name];\n  }\n}\n\n/**\n * Gets a function that returns the smaller of the two timeouts,\n * taking into account elapsed time from when getRemainingWaitTimeInMsFn\n * was called.\n *\n * @param maxWaitTimeInMs - Maximum time to wait for the first message\n * @param maxTimeAfterFirstMessageInMs - Maximum time to wait after the first message before completing the receive.\n *\n * @internal\n */\nexport function getRemainingWaitTimeInMsFn(\n  maxWaitTimeInMs: number,\n  maxTimeAfterFirstMessageInMs: number\n): () => number {\n  const startTimeMs = Date.now();\n\n  return () => {\n    const remainingTimeMs = maxWaitTimeInMs - (Date.now() - startTimeMs);\n\n    if (remainingTimeMs < 0) {\n      return 0;\n    }\n\n    return Math.min(remainingTimeMs, maxTimeAfterFirstMessageInMs);\n  };\n}\n\n/**\n * Useful interface that mimics EventEmitter without requiring us to actually\n * import the events definition (which is annoying with browsers).\n *\n * @internal\n */\ntype EventEmitterLike<T extends RheaPromiseReceiver | Session> = Pick<\n  T,\n  \"once\" | \"removeListener\" | \"on\"\n>;\n\n/**\n * The bare minimum needed to receive messages for batched\n * message receiving.\n *\n * @internal\n */\nexport type MinimalReceiver = Pick<\n  RheaPromiseReceiver,\n  \"name\" | \"isOpen\" | \"credit\" | \"addCredit\" | \"drain\" | \"drainCredit\"\n> &\n  EventEmitterLike<RheaPromiseReceiver> & {\n    session: EventEmitterLike<Session>;\n  } & {\n    connection: {\n      id: string;\n    };\n  };\n\n/**\n * @internal\n */\ntype MessageAndDelivery = Pick<EventContext, \"message\" | \"delivery\">;\n\n/**\n * @internal\n */\ninterface ReceiveMessageArgs extends OperationOptionsBase {\n  maxMessageCount: number;\n  maxWaitTimeInMs: number;\n  maxTimeAfterFirstMessageInMs: number;\n}\n\n/**\n * The internals of a batching receiver minus anything that would require us to hold onto a client entity context\n * or a receiver on a permanent basis.\n *\n * Usable with both session and non-session receivers.\n *\n * @internal\n */\nexport class BatchingReceiverLite {\n  /**\n   * NOTE: exists only to make unit testing possible.\n   */\n  private _createAndEndProcessingSpan: typeof createAndEndProcessingSpan;\n\n  constructor(\n    private _connectionContext: ConnectionContext,\n    public entityPath: string,\n    private _getCurrentReceiver: (\n      abortSignal?: AbortSignalLike\n    ) => Promise<MinimalReceiver | undefined>,\n    private _receiveMode: ReceiveMode,\n    _skipParsingBodyAsJson: boolean\n  ) {\n    this._createAndEndProcessingSpan = createAndEndProcessingSpan;\n\n    this._createServiceBusMessage = (context: MessageAndDelivery) => {\n      return new ServiceBusMessageImpl(\n        context.message!,\n        context.delivery!,\n        true,\n        this._receiveMode,\n        _skipParsingBodyAsJson\n      );\n    };\n\n    this._getRemainingWaitTimeInMsFn = (\n      maxWaitTimeInMs: number,\n      maxTimeAfterFirstMessageInMs: number\n    ) => getRemainingWaitTimeInMsFn(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs);\n\n    this.isReceivingMessages = false;\n  }\n\n  private _createServiceBusMessage: (\n    context: Pick<EventContext, \"message\" | \"delivery\">\n  ) => ServiceBusMessageImpl;\n\n  private _getRemainingWaitTimeInMsFn: typeof getRemainingWaitTimeInMsFn;\n  private _closeHandler: ((connectionError?: AmqpError | Error) => void) | undefined;\n  private _finalAction: (() => void) | undefined;\n\n  isReceivingMessages: boolean;\n\n  /**\n   * Receives a set of messages,\n   *\n   * @internal\n   * @hidden\n   */\n  public async receiveMessages(args: ReceiveMessageArgs): Promise<ServiceBusMessageImpl[]> {\n    try {\n      this.isReceivingMessages = true;\n      const receiver = await this._getCurrentReceiver(args.abortSignal);\n\n      if (receiver == null) {\n        // (was somehow closed in between the init() and the return)\n        throw new ServiceBusError(\"Link closed before receiving messages.\", \"GeneralError\");\n      }\n\n      const messages = await new Promise<ServiceBusMessageImpl[]>((resolve, reject) =>\n        this._receiveMessagesImpl(receiver, args, resolve, reject)\n      );\n      this._createAndEndProcessingSpan(messages, this, this._connectionContext.config, args);\n      return messages;\n    } finally {\n      this._closeHandler = undefined;\n      this.isReceivingMessages = false;\n    }\n  }\n\n  /**\n   * Closes the receiver (optionally with an error), cancelling any current operations.\n   *\n   * @param connectionError - An optional error (rhea doesn't always deliver one for certain disconnection events)\n   */\n  terminate(connectionError?: Error | AmqpError): void {\n    if (this._closeHandler) {\n      this._closeHandler(connectionError);\n      this._closeHandler = undefined;\n    }\n  }\n\n  private _receiveMessagesImpl(\n    receiver: MinimalReceiver,\n    args: ReceiveMessageArgs,\n    origResolve: (messages: ServiceBusMessageImpl[]) => void,\n    origReject: (err: Error | AmqpError) => void\n  ): void {\n    const getRemainingWaitTimeInMs = this._getRemainingWaitTimeInMsFn(\n      args.maxWaitTimeInMs,\n      args.maxTimeAfterFirstMessageInMs\n    );\n\n    const brokeredMessages: ServiceBusMessageImpl[] = [];\n    const loggingPrefix = `[${receiver.connection.id}|r:${receiver.name}]`;\n\n    let totalWaitTimer: NodeJS.Timer | undefined;\n\n    // eslint-disable-next-line prefer-const\n    let cleanupBeforeResolveOrReject: () => void;\n\n    const reject = (err: Error | AmqpError): void => {\n      cleanupBeforeResolveOrReject();\n      origReject(err);\n    };\n\n    const resolveImmediately = (result: ServiceBusMessageImpl[]): void => {\n      cleanupBeforeResolveOrReject();\n      origResolve(result);\n    };\n\n    const resolveAfterPendingMessageCallbacks = (result: ServiceBusMessageImpl[]): void => {\n      // NOTE: through rhea-promise, most of our event handlers are made asynchronous by calling setTimeout(emit).\n      // However, a small set (*error and drain) execute immediately. This can lead to a situation where the logical\n      // ordering of events is correct but the execution order is incorrect because the events are not all getting\n      // put into the task queue the same way.\n      // setTimeout() ensures that we resolve _after_ any already-queued onMessage handlers that may\n      // be waiting in the task queue.\n      setTimeout(() => {\n        cleanupBeforeResolveOrReject();\n        origResolve(result);\n      });\n    };\n\n    const onError: OnAmqpEvent = (context: EventContext) => {\n      const eventType = context.session?.error != null ? \"session_error\" : \"receiver_error\";\n      let error = context.session?.error || context.receiver?.error;\n\n      if (error) {\n        error = translateServiceBusError(error);\n        logger.logError(error, `${loggingPrefix} '${eventType}' event occurred. Received an error`);\n      } else {\n        error = new ServiceBusError(\"An error occurred while receiving messages.\", \"GeneralError\");\n      }\n      reject(error);\n    };\n\n    this._closeHandler = (error?: AmqpError | Error): void => {\n      if (\n        // no error, just closing. Go ahead and return what we have.\n        error == null ||\n        // Return the collected messages if in ReceiveAndDelete mode because otherwise they are lost forever\n        (this._receiveMode === \"receiveAndDelete\" && brokeredMessages.length)\n      ) {\n        logger.verbose(\n          `${loggingPrefix} Closing. Resolving with ${brokeredMessages.length} messages.`\n        );\n\n        return resolveAfterPendingMessageCallbacks(brokeredMessages);\n      }\n\n      reject(translateServiceBusError(error));\n    };\n\n    let abortSignalCleanupFunction: (() => void) | undefined = undefined;\n\n    // Final action to be performed after\n    // - maxMessageCount is reached or\n    // - maxWaitTime is passed or\n    // - newMessageWaitTimeoutInSeconds is passed since the last message was received\n    this._finalAction = (): void => {\n      if (receiver.drain) {\n        // If a drain is already in process then we should let it complete. Some messages might still be in flight, but they will\n        // arrive before the drain completes.\n        return;\n      }\n\n      // Drain any pending credits.\n      if (receiver.isOpen() && receiver.credit > 0) {\n        logger.verbose(`${loggingPrefix} Draining leftover credits(${receiver.credit}).`);\n        receiver.drainCredit();\n      } else {\n        logger.verbose(\n          `${loggingPrefix} Resolving receiveMessages() with ${brokeredMessages.length} messages.`\n        );\n\n        // we can resolve immediately (ie, no setTimeout call) because we have no\n        // remaining messages (thus nothing to wait for)\n        resolveImmediately(brokeredMessages);\n      }\n    };\n\n    // Action to be performed on the \"message\" event.\n    const onReceiveMessage: OnAmqpEventAsPromise = async (context: EventContext) => {\n      // TODO: this appears to be aggravating a bug that we need to look into more deeply.\n      // The same timeout+drain sequence should work fine for receiveAndDelete but it appears\n      // to cause problems.\n      if (this._receiveMode === \"peekLock\") {\n        if (brokeredMessages.length === 0) {\n          // We'll now remove the old timer (which was the overall `maxWaitTimeMs` timer)\n          // and replace it with another timer that is a (probably) much shorter interval.\n          //\n          // This allows the user to get access to received messages earlier and also gives us\n          // a chance to have fewer messages internally that could get lost if the user's\n          // app crashes.\n          if (totalWaitTimer) clearTimeout(totalWaitTimer);\n          const remainingWaitTimeInMs = getRemainingWaitTimeInMs();\n          totalWaitTimer = setTimeout(() => {\n            logger.verbose(\n              `${loggingPrefix} Batching, waited for ${remainingWaitTimeInMs} milliseconds after receiving the first message.`\n            );\n            this._finalAction!();\n          }, remainingWaitTimeInMs);\n        }\n      }\n\n      try {\n        const data: ServiceBusMessageImpl = this._createServiceBusMessage(context);\n        brokeredMessages.push(data);\n\n        // NOTE: we used to actually \"lose\" any extra messages. At this point I've fixed the areas that were causing us to receive\n        // extra messages but if this bug arises in some other way it's better to return the message than it would be to let it be\n        // silently dropped on the floor.\n        if (brokeredMessages.length > args.maxMessageCount) {\n          logger.warning(\n            `More messages arrived than were expected: ${args.maxMessageCount} vs ${\n              brokeredMessages.length + 1\n            }`\n          );\n        }\n      } catch (err) {\n        const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));\n        logger.logError(\n          err,\n          `${loggingPrefix} Received an error while converting AmqpMessage to ServiceBusMessage`\n        );\n        reject(errObj);\n      }\n      if (brokeredMessages.length === args.maxMessageCount) {\n        this._finalAction!();\n      }\n    };\n\n    const onClose: OnAmqpEventAsPromise = async (context: EventContext) => {\n      const type = context.session?.error != null ? \"session_closed\" : \"receiver_closed\";\n      const error = context.session?.error || context.receiver?.error;\n\n      if (error) {\n        logger.logError(error, `${loggingPrefix} '${type}' event occurred. The associated error`);\n      }\n    };\n\n    // Action to be performed on the \"receiver_drained\" event.\n    const onReceiveDrain: OnAmqpEvent = () => {\n      receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n      receiver.drain = false;\n\n      logger.verbose(\n        `${loggingPrefix} Drained, resolving receiveMessages() with ${brokeredMessages.length} messages.`\n      );\n\n      resolveAfterPendingMessageCallbacks(brokeredMessages);\n    };\n\n    cleanupBeforeResolveOrReject = (): void => {\n      if (receiver != null) {\n        receiver.removeListener(ReceiverEvents.receiverError, onError);\n        receiver.removeListener(ReceiverEvents.message, onReceiveMessage);\n        receiver.session.removeListener(SessionEvents.sessionError, onError);\n        receiver.removeListener(ReceiverEvents.receiverClose, onClose);\n        receiver.session.removeListener(SessionEvents.sessionClose, onClose);\n        receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n      }\n\n      if (totalWaitTimer) {\n        clearTimeout(totalWaitTimer);\n      }\n\n      if (abortSignalCleanupFunction) {\n        abortSignalCleanupFunction();\n      }\n      abortSignalCleanupFunction = undefined;\n    };\n\n    abortSignalCleanupFunction = checkAndRegisterWithAbortSignal((err) => {\n      reject(err);\n    }, args.abortSignal);\n\n    logger.verbose(\n      `${loggingPrefix} Adding credit for receiving ${args.maxMessageCount} messages.`\n    );\n\n    // By adding credit here, we let the service know that at max we can handle `maxMessageCount`\n    // number of messages concurrently. We will return the user an array of messages that can\n    // be of size upto maxMessageCount. Then the user needs to accordingly dispose\n    // (complete/abandon/defer/deadletter) the messages from the array.\n    receiver.addCredit(args.maxMessageCount);\n\n    logger.verbose(\n      `${loggingPrefix} Setting the wait timer for ${args.maxWaitTimeInMs} milliseconds.`\n    );\n\n    totalWaitTimer = setTimeout(() => {\n      logger.verbose(\n        `${loggingPrefix} Batching, waited for max wait time ${args.maxWaitTimeInMs} milliseconds.`\n      );\n      this._finalAction!();\n    }, args.maxWaitTimeInMs);\n\n    receiver.on(ReceiverEvents.message, onReceiveMessage);\n    receiver.on(ReceiverEvents.receiverError, onError);\n    receiver.on(ReceiverEvents.receiverClose, onClose);\n    receiver.on(ReceiverEvents.receiverDrained, onReceiveDrain);\n\n    receiver.session.on(SessionEvents.sessionError, onError);\n    receiver.session.on(SessionEvents.sessionClose, onClose);\n  }\n}\n"]}