{"version":3,"file":"autoLockRenewer.js","sourceRoot":"","sources":["../../../src/core/autoLockRenewer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionContext } from \"../connectionContext\";\nimport { receiverLogger as logger } from \"../log\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { calculateRenewAfterDuration } from \"../util/utils\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { OnErrorNoContext } from \"./messageReceiver\";\n\n/**\n * @internal\n */\nexport type RenewableMessageProperties = Readonly<\n  Pick<ServiceBusMessageImpl, \"lockToken\" | \"messageId\">\n> &\n  // updated when we renew the lock\n  Pick<ServiceBusMessageImpl, \"lockedUntilUtc\">;\n\n/**\n * @internal\n */\ntype MinimalLink = Pick<LinkEntity<any>, \"name\" | \"logPrefix\" | \"entityPath\">;\n\n/**\n * Tracks locks for messages, renewing until a configurable duration.\n *\n * @internal\n */\nexport class LockRenewer {\n  /**\n   * A map of link names to individual maps for each\n   * link that map a message ID to its auto-renewal timer.\n   */\n  private _messageRenewLockTimers: Map<string, Map<string, NodeJS.Timer | undefined>> = new Map<\n    string,\n    Map<string, NodeJS.Timer | undefined>\n  >();\n\n  // just here for make unit testing a bit easier.\n  private _calculateRenewAfterDuration: typeof calculateRenewAfterDuration;\n\n  constructor(\n    private _context: Pick<ConnectionContext, \"getManagementClient\">,\n    private _maxAutoRenewDurationInMs: number\n  ) {\n    this._calculateRenewAfterDuration = calculateRenewAfterDuration;\n  }\n\n  /**\n   * Creates an AutoLockRenewer.\n   *\n   * @param linkEntity - Your link entity instance (probably 'this')\n   * @param context - The connection context for your link entity (probably 'this._context')\n   * @param options - The ReceiveOptions passed through to your message receiver.\n   * @returns if the lock mode is peek lock (or if is unspecified, thus defaulting to peekLock)\n   * and the options.maxAutoLockRenewalDurationInMs is greater than 0..Otherwise, returns undefined.\n   */\n  static create(\n    context: Pick<ConnectionContext, \"getManagementClient\">,\n    maxAutoRenewLockDurationInMs: number,\n    receiveMode: \"peekLock\" | \"receiveAndDelete\"\n  ): LockRenewer | undefined {\n    if (receiveMode !== \"peekLock\") {\n      return undefined;\n    }\n\n    if (maxAutoRenewLockDurationInMs <= 0) {\n      return undefined;\n    }\n\n    return new LockRenewer(context, maxAutoRenewLockDurationInMs);\n  }\n\n  /**\n   * Cancels all pending lock renewals for messages on given link and removes all entries from our internal cache.\n   */\n  stopAll(linkEntity: MinimalLink): void {\n    logger.verbose(\n      `${linkEntity.logPrefix} Clearing message renew lock timers for all the active messages.`\n    );\n\n    const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);\n\n    if (messagesForLink == null) {\n      return;\n    }\n\n    for (const messageId of messagesForLink.keys()) {\n      this._stopAndRemoveById(linkEntity, messagesForLink, messageId);\n    }\n\n    this._messageRenewLockTimers.delete(linkEntity.name);\n  }\n\n  /**\n   * Stops lock renewal for a single message.\n   *\n   * @param bMessage - The message whose lock renewal we will stop.\n   */\n  stop(linkEntity: MinimalLink, bMessage: RenewableMessageProperties): void {\n    const messageId = bMessage.messageId as string;\n\n    const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);\n\n    if (messagesForLink == null) {\n      return;\n    }\n\n    this._stopAndRemoveById(linkEntity, messagesForLink, messageId);\n  }\n\n  /**\n   * Starts lock renewal for a single message.\n   *\n   * @param bMessage - The message whose lock renewal we will start.\n   */\n  start(\n    linkEntity: MinimalLink,\n    bMessage: RenewableMessageProperties,\n    onError: OnErrorNoContext\n  ): void {\n    try {\n      const logPrefix = linkEntity.logPrefix;\n\n      if (bMessage.lockToken == null) {\n        throw new Error(\n          `Can't start auto lock renewal for message with message id '${bMessage.messageId}' since it does not have a lock token.`\n        );\n      }\n\n      const lockToken = bMessage.lockToken;\n      const linkMessageMap = this._getOrCreateMapForLink(linkEntity);\n      // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.\n      // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInMs\n      // - We should be able to clear the renewal timer when the user's message handler\n      // is done (whether it succeeds or fails).\n      // Setting the messageId with undefined value in the linkMessageMap because we\n      // track state by checking the presence of messageId in the map. It is removed from the map\n      // when an attempt is made to settle the message (either by the user or by the sdk) OR\n      // when the execution of user's message handler completes.\n      linkMessageMap.set(bMessage.messageId as string, undefined);\n\n      logger.verbose(\n        `${logPrefix} message with id '${\n          bMessage.messageId\n        }' is locked until ${bMessage.lockedUntilUtc!.toString()}.`\n      );\n      const totalAutoLockRenewDuration = Date.now() + this._maxAutoRenewDurationInMs;\n      logger.verbose(\n        `${logPrefix} Total autolockrenew duration for message with id '${\n          bMessage.messageId\n        }' is: ${new Date(totalAutoLockRenewDuration).toString()}`\n      );\n\n      const autoRenewLockTask = (): void => {\n        const renewalNeededToMaintainLock =\n          // if the lock expires _after_ our max auto-renew duration there's no reason to\n          // spin up an auto-renewer - it's already held for the duration.\n          new Date(totalAutoLockRenewDuration) > bMessage.lockedUntilUtc!;\n\n        // once we've exceeded the max amount of time we'll renew we can stop.\n        const haventExceededMaxLockRenewalTime = Date.now() < totalAutoLockRenewDuration;\n\n        if (renewalNeededToMaintainLock && haventExceededMaxLockRenewalTime) {\n          if (linkMessageMap.has(bMessage.messageId as string)) {\n            // TODO: We can run into problems with clock skew between the client and the server.\n            // It would be better to calculate the duration based on the \"lockDuration\" property\n            // of the queue. However, we do not have the management plane of the client ready for\n            // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.\n            const amount = this._calculateRenewAfterDuration(bMessage.lockedUntilUtc!);\n\n            logger.verbose(\n              `${logPrefix} Sleeping for ${amount} milliseconds while renewing the lock for message with id '${bMessage.messageId}'`\n            );\n            // Setting the value of the messageId to the actual timer. This will be cleared when\n            // an attempt is made to settle the message (either by the user or by the sdk) OR\n            // when the execution of user's message handler completes.\n            const autoRenewTimer = setTimeout(async () => {\n              try {\n                logger.verbose(\n                  `${logPrefix} Attempting to renew the lock for message with id '${bMessage.messageId}'.`\n                );\n\n                bMessage.lockedUntilUtc = await this._context\n                  .getManagementClient(linkEntity.entityPath)\n                  .renewLock(lockToken, {\n                    associatedLinkName: linkEntity.name,\n                  });\n                logger.verbose(\n                  `${logPrefix} Successfully renewed the lock for message with id '${bMessage.messageId}'. Starting next auto-lock-renew cycle for message.`\n                );\n\n                autoRenewLockTask();\n              } catch (err) {\n                logger.logError(\n                  err,\n                  `${logPrefix} An error occurred while auto renewing the message lock '${bMessage.lockToken}' for message with id '${bMessage.messageId}'`\n                );\n                onError(err);\n              }\n            }, amount);\n\n            // Prevent the active Timer from keeping the Node.js event loop active.\n            if (typeof autoRenewTimer.unref === \"function\") {\n              autoRenewTimer.unref();\n            }\n\n            linkMessageMap.set(bMessage.messageId as string, autoRenewTimer);\n          } else {\n            logger.verbose(\n              `${logPrefix} Looks like the message lock renew timer has already been cleared for message with id '${bMessage.messageId}'.`\n            );\n          }\n        } else {\n          logger.verbose(\n            `${logPrefix} Current time ${new Date()} exceeds the total autolockrenew duration ${new Date(\n              totalAutoLockRenewDuration\n            )} for message with messageId '${\n              bMessage.messageId\n            }'. Hence we will stop the autoLockRenewTask.`\n          );\n\n          this.stop(linkEntity, bMessage);\n        }\n      };\n\n      // start\n      autoRenewLockTask();\n    } catch (err) {\n      onError(err);\n    }\n  }\n\n  private _getOrCreateMapForLink(linkEntity: MinimalLink): Map<string, NodeJS.Timer | undefined> {\n    if (!this._messageRenewLockTimers.has(linkEntity.name)) {\n      this._messageRenewLockTimers.set(\n        linkEntity.name,\n        new Map<string, NodeJS.Timer | undefined>()\n      );\n    }\n\n    return this._messageRenewLockTimers.get(linkEntity.name)!;\n  }\n\n  private _stopAndRemoveById(\n    linkEntity: MinimalLink,\n    linkMessageMap: Map<string, NodeJS.Timer | undefined>,\n    messageId: string | undefined\n  ): void {\n    if (messageId == null) {\n      throw new Error(\"Failed to stop auto lock renewal - no message ID\");\n    }\n\n    // TODO: messageId doesn't actually need to be unique. Perhaps we should use lockToken\n    // instead?\n    if (linkMessageMap.has(messageId)) {\n      clearTimeout(linkMessageMap.get(messageId) as NodeJS.Timer);\n      logger.verbose(\n        `${linkEntity.logPrefix} Cleared the message renew lock timer for message with id '${messageId}'.`\n      );\n      linkMessageMap.delete(messageId);\n    }\n  }\n}\n"]}