{"version":3,"file":"instrumentServiceBusMessage.js","sourceRoot":"","sources":["../../../src/diagnostics/instrumentServiceBusMessage.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EACL,uCAAuC,EACvC,cAAc,EAId,QAAQ,GACT,MAAM,qBAAqB,CAAC;AAK7B,OAAO,EAAE,oBAAoB,EAAE,MAAM,WAAW,CAAC;AAEjD;;GAEG;AACH,MAAM,CAAC,MAAM,oBAAoB,GAAG,eAAe,CAAC;AAEpD;;;;GAIG;AACH,MAAM,UAAU,uCAAuC,CACrD,OAA0B;IAE1B,IAAI,CAAC,OAAO,CAAC,qBAAqB,IAAI,CAAC,OAAO,CAAC,qBAAqB,CAAC,oBAAoB,CAAC,EAAE;QAC1F,OAAO;KACR;IAED,MAAM,YAAY,GAAG,OAAO,CAAC,qBAAqB,CAAC,oBAAoB,CAAW,CAAC;IACnF,OAAO,uCAAuC,CAAC,YAAY,CAAC,CAAC;AAC/D,CAAC;AAED;;;;;;GAMG;AACH,QAAQ,CAAC,CAAC,mBAAmB,CAC3B,gBAAyE;IAEzE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAE;QACpC,MAAM,gBAAgB,CAAC;KACxB;SAAM;QACL,KAAK,MAAM,OAAO,IAAI,gBAAgB,EAAE;YACtC,MAAM,OAAO,CAAC;SACf;KACF;AACH,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,oBAAoB,CAClC,gBAAyE;AACzE,2EAA2E;AAC3E,6EAA6E;AAC7E,4BAA4B;AAC5B,QAAgD,EAChD,gBAA2D,EAC3D,OAA8B;;IAE9B,MAAM,KAAK,GAAW,EAAE,CAAC;IAEzB,KAAK,MAAM,eAAe,IAAI,mBAAmB,CAAC,gBAAgB,CAAC,EAAE;QACnE,MAAM,WAAW,GAAG,uCAAuC,CAAC,eAAe,CAAC,CAAC;QAE7E,IAAI,WAAW,IAAI,IAAI,EAAE;YACvB,SAAS;SACV;QAED,KAAK,CAAC,IAAI,CAAC;YACT,OAAO,EAAE,WAAW;YACpB,UAAU,EAAE;gBACV,YAAY,EAAE,MAAA,eAAe,CAAC,eAAe,0CAAE,OAAO,EAAE;aACzD;SACF,CAAC,CAAC;KACJ;IAED,MAAM,EAAE,IAAI,EAAE,GAAG,oBAAoB,CACnC,SAAS,EACT,OAAO,EACP,QAAQ,CAAC,UAAU,EACnB,gBAAgB,CAAC,IAAI,EACrB;QACE,IAAI,EAAE,QAAQ,CAAC,QAAQ;QACvB,KAAK;KACN,CACF,CAAC;IAEF,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,0BAA0B,CACxC,gBAAyE,EACzE,QAAgD,EAChD,gBAA2D,EAC3D,OAA8B;IAE9B,MAAM,IAAI,GAAG,oBAAoB,CAAC,gBAAgB,EAAE,QAAQ,EAAE,gBAAgB,EAAE,OAAO,CAAC,CAAC;IACzF,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,cAAc,CAAC,EAAE,EAAE,CAAC,CAAC;IAC5C,IAAI,CAAC,GAAG,EAAE,CAAC;AACb,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  extractSpanContextFromTraceParentHeader,\n  SpanStatusCode,\n  Link,\n  Span,\n  SpanContext,\n  SpanKind,\n} from \"@azure/core-tracing\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { ServiceBusReceiver } from \"../receivers/receiver\";\nimport { ServiceBusMessage, ServiceBusReceivedMessage } from \"../serviceBusMessage\";\nimport { createServiceBusSpan } from \"./tracing\";\n\n/**\n * @hidden\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * Extracts the `SpanContext` from an `ServiceBusMessage` if the context exists.\n * @param message - An individual `ServiceBusMessage` object.\n * @internal\n */\nexport function extractSpanContextFromServiceBusMessage(\n  message: ServiceBusMessage\n): SpanContext | undefined {\n  if (!message.applicationProperties || !message.applicationProperties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = message.applicationProperties[TRACEPARENT_PROPERTY] as string;\n  return extractSpanContextFromTraceParentHeader(diagnosticId);\n}\n\n/**\n * Provides an iterable over messages, whether it is a single message or multiple\n * messages.\n *\n * @param receivedMessages - A single message or a set of messages\n * @internal\n */\nfunction* getReceivedMessages(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[]\n): Iterable<ServiceBusReceivedMessage> {\n  if (!Array.isArray(receivedMessages)) {\n    yield receivedMessages;\n  } else {\n    for (const message of receivedMessages) {\n      yield message;\n    }\n  }\n}\n\n/**\n * A span that encompasses the period when the message has been received and\n * is being processed.\n *\n * NOTE: The amount of time the user would be considered processing the message is\n * not always clear - in that case the span will have a very short lifetime\n * since we'll start the span when we receive the message and end it when we\n * give the message to the user.\n *\n * @internal\n */\nexport function createProcessingSpan(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[],\n  // NOTE: the connectionConfig also has an entityPath property but that only\n  // represents the optional entityPath in their connection string which is NOT\n  // what we want for tracing.\n  receiver: Pick<ServiceBusReceiver, \"entityPath\">,\n  connectionConfig: Pick<ConnectionContext[\"config\"], \"host\">,\n  options?: OperationOptionsBase\n): Span {\n  const links: Link[] = [];\n\n  for (const receivedMessage of getReceivedMessages(receivedMessages)) {\n    const spanContext = extractSpanContextFromServiceBusMessage(receivedMessage);\n\n    if (spanContext == null) {\n      continue;\n    }\n\n    links.push({\n      context: spanContext,\n      attributes: {\n        enqueuedTime: receivedMessage.enqueuedTimeUtc?.getTime(),\n      },\n    });\n  }\n\n  const { span } = createServiceBusSpan(\n    \"process\",\n    options,\n    receiver.entityPath,\n    connectionConfig.host,\n    {\n      kind: SpanKind.CONSUMER,\n      links,\n    }\n  );\n\n  return span;\n}\n\n/**\n * Creates and immediately ends a processing span. Used when\n * the 'processing' occurs outside of our control so we don't\n * know the scope.\n *\n * @internal\n */\nexport function createAndEndProcessingSpan(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[],\n  receiver: Pick<ServiceBusReceiver, \"entityPath\">,\n  connectionConfig: Pick<ConnectionContext[\"config\"], \"host\">,\n  options?: OperationOptionsBase\n): void {\n  const span = createProcessingSpan(receivedMessages, receiver, connectionConfig, options);\n  span.setStatus({ code: SpanStatusCode.OK });\n  span.end();\n}\n"]}