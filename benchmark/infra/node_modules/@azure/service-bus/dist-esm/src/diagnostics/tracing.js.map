{"version":3,"file":"tracing.js","sourceRoot":"","sources":["../../../src/diagnostics/tracing.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"@azure/core-http\";\nimport {\n  createSpanFunction,\n  extractSpanContextFromTraceParentHeader,\n  getTraceParentHeader,\n  SpanOptions,\n  setSpan,\n  Span,\n  SpanContext,\n  SpanKind,\n  context as otContext,\n  setSpanContext,\n} from \"@azure/core-tracing\";\nimport { ServiceBusMessage } from \"../serviceBusMessage\";\nimport { TryAddOptions } from \"../modelsToBeSharedWithEventHubs\";\n\n/**\n * Creates a span using the global tracer.\n * @internal\n */\nexport const createSpan = createSpanFunction({\n  packagePrefix: \"Azure.ServiceBus\",\n  namespace: \"Microsoft.ServiceBus\",\n});\n\n/**\n * @internal\n */\nexport function createMessageSpan(\n  operationOptions: OperationOptions,\n  entityPath: string,\n  host: string\n): ReturnType<typeof createServiceBusSpan> {\n  return createServiceBusSpan(\"message\", operationOptions, entityPath, host, {\n    kind: SpanKind.PRODUCER,\n  });\n}\n\n/**\n * Creates an EventHubs specific span, with peer.address and message_bus.destination filled out.\n * @internal\n */\nexport function createServiceBusSpan(\n  operationName: string,\n  operationOptions: OperationOptions | undefined,\n  entityPath: string,\n  host: string,\n  additionalSpanOptions?: SpanOptions\n): { span: Span; updatedOptions: OperationOptions } {\n  const { span, updatedOptions } = createSpan(operationName, {\n    ...operationOptions,\n    tracingOptions: {\n      ...operationOptions?.tracingOptions,\n      spanOptions: {\n        // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n        ...(operationOptions?.tracingOptions as any)?.spanOptions,\n        ...additionalSpanOptions,\n      },\n    },\n  });\n\n  span.setAttribute(\"message_bus.destination\", entityPath);\n  span.setAttribute(\"peer.address\", host);\n\n  return {\n    span,\n    updatedOptions,\n  };\n}\n\n/**\n * @internal\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * @hidden\n */\nexport interface InstrumentableMessage {\n  /**\n   * The application specific properties which can be\n   * used for custom message metadata.\n   */\n  applicationProperties?: { [key: string]: number | boolean | string | Date | null };\n}\n\n/**\n * Instruments an AMQP message with a proper `Diagnostic-Id` for tracing.\n *\n * @hidden\n */\nexport function instrumentMessage<T extends InstrumentableMessage>(\n  message: T,\n  options: OperationOptions,\n  entityPath: string,\n  host: string\n): {\n  /**\n   * If instrumentation was done, a copy of the message with\n   * message.applicationProperties['Diagnostic-Id'] filled\n   * out appropriately.\n   */\n  message: T;\n\n  /**\n   * A valid SpanContext if this message should be linked to a parent span, or undefined otherwise.\n   */\n  spanContext: SpanContext | undefined;\n} {\n  const previouslyInstrumented = Boolean(\n    message.applicationProperties && message.applicationProperties[TRACEPARENT_PROPERTY]\n  );\n\n  if (previouslyInstrumented) {\n    return {\n      message,\n      spanContext: undefined,\n    };\n  }\n\n  const { span: messageSpan } = createMessageSpan(options, entityPath, host);\n\n  try {\n    if (!messageSpan.isRecording()) {\n      return {\n        message,\n        spanContext: undefined,\n      };\n    }\n\n    const traceParent = getTraceParentHeader(messageSpan.spanContext());\n\n    if (traceParent) {\n      // create a copy so the original isn't modified\n      message = {\n        ...message,\n        applicationProperties: {\n          ...message.applicationProperties,\n          [TRACEPARENT_PROPERTY]: traceParent,\n        },\n      };\n    }\n\n    return {\n      message,\n      spanContext: messageSpan.spanContext(),\n    };\n  } finally {\n    messageSpan.end();\n  }\n}\n\n/**\n * Extracts the `SpanContext` from an `ServiceBusMessage` if the context exists.\n * @param message - An individual `ServiceBusMessage` object.\n * @internal\n */\nexport function extractSpanContextFromServiceBusMessage(\n  message: ServiceBusMessage\n): SpanContext | undefined {\n  if (!message.applicationProperties || !message.applicationProperties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = message.applicationProperties[TRACEPARENT_PROPERTY] as string;\n  return extractSpanContextFromTraceParentHeader(diagnosticId);\n}\n\n/**\n * Converts TryAddOptions into the modern shape (OperationOptions) when needed.\n * (this is something we can eliminate at the next major release of SB _or_ when\n * we release with the GA version of opentelemetry).\n *\n * @internal\n */\nexport function convertTryAddOptionsForCompatibility(tryAddOptions: TryAddOptions): TryAddOptions {\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore: parentSpan is deprecated and this is compat code to translate it until we can get rid of it.\n  const legacyParentSpanOrSpanContext = tryAddOptions.parentSpan;\n\n  /*\n    Our goal here is to offer compatibility but there is a case where a user might accidentally pass\n    _both_ sets of options. We'll assume they want the OperationTracingOptions code path in that case.\n\n    Example of accidental span passing:\n\n    const someOptionsPassedIntoTheirFunction = {\n       parentSpan: span;      // set somewhere else in their code\n    }\n\n    function takeSomeOptionsFromSomewhere(someOptionsPassedIntoTheirFunction) {\n      \n      batch.tryAddMessage(message, { \n        // \"runtime\" blend of options from some other part of their app\n        ...someOptionsPassedIntoTheirFunction,      // parentSpan comes along for the ride...\n\n        tracingOptions: {\n          // thank goodness, I'm doing this right! (thinks the developer)\n          spanOptions: {\n            context: context\n          }\n        }\n      });\n    }\n\n    And now they've accidentally been opted into the legacy code path even though they think\n    they're using the modern code path.\n    \n    This does kick the can down the road a bit - at some point we will be putting them in this\n    situation where things looked okay but their spans are becoming unparented but we can \n    try to announce this (and other changes related to tracing) in our next big rev.\n  */\n\n  if (!legacyParentSpanOrSpanContext || tryAddOptions.tracingOptions) {\n    // assume that the options are already in the modern shape even if (possibly)\n    // they were still specifying `parentSpan`\n    return tryAddOptions;\n  }\n\n  const convertedOptions: TryAddOptions = {\n    ...tryAddOptions,\n    tracingOptions: {\n      tracingContext: isSpan(legacyParentSpanOrSpanContext)\n        ? setSpan(otContext.active(), legacyParentSpanOrSpanContext)\n        : setSpanContext(otContext.active(), legacyParentSpanOrSpanContext),\n    },\n  };\n\n  return convertedOptions;\n}\n\nfunction isSpan(possibleSpan: Span | SpanContext | undefined): possibleSpan is Span {\n  if (possibleSpan == null) {\n    return false;\n  }\n\n  const x = possibleSpan as Span;\n  return typeof x.spanContext === \"function\";\n}\n"]}