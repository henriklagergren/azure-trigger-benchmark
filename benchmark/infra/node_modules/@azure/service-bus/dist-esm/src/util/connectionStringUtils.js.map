{"version":3,"file":"connectionStringUtils.js","sourceRoot":"","sources":["../../../src/util/connectionStringUtils.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,qBAAqB,EAAE,MAAM,kBAAkB,CAAC;AA2CzD;;;;;GAKG;AACH,MAAM,UAAU,+BAA+B,CAC7C,gBAAwB;IAExB,MAAM,YAAY,GAAG,qBAAqB,CAMvC,gBAAgB,CAAC,CAAC;IACrB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE;QAC1B,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;KACnE;IAED,IAAI,YAAY,CAAC,qBAAqB,EAAE;QACtC,IAAI,YAAY,CAAC,eAAe,IAAI,YAAY,CAAC,mBAAmB,EAAE;YACpE,MAAM,IAAI,KAAK,CACb,oFAAoF,CACrF,CAAC;SACH;KACF;SAAM,IAAI,YAAY,CAAC,eAAe,IAAI,CAAC,YAAY,CAAC,mBAAmB,EAAE;QAC5E,MAAM,IAAI,KAAK,CAAC,yEAAyE,CAAC,CAAC;KAC5F;SAAM,IAAI,CAAC,YAAY,CAAC,eAAe,IAAI,YAAY,CAAC,mBAAmB,EAAE;QAC5E,MAAM,IAAI,KAAK,CACb,iFAAiF,CAClF,CAAC;KACH;IAED,MAAM,MAAM,GAAyC;QACnD,uBAAuB,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;QAC/E,QAAQ,EAAE,YAAY,CAAC,QAAQ;KAChC,CAAC;IACF,IAAI,YAAY,CAAC,UAAU,EAAE;QAC3B,MAAM,CAAC,UAAU,GAAG,YAAY,CAAC,UAAU,CAAC;KAC7C;IACD,IAAI,YAAY,CAAC,qBAAqB,EAAE;QACtC,MAAM,CAAC,qBAAqB,GAAG,YAAY,CAAC,qBAAqB,CAAC;KACnE;IACD,IAAI,YAAY,CAAC,eAAe,IAAI,YAAY,CAAC,mBAAmB,EAAE;QACpE,MAAM,CAAC,eAAe,GAAG,YAAY,CAAC,eAAe,CAAC;QACtD,MAAM,CAAC,mBAAmB,GAAG,YAAY,CAAC,mBAAmB,CAAC;KAC/D;IACD,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { parseConnectionString } from \"@azure/core-amqp\";\n\n/**\n * The set of properties that comprise a Service Bus connection string.\n */\nexport interface ServiceBusConnectionStringProperties {\n  /**\n   * The fully qualified Service Bus namespace extracted from the \"Endpoint\" in the\n   * connection string. This is likely to be similar to `{yournamespace}.servicebus.windows.net`.\n   * This is typically used to construct the ServiceBusClient.\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The value for \"Endpoint\" in the connection string.\n   */\n  endpoint: string;\n  /**\n   * The value for \"EntityPath\" in the connection string which would be the name of the queue or\n   * topic associated with the connection string.\n   * Connection string from a Shared Access Policy created at the namespace level\n   * will not have the EntityPath in it.\n   */\n  entityPath?: string;\n  /**\n   * The value for \"SharedAccessKey\" in the connection string. This along with the \"SharedAccessKeyName\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKey?: string;\n  /**\n   * The value for \"SharedAccessKeyName\" in the connection string. This along with the \"SharedAccessKey\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKeyName?: string;\n  /**\n   * The value for \"SharedAccessSignature\" in the connection string. This is typically not present in the\n   * connection string generated for a Shared Access Policy. It is instead generated by the\n   * user and appended to the connection string for ease of use.\n   */\n  sharedAccessSignature?: string;\n}\n\n/**\n * Parses given connection string into the different properties applicable to Azure Service Bus.\n * The properties are useful to then construct a ServiceBusClient.\n * @param connectionString - The connection string associated with the Shared Access Policy created\n * for the Service Bus namespace, queue or topic.\n */\nexport function parseServiceBusConnectionString(\n  connectionString: string\n): ServiceBusConnectionStringProperties {\n  const parsedResult = parseConnectionString<{\n    Endpoint: string;\n    EntityPath?: string;\n    SharedAccessSignature?: string;\n    SharedAccessKey?: string;\n    SharedAccessKeyName?: string;\n  }>(connectionString);\n  if (!parsedResult.Endpoint) {\n    throw new Error(\"Connection string should have an Endpoint key.\");\n  }\n\n  if (parsedResult.SharedAccessSignature) {\n    if (parsedResult.SharedAccessKey || parsedResult.SharedAccessKeyName) {\n      throw new Error(\n        \"Connection string cannot have both SharedAccessSignature and SharedAccessKey keys.\"\n      );\n    }\n  } else if (parsedResult.SharedAccessKey && !parsedResult.SharedAccessKeyName) {\n    throw new Error(\"Connection string with SharedAccessKey should have SharedAccessKeyName.\");\n  } else if (!parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {\n    throw new Error(\n      \"Connection string with SharedAccessKeyName should have SharedAccessKey as well.\"\n    );\n  }\n\n  const output: ServiceBusConnectionStringProperties = {\n    fullyQualifiedNamespace: (parsedResult.Endpoint.match(\".*://([^/]*)\") || [])[1],\n    endpoint: parsedResult.Endpoint,\n  };\n  if (parsedResult.EntityPath) {\n    output.entityPath = parsedResult.EntityPath;\n  }\n  if (parsedResult.SharedAccessSignature) {\n    output.sharedAccessSignature = parsedResult.SharedAccessSignature;\n  }\n  if (parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {\n    output.sharedAccessKey = parsedResult.SharedAccessKey;\n    output.sharedAccessKeyName = parsedResult.SharedAccessKeyName;\n  }\n  return output;\n}\n"]}