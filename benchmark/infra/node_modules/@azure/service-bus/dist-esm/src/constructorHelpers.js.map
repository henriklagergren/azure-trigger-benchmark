{"version":3,"file":"constructorHelpers.js","sourceRoot":"","sources":["../../src/constructorHelpers.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EACL,gBAAgB,EAChB,sBAAsB,GAIvB,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EACL,oBAAoB,EACpB,eAAe,GAIhB,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EAAE,iBAAiB,EAAE,MAAM,qBAAqB,CAAC;AAExD,OAAO,EACL,+BAA+B,GAEhC,MAAM,8BAA8B,CAAC;AAkCtC;;;GAGG;AACH,MAAM,UAAU,uBAAuB,CACrC,gBAAwB,EACxB,UAA8C,EAC9C,OAAgC;;IAEhC,MAAM,MAAM,GAAG,gBAAgB,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;IAEzD,MAAM,CAAC,SAAS,GAAG,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,gBAAgB,0CAAE,SAAS,CAAC;IACxD,MAAM,CAAC,qBAAqB,GAAG,uBAAuB,CAAC;IACvD,MAAM,CAAC,2BAA2B,GAAG,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,gBAAgB,0CAAE,2BAA2B,CAAC;IAE5F,OAAO,iBAAiB,CAAC,MAAM,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;AAC/D,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,0CAA0C,CACxD,gBAAwB,EACxB,UAAmC,EAAE;IAErC,MAAM,MAAM,GAAG,+BAA+B,CAAC,gBAAgB,CAG9D,CAAC;IACF,MAAM,gBAAgB,GAAG,sBAAsB,CAAC,MAAM,CAAC,CAAC;IACxD,OAAO,uBAAuB,CAAC,gBAAgB,EAAE,gBAAgB,EAAE,OAAO,CAAC,CAAC;AAC9E,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,oCAAoC,CAClD,UAAgE,EAChE,IAAY,EACZ,UAAmC,EAAE;IAErC,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;QAC5B,MAAM,IAAI,SAAS,CAAC,kCAAkC,CAAC,CAAC;KACzD;IAED,IAAI,aAAiD,CAAC;IAEtD,6DAA6D;IAC7D,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;QACvB,IAAI,IAAI,GAAG,CAAC;KACb;IACD,IAAI,oBAAoB,CAAC,UAAU,CAAC,IAAI,eAAe,CAAC,UAAU,CAAC,EAAE;QACnE,aAAa,GAAG,sBAAsB,CAAC,UAAU,CAAC,CAAC;KACpD;SAAM;QACL,aAAa,GAAG,UAAU,CAAC;KAC5B;IACD,MAAM,gBAAgB,GAAG,iBAAiB,IAAI,sEAAsE,CAAC;IACrH,OAAO,uBAAuB,CAAC,gBAAgB,EAAE,aAAa,EAAE,OAAO,CAAC,CAAC;AAC3E,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,iCAAiC,CAAC,gBAAwB;IACxE,MAAM,eAAe,GAAG,gBAAgB,CAAC,KAAK,CAAC,4BAA4B,CAAC,CAAC;IAE7E,IAAI,eAAe,IAAI,IAAI,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;QAC3D,OAAO,eAAe,CAAC,CAAC,CAAC,CAAC;KAC3B;SAAM;QACL,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;KACpE;AACH,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  ConnectionConfig,\n  createSasTokenProvider,\n  RetryOptions,\n  SasTokenProvider,\n  WebSocketOptions,\n} from \"@azure/core-amqp\";\nimport {\n  isNamedKeyCredential,\n  isSASCredential,\n  NamedKeyCredential,\n  SASCredential,\n  TokenCredential,\n} from \"@azure/core-auth\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { UserAgentOptions } from \"@azure/core-http\";\nimport {\n  parseServiceBusConnectionString,\n  ServiceBusConnectionStringProperties,\n} from \"./util/connectionStringUtils\";\n\n/**\n * Describes the options that can be provided while creating the ServiceBusClient.\n *\n * - `webSocketOptions` : Options to configure the channelling of the AMQP connection over Web Sockets.\n *    - `websocket`     : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n * over a WebSocket.\n *    - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n * over a WebSocket.\n * - `retryOptions`     : The retry options for all the operations on the client.\n *    - `maxRetries` : The number of times the operation can be retried in case of a retryable error.\n *    - `maxRetryDelayInMs`: The maximum delay between retries. Applicable only when performing exponential retries.\n *    - `mode`: Which retry mode to apply, specified by the `RetryMode` enum. Options are `Exponential` and `Fixed`. Defaults to `Fixed`.\n *    - `retryDelayInMs`: Amount of time to wait in milliseconds before making the next attempt. When `mode` is set to `Exponential`,\n *       this is used to compute the exponentially increasing delays between retries. Default: 30000 milliseconds.\n *    - `timeoutInMs`: Amount of time in milliseconds to wait before the operation times out. This will trigger a retry if there are any\n *       retry attempts remaining. Minimum value: 60000 milliseconds.\n */\nexport interface ServiceBusClientOptions {\n  /**\n   * Retry policy options that determine the mode, number of retries, retry interval etc.\n   */\n  retryOptions?: RetryOptions;\n  /**\n   * Options to configure the channelling of the AMQP connection over Web Sockets.\n   */\n  webSocketOptions?: WebSocketOptions;\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentOptions;\n}\n\n/**\n * @internal\n *\n */\nexport function createConnectionContext(\n  connectionString: string,\n  credential: SasTokenProvider | TokenCredential,\n  options: ServiceBusClientOptions\n): ConnectionContext {\n  const config = ConnectionConfig.create(connectionString);\n\n  config.webSocket = options?.webSocketOptions?.webSocket;\n  config.webSocketEndpointPath = \"$servicebus/websocket\";\n  config.webSocketConstructorOptions = options?.webSocketOptions?.webSocketConstructorOptions;\n\n  return ConnectionContext.create(config, credential, options);\n}\n\n/**\n * @internal\n */\nexport function createConnectionContextForConnectionString(\n  connectionString: string,\n  options: ServiceBusClientOptions = {}\n): ConnectionContext {\n  const parsed = parseServiceBusConnectionString(connectionString) as Required<\n    | Pick<ServiceBusConnectionStringProperties, \"sharedAccessKey\" | \"sharedAccessKeyName\">\n    | Pick<ServiceBusConnectionStringProperties, \"sharedAccessSignature\">\n  >;\n  const sasTokenProvider = createSasTokenProvider(parsed);\n  return createConnectionContext(connectionString, sasTokenProvider, options);\n}\n\n/**\n *\n * @internal\n */\nexport function createConnectionContextForCredential(\n  credential: TokenCredential | NamedKeyCredential | SASCredential,\n  host: string,\n  options: ServiceBusClientOptions = {}\n): ConnectionContext {\n  if (typeof host !== \"string\") {\n    throw new TypeError(\"`host` parameter is not a string\");\n  }\n\n  let tokenProvider: TokenCredential | SasTokenProvider;\n\n  // host, credential and options based constructor was invoked\n  if (!host.endsWith(\"/\")) {\n    host += \"/\";\n  }\n  if (isNamedKeyCredential(credential) || isSASCredential(credential)) {\n    tokenProvider = createSasTokenProvider(credential);\n  } else {\n    tokenProvider = credential;\n  }\n  const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;`;\n  return createConnectionContext(connectionString, tokenProvider, options);\n}\n\n/**\n * Parses a connection string and extracts the EntityPath named entity out.\n * @param connectionString - An entity specific Service Bus connection string.\n * @internal\n */\nexport function getEntityNameFromConnectionString(connectionString: string): string {\n  const entityPathMatch = connectionString.match(/^.+EntityPath=(.+?);{0,1}$/);\n\n  if (entityPathMatch != null && entityPathMatch.length === 2) {\n    return entityPathMatch[1];\n  } else {\n    throw new Error(\"No entity name present in the connection string\");\n  }\n}\n"]}