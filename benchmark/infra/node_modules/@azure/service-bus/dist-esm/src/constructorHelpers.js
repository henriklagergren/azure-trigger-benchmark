// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { ConnectionConfig, createSasTokenProvider, } from "@azure/core-amqp";
import { isNamedKeyCredential, isSASCredential, } from "@azure/core-auth";
import { ConnectionContext } from "./connectionContext";
import { parseServiceBusConnectionString, } from "./util/connectionStringUtils";
/**
 * @internal
 *
 */
export function createConnectionContext(connectionString, credential, options) {
    var _a, _b;
    const config = ConnectionConfig.create(connectionString);
    config.webSocket = (_a = options === null || options === void 0 ? void 0 : options.webSocketOptions) === null || _a === void 0 ? void 0 : _a.webSocket;
    config.webSocketEndpointPath = "$servicebus/websocket";
    config.webSocketConstructorOptions = (_b = options === null || options === void 0 ? void 0 : options.webSocketOptions) === null || _b === void 0 ? void 0 : _b.webSocketConstructorOptions;
    return ConnectionContext.create(config, credential, options);
}
/**
 * @internal
 */
export function createConnectionContextForConnectionString(connectionString, options = {}) {
    const parsed = parseServiceBusConnectionString(connectionString);
    const sasTokenProvider = createSasTokenProvider(parsed);
    return createConnectionContext(connectionString, sasTokenProvider, options);
}
/**
 *
 * @internal
 */
export function createConnectionContextForCredential(credential, host, options = {}) {
    if (typeof host !== "string") {
        throw new TypeError("`host` parameter is not a string");
    }
    let tokenProvider;
    // host, credential and options based constructor was invoked
    if (!host.endsWith("/")) {
        host += "/";
    }
    if (isNamedKeyCredential(credential) || isSASCredential(credential)) {
        tokenProvider = createSasTokenProvider(credential);
    }
    else {
        tokenProvider = credential;
    }
    const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;`;
    return createConnectionContext(connectionString, tokenProvider, options);
}
/**
 * Parses a connection string and extracts the EntityPath named entity out.
 * @param connectionString - An entity specific Service Bus connection string.
 * @internal
 */
export function getEntityNameFromConnectionString(connectionString) {
    const entityPathMatch = connectionString.match(/^.+EntityPath=(.+?);{0,1}$/);
    if (entityPathMatch != null && entityPathMatch.length === 2) {
        return entityPathMatch[1];
    }
    else {
        throw new Error("No entity name present in the connection string");
    }
}
//# sourceMappingURL=constructorHelpers.js.map